{"task_id": "kotlin/0", "language": "kotlin", "completion": "fun belowZero(operations: List<Any>): Boolean {\n    var balance = 0 // Initial balance is 0\n    for (operation in operations) {\n        when (operation) {\n            is Int -> { // Deposit/Withdrawal operation\n                balance += operation\n                if (balance < 0) return true // If balance goes below zero, return True\n            }\n        }\n    }\n    return false // If we reach this point, the balance never went below zero\n}"}
{"task_id": "kotlin/1", "language": "kotlin", "completion": "fun sumProduct(numbers: List<Any>): Pair<Int, Int> {\n    var sum = 0\n    var product = 1\n\n    numbers.forEach { number ->\n        when (number) {\n            is Int -> {\n                sum += number\n                product *= number\n            }\n            else -> throw IllegalArgumentException(\"List must only contain integers\")\n        }\n    }\n\n    return Pair(sum, product)\n}"}
{"task_id": "kotlin/2", "language": "kotlin", "completion": "fun stringXor(a: String, b: String): String {\n    return a.map { (it.toInt() xor b[b.indexOf(it)].toInt()).toString(2).padStart(1, '0') }.joinToString(\"\")\n}"}
{"task_id": "kotlin/3", "language": "kotlin", "completion": "fun longest(strings: List<Any>): String? {\n    if (strings.isEmpty()) return null\n\n    return strings.maxByOrNull { it.toString().length } as String?\n}"}
{"task_id": "kotlin/4", "language": "kotlin", "completion": "fun greatestCommonDivisor(a: Int, b: Int): Int {\n    if (b == 0) return a\n    return greatestCommonDivisor(b, a % b)\n}"}
{"task_id": "kotlin/5", "language": "kotlin", "completion": "fun sortNumbers(numbers: String): String {\n    val numbersArray = numbers.split(\" \").map { it.toLowerCase() }.filter { it in \"eins zwei drei vier f\u00fcnf sechs sieben acht neun\" }\n    return numbersArray.sorted().joinToString(\" \")\n}\n\n>>> println(sortNumbers(\"three one five\"))\none three five"}
{"task_id": "kotlin/6", "language": "kotlin", "completion": "fun rescaleToUnit(numbers: List<Double>): List<Double> {\n    val min = numbers.min()!!\n    val max = numbers.max()!!\n\n    return numbers.map { (it - min) / (max - min) }\n}"}
{"task_id": "kotlin/7", "language": "kotlin", "completion": "fun flipCase(string: String): String {\n    return string.toLowerCase().reversed().toUpperCase()\n}"}
{"task_id": "kotlin/8", "language": "kotlin", "completion": "fun getPositive(l: List<Any>): List<Any> {\n    return l.filter { it as Any? == null || (it as Number).toInt() > 0 }\n}"}
{"task_id": "kotlin/9", "language": "kotlin", "completion": "fun isPrime(n: Int): Boolean {\n    if (n <= 1) return false // Primzahlen sind gr\u00f6\u00dfer als 1\n    if (n == 2) return true // 2 ist eine Primzahl\n\n    for (i in 2..Math.sqrt(n).toInt()) { // wir m\u00fcssen nur bis sqrt(n) gehen, da ein gr\u00f6\u00dferes Teiler von einem kleineren aus folgt\n        if (n % i == 0) return false // wenn n durch i teilbar ist, ist es keine Primzahl\n    }\n    return true // wenn niemand von den \u00fcberpr\u00fcften Zahlen eine Teilung gefunden hat, ist es eine Primzahl\n}"}
{"task_id": "kotlin/10", "language": "kotlin", "completion": "fun unique(l: List<Int>): List<Int> {\n    return l.toSet().toList()\n}"}
{"task_id": "kotlin/11", "language": "kotlin", "completion": "fun primeFib(n: Int): Int {\n    var fibNum = 0\n    var fibPrev = 1\n    var fibCurr = 1\n    var count = 0\n\n    while (true) {\n        if (isPrime(fibCurr)) {\n            count++\n            if (count == n) return fibCurr\n        }\n        fibPrev = fibCurr\n        fibCurr += fibPrev\n    }\n}\n\nfun isPrime(num: Int): Boolean {\n    if (num <= 1) return false\n    for (i in 2..Math.sqrt(num.toDouble()).toInt()) {\n        if (num % i == 0) return false\n    }\n    return true\n}"}
{"task_id": "kotlin/12", "language": "kotlin", "completion": "fun triplesSumToZero(l: List<Int>): Boolean {\n    l.distinct().forEach { a ->\n        val complement = -a\n        if (l.contains(complement)) {\n            val third = -(a + complement)\n            if (l.contains(third) && a != third) {\n                return true\n            }\n        }\n    }\n    return false\n}"}
{"task_id": "kotlin/13", "language": "kotlin", "completion": "fun pairsSumToZero(l: List<Int>): Boolean {\n    l.distinct().forEach { num ->\n        val complement = -num\n        if (l.contains(complement) && num != complement) {\n            return true\n        }\n    }\n    return false\n}"}
{"task_id": "kotlin/14", "language": "kotlin", "completion": "fun fib4(n: Int): Int {\n    if (n <= 1) return 0 // base cases\n    val dp = IntArray(n + 1)\n    dp[0] = 0; dp[1] = 0; dp[2] = 2; dp[3] = 0 // initial values\n\n    for (i in 4..n) {\n        dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3] + dp[i - 4]\n    }\n\n    return dp[n]\n}"}
{"task_id": "kotlin/15", "language": "kotlin", "completion": "fun median(l: List<Int>): Any {\n    val sortedList = l.sorted()\n    val middleIndex = sortedList.size / 2\n\n    if (sortedList.size % 2 == 0) { // wenn die Liste eine ungerade Anzahl von Elementen hat\n        return ((sortedList[middleIndex - 1] + sortedList[middleIndex]) / 2.0).toDouble()\n    } else { // wenn die Liste eine gerade Anzahl von Elementen hat\n        return sortedList[middleIndex].toDouble()\n    }\n}"}
{"task_id": "kotlin/16", "language": "kotlin", "completion": "fun isPalindrome(text: String): Boolean {\n    val cleanText = text.replace(Regex(\"[^a-zA-Z0-9]\"), \"\").toLowerCase()\n    return cleanText.equals(cleanText.reversed())\n}"}
{"task_id": "kotlin/17", "language": "kotlin", "completion": "fun removeVowels(text: String): String {\n    return text.toCharArray().filterNot { it.isVowel() }.joinToString()\n}\n\nprivate fun Char.isVowel(): Boolean {\n    val vowels = \"aeiouAEIOU\"\n    return vowels.contains(this)\n}"}
{"task_id": "kotlin/18", "language": "kotlin", "completion": "fun belowThreshold(l: List<Int>, t: Int): Boolean {\n    return l.all { it < t }\n}"}
{"task_id": "kotlin/19", "language": "kotlin", "completion": "fun add(x: Int, y: Int): Int {\n    return x + y\n}"}
{"task_id": "kotlin/20", "language": "kotlin", "completion": "fun sameChars(s0: String, s1: String): Boolean {\n    val set0 = s0.toCharArray().asSet()\n    val set1 = s1.toCharArray().asSet()\n\n    return set0 == set1\n}"}
{"task_id": "kotlin/21", "language": "kotlin", "completion": "fun fib(n: Int): Int {\n    if (n <= 1) return n\n    var a = 0\n    var b = 1\n    for (i in 2..n) {\n        val temp = b\n        b += a\n        a = temp\n    }\n    return b\n}"}
{"task_id": "kotlin/22", "language": "kotlin", "completion": "fun common(l1: List<Int>, l2: List<Any>): List<Any> {\n    return (l1.toSet() intersect l2.toSet()).toList()\n}"}
{"task_id": "kotlin/23", "language": "kotlin", "completion": "fun largestPrimeFactor(n: Int): Int {\n    var maxPrime = 1 // Initialize with the smallest prime number\n    for (i in 2..Math.sqrt(n.toDouble()).toInt()) { // Only need to check up to sqrt(n)\n        while (n % i == 0) { // If n is divisible by i, find its largest prime factor\n            val temp = i\n            var j = 2\n            while (j * j <= temp) {\n                if (temp % j == 0) {\n                    temp /= j\n                } else {\n                    j += 1\n                }\n            }\n            maxPrime = temp // Update the largest prime factor found so far\n            n /= i\n        }\n    }\n    return if (n > 1) n else maxPrime // If n is still greater than 1, it's the largest prime factor\n}"}
{"task_id": "kotlin/24", "language": "kotlin", "completion": "fun sumToN(n: Int): Int {\n    var result = 0\n    for (i in 1..n) {\n        result += i\n    }\n    return result\n}"}
{"task_id": "kotlin/25", "language": "kotlin", "completion": "fun derivative(xs: List<Int>): List<Any> {\n    val result = mutableListOf[Any>()\n    for (i in 1 until xs.size) {\n        result.add(i.toLong() * xs[i] * (xs.size - i).toLong())\n    }\n    return result\n}"}
{"task_id": "kotlin/26", "language": "kotlin", "completion": "fun fibfib(n: Int): Int {\n    if (n <= 1) return 0 // base cases\n    if (n == 2) return 1 // base case\n\n    var a = 0\n    var b = 0\n    var c = 1 // initial values for the recurrence relation\n\n    for (i in 3..n) {\n        val t = a + b + c // calculate the next value using the recurrence relation\n        a = b\n        b = c\n        c = t\n    }\n\n    return c // the n-th element of the FibFib sequence\n}"}
{"task_id": "kotlin/27", "language": "kotlin", "completion": "fun vowelsCount(s: String): Int {\n    var count = 0\n    for (c in s.toLowerCase()) {\n        when (c) {\n            'a', 'e', 'i', 'o', 'u' -> count++\n            'y' -> if (!s.endsWith(c.toString())) count++ // only increment if y is at the end of the string\n        }\n    }\n    return count\n}"}
{"task_id": "kotlin/28", "language": "kotlin", "completion": "fun search(lst: List<Int>): Int {\n    return lst.groupingBy { it }.eachCount().maxByOrNull { value -> value }?.key ?: -1\n}"}
{"task_id": "kotlin/29", "language": "kotlin", "completion": "fun triangleArea(a: Int, b: Int, c: Int): Any {\n    if (a + b > c && a + c > b && b + c > a) { // check if sides form a valid triangle\n        val s = (a + b + c) / 2.0 // calculate semi-perimeter\n        val area = Math.sqrt(s * (s - a) * (s - b) * (s - c)) // calculate area using Heron's formula\n        return \"%.2f\".format(area).toDouble() // round to 2 decimal places and convert to double\n    } else {\n        return -1 // not a valid triangle, return -1\n    }\n}"}
{"task_id": "kotlin/30", "language": "kotlin", "completion": "fun willItFly(q: List<Int>, w: Int): Boolean {\n    val sum = q.sum()\n    return isBalanced(q) && sum <= w\n}\n\nprivate fun isBalanced(list: List<Int>): Boolean {\n    val mid = list.size / 2\n    val leftSum = list.take(mid).sum()\n    val rightSum = list.drop(mid).sum()\n    return leftSum == rightSum\n}"}
{"task_id": "kotlin/31", "language": "kotlin", "completion": "fun isMultiplyPrime(a: Int): Boolean {\n    val primeNumbers = mutableListOf<Int>()\n    var i = 2\n    while (i * i <= a) {\n        if (isPrime(i)) {\n            primeNumbers.add(i)\n            var j = i + 1\n            while (j <= a) {\n                if (isPrime(j) && !primeNumbers.contains(j)) {\n                    primeNumbers.add(j)\n                    j += 1\n                } else {\n                    break\n                }\n            }\n        }\n        i++\n    }\n\n    return primeNumbers.size == 3 && a == primeNumbers[0] * primeNumbers[1] * primeNumbers[2]\n}\n\nfun isPrime(n: Int): Boolean {\n    if (n <= 1) return false\n    for (i in 2..Math.sqrt(n.toDouble()).toInt()) {\n        if (n % i == 0) return false\n    }\n    return true\n}"}
{"task_id": "kotlin/32", "language": "kotlin", "completion": "fun decimalToBinary(decimal: Int): String {\n    val binary = java.lang.Integer.toBinaryString(decimal)\n    return \"db\" + binary.padStart(binary.length + 2, '0') + \"db\"\n}"}
{"task_id": "kotlin/33", "language": "kotlin", "completion": "fun isHappy(s: String): Boolean {\n    if (s.length < 3) return false // wenn die L\u00e4nge des Strings zu klein ist, ist er nicht gl\u00fccklich\n\n    val groups = s.windowed(3, overlap = true) // teile den String in Gruppen von 3 aufeinanderfolgenden Buchstaben\n    for (group in groups) {\n        if (!group.toSet().size == group.size) { // wenn eine Gruppe nicht einzigartig ist, ist der String nicht gl\u00fccklich\n            return false\n        }\n    }\n    return true // wenn alle Gruppen einzigartig sind, ist der String gl\u00fccklich\n}"}
{"task_id": "kotlin/34", "language": "kotlin", "completion": "fun numericalLetterGrade(grades: List<Any>): List<String> {\n    val letterGrades = mutableListOf<String>()\n    for (gpa in grades) {\n        var grade = \"\"\n        when (gpa) {\n            is Double -> {\n                if (gpa >= 4.0) grade = \"A+\"\n                else if (gpa > 3.7) grade = \"A\"\n                else if (gpa > 3.3) grade = \"A-\"\n                else if (gpa > 3.0) grade = \"B+\"\n                else if (gpa > 2.7) grade = \"B\"\n                else if (gpa > 2.3) grade = \"B-\"\n                else if (gpa > 2.0) grade = \"C+\"\n                else if (gpa > 1.7) grade = \"C\"\n                else if (gpa > 1.3) grade = \"C-\"\n                else if (gpa > 1.0) grade = \"D+\"\n                else if (gpa > 0.7) grade = \"D\"\n                else if (gpa > 0.0) grade = \"D-\"\n                else grade = \"E\"\n            }\n        }\n        letterGrades.add(grade)\n    }\n    return letterGrades\n}"}
{"task_id": "kotlin/35", "language": "kotlin", "completion": "fun primeLength(string: String): Boolean {\n    val length = string.length\n    if (length <= 1) return true // L\u00e4nge 0 oder 1 ist immer prim\n\n    for (i in 2 until sqrt(length.toDouble()).toInt() + 1) {\n        if (length % i == 0) return false // L\u00e4nge ist keine Primzahl\n    }\n    return true // L\u00e4nge ist eine Primzahl\n}"}
{"task_id": "kotlin/36", "language": "kotlin", "completion": "fun solve(n: Int): String {\n    var sum = 0\n    var binarySum = \"\"\n\n    while (n > 0) {\n        sum += n % 10\n        n /= 10\n    }\n\n    while (sum > 0) {\n        if (sum and 1 == 1) {\n            binarySum = \"1\" + binarySum\n        } else {\n            binarySum = \"0\" + binarySum\n        }\n        sum shr 1\n    }\n\n    return if (binarySum.isEmpty()) \"0\" else binarySum\n}"}
{"task_id": "kotlin/37", "language": "kotlin", "completion": "fun getRow(lst: List<Any>, x: Int): List<Any> {\n    val result = mutableListOf<Pair<Int, Int>>()\n    var rowIndex = 0\n    lst.forEach { row ->\n        (row as? List<*>)?.forEachIndexed { columnIndex, element ->\n            if (element == x) {\n                result.add(Pair(rowIndex, columnIndex))\n            }\n        }\n        rowIndex++\n    }\n    return result.sortedBy { it.first }.sortedByDescending { it.second }\n}"}
{"task_id": "kotlin/38", "language": "kotlin", "completion": "fun nextSmallest(lst: List<Any>): Int? {\n    if (lst.isEmpty()) return null // no elements, nothing to find\n\n    val sorted = lst.sorted() // sort the list\n    val smallest = sorted.first() // get the smallest element\n    val index = sorted.indexOf(smallest) // find the index of the smallest element\n\n    if (index == 0) return null // smallest is the first element, no next smallest\n\n    return sorted[index] as Int? // return the second smallest element\n}"}
{"task_id": "kotlin/39", "language": "kotlin", "completion": "fun isBored(s: String): Int {\n    var boredCount = 0\n    val sentences = s.split(Regex(\"[.!?]+\")) // split by sentence terminator\n    for (sentence in sentences) {\n        if (sentence.trim().startsWith(\"Ich\", ignoreCase = true)) {\n            boredCount++\n        }\n    }\n    return boredCount\n}"}
{"task_id": "kotlin/40", "language": "kotlin", "completion": "fun skjkasdkd(lst: List<Int>): Int {\n    fun isPrime(n: Int): Boolean {\n        if (n <= 1) return false\n        for (i in 2..Math.sqrt(n.toDouble()).toInt()) {\n            if (n % i == 0) return false\n        }\n        return true\n    }\n\n    val maxPrime = lst.asSequence()\n        .filter { it > 0 } // Nur positive Zahlen ber\u00fccksichtigen\n        .filter { isPrime(it) } // Nur Primzahlen finden\n        .maxOrNull() ?: 0 // Maximale Primzahl finden oder 0, wenn keine gefunden wurde\n\n    return maxPrime.toString().sumOf { it.toString().toInt() } // Summe der Ziffern der gr\u00f6\u00dften Primzahl\n}"}
{"task_id": "kotlin/41", "language": "kotlin", "completion": "fun checkDictCase(dict: Map<Any?, Any?>): Boolean {\n    if (dict.isEmpty()) return false  // empty dict, so it's not all in one case\n\n    val firstKey = dict.keys.first()\n    val isAllLowercase = firstKey.toString().toLowerCase() == firstKey.toString()\n\n    return dict.all { key, _ -> key.toString().toLowerCase() == key.toString() && isAllLowercase }\n}"}
{"task_id": "kotlin/42", "language": "kotlin", "completion": "fun closestInteger(value: String): Int {\n    val num = value.toDouble()\n    return when {\n        num == num.toInt() -> num.toInt() // exact integer, no rounding needed\n        num > 0 -> Math.ceil(num).toInt() // round up if positive\n        else -> Math.floor(num).toInt() // round down if negative\n    }\n}"}
{"task_id": "kotlin/43", "language": "kotlin", "completion": "fun makeAPile(n: Int): List<Int> {\n    val pile = mutableListOf<Int>()\n    var currentLevel = n\n\n    repeat(n) {\n        pile.add(currentLevel)\n        when (currentLevel) {\n            in (1..n -> 4) -> currentLevel = (currentLevel + 2).also { if (it % 2 == 0) it.inc() }\n            else -> currentLevel = (currentLevel + 1).also { if (it % 2 == 1) it.inc() }\n        }\n    }\n\n    return pile\n}"}
{"task_id": "kotlin/44", "language": "kotlin", "completion": "fun wordsString(s: String): List<Any> {\n    return s.split(\"[ ,]+\").map { it::class } // split by one or more spaces or commas, and then map each word to its class (any)\n}"}
{"task_id": "kotlin/45", "language": "kotlin", "completion": "fun chooseNum(x: Int, y: Int): Int {\n    if (x > y) {\n        return -1 // no even number in [x, y] interval\n    }\n    for (i in x..y) {\n        if (i % 2 == 0) { // found an even number\n            return i\n        }\n    }\n    return -1 // no even number in [x, y] interval\n}"}
{"task_id": "kotlin/46", "language": "kotlin", "completion": "fun roundedAvg(n: Int, m: Int): Any {\n    if (n > m) return -1\n\n    val sum = (n..m).sum()\n    val avg = Math.ceil(sum.toDouble() / (m - n + 1)) // Ceiling to round up\n    return \"0b${avg.toString(2)}\"\n}"}
{"task_id": "kotlin/47", "language": "kotlin", "completion": "fun f(n: Int): List<Int> {\n    val result = mutableListOf<Int>()\n    for (i in 1..n) {\n        if (i % 2 == 0) { // i is even\n            result.add(fact(i))\n        } else { // i is odd\n            result.add(sumOfIntegers(1, i))\n        }\n    }\n    return result\n}\n\nprivate fun fact(n: Int): Int = (1..n).fold(1) { acc, i -> acc * i }\n\nprivate fun sumOfIntegers(start: Int, end: Int): Int = (start..end).sum()"}
{"task_id": "kotlin/48", "language": "kotlin", "completion": "fun evenOddPalindrome(n: Int): List<Int> {\n    var even = 0\n    var odd = 0\n    for (i in 1..n) {\n        val str = i.toString()\n        if (isPalindrome(str)) {\n            if (isEven(i)) {\n                even++\n            } else {\n                odd++\n            }\n        }\n    }\n    return listOf(even, odd)\n}\n\nfun isPalindrome(s: String): Boolean {\n    val rev = s.reversed()\n    return s == rev\n}\n\nfun isEven(n: Int): Boolean {\n    return n % 2 == 0\n}"}
{"task_id": "kotlin/49", "language": "kotlin", "completion": "fun moveOneBall(arr: List<Any>): Boolean {\n    var canBeSorted = true\n    var maxSoFar = arr[0] as Int\n\n    for (i in 1 until arr.size) {\n        if ((arr[i] as Int) <= maxSoFar) {\n            canBeSorted = false\n            break\n        }\n        maxSoFar = arr[i] as Int\n    }\n\n    return canBeSorted || arr.isEmpty()\n}"}
{"task_id": "kotlin/50", "language": "kotlin", "completion": "fun exchange(lst1: List<Int>, lst2: List<Int>): String {\n    val oddCount = lst1.count { it % 2 != 0 }\n    if (oddCount == 0) return \"YES\" // all elements in lst1 are even, no need to swap\n\n    val canSwap = lst2.count { it % 2 != 0 } >= oddCount\n    if (!canSwap) return \"NO\" // not enough odd numbers in lst2 to swap with lst1\n\n    return \"YES\"\n}"}
{"task_id": "kotlin/51", "language": "kotlin", "completion": "fun reverseDelete(s: String, c: String): List<Any> {\n    var result = s.toMutableCharArray()\n    \n    for (char in c.toCharArray()) {\n        result = result.filterNot { it == char }.toCharArray().toMutableList()\n    }\n    \n    val isPalindrome = isPalindrome(result.joinToString())\n    \n    return listOf(result.joinToString(), isPalindrome)\n}\n\nprivate fun isPalindrome(str: String): Boolean {\n    var left = 0\n    var right = str.length - 1\n    \n    while (left < right) {\n        if (str[left] != str[right]) {\n            return false\n        }\n        left++\n        right--\n    }\n    \n    return true\n}"}
{"task_id": "kotlin/52", "language": "kotlin", "completion": "fun maxFill(grid: List<List<Int>>, capacity: Int): Int {\n    var totalWater = 0\n    var usedCapacity = 0\n\n    for (row in grid) {\n        for (cell in row) {\n            if (cell == 1) {\n                totalWater += cell\n                usedCapacity++\n            }\n        }\n    }\n\n    return usedCapacity / capacity + (if (totalWater % capacity > 0) 1 else 0)\n}"}
{"task_id": "kotlin/53", "language": "kotlin", "completion": "fun selectWords(s: String, n: Int): List<Any> {\n    val words = s.split(\"\\\\s+\".toRegex())\n    return words.filter { it.count { !it.isLetter() } == n - 1 }.takeIf { it.isNotEmpty() } ?: emptyList()\n}"}
{"task_id": "kotlin/54", "language": "kotlin", "completion": "fun maximum(arr: List<Int>, k: Int): List<Any> {\n    return arr.sortedDescending().take(k).map { it as Any }\n}"}
{"task_id": "kotlin/55", "language": "kotlin", "completion": "fun addElements(arr: List<Int>, k: Int): Int {\n    return arr.take(k).filter { it.toString().length <= 2 }.sum()\n}"}
{"task_id": "kotlin/56", "language": "kotlin", "completion": "fun intersection(interval1: List<Int>, interval2: List<Int>): String {\n    val start = maxOf(interval1[0], interval2[0])\n    val end = minOf(interval1[1], interval2[1])\n\n    if (start > end) return \"NO\" // Intervalle \u00fcberschneiden sich nicht\n\n    val intersectionLength = end - start + 1\n    return if (isPrime(intersectionLength)) \"YES\" else \"NO\"\n}\n\nprivate fun isPrime(n: Int): Boolean {\n    if (n <= 1) return false\n    for (i in 2..Math.sqrt(n.toDouble()).toInt()) {\n        if (n % i == 0) return false\n    }\n    return true\n}"}
{"task_id": "kotlin/57", "language": "kotlin", "completion": "fun tri(n: Int): List<Int> {\n    if (n == 0) {\n        return listOf(3)\n    }\n    if (n == 1) {\n        return listOf(3, 2)\n    }\n\n    val result = mutableListOf<Int>(3, 2)\n\n    for (i in 2..n) {\n        when (i % 2) {\n            0 -> result.add((i).toInt() / 2 + 1)\n            else -> {\n                val prev = i - 1\n                val prevPrev = if (prev % 2 == 0) prev / 2 + 1 else result[prev - 1]\n                val next = i + 1\n                while (next > n) {\n                    next -= 2\n                }\n                result.add(prevPrev + result[prev] + next)\n            }\n        }\n    }\n\n    return result\n}"}
{"task_id": "kotlin/58", "language": "kotlin", "completion": "fun digits(n: Int): Int {\n    var result = 1\n    for (digit in n.toString().reversed()) {\n        if (digit.toInt() % 2 != 0) {\n            result *= digit.toInt()\n        }\n    }\n    return result\n}"}
{"task_id": "kotlin/59", "language": "kotlin", "completion": "fun isNested(s: String): Boolean {\n    var count = 0\n    for (c in s) {\n        if (c == '[') count++\n        if (c == ']') {\n            if (count <= 0) return false\n            count--\n        }\n    }\n    return count > 0\n}"}
{"task_id": "kotlin/60", "language": "kotlin", "completion": "fun sumSquares(lst: List[Any>): Int {\n    return lst.sumBy { ceil(it as Double).toInt() * ceil(it as Double).toInt() }\n}"}
{"task_id": "kotlin/61", "language": "kotlin", "completion": "fun checkIfLastCharIsALetter(txt: String): Boolean {\n    val lastChar = txt.trim().lastOrNull()\n    return lastChar?.isLetter() ?: false && !txt.trim().endsWith(\" \")\n}"}
{"task_id": "kotlin/62", "language": "kotlin", "completion": "fun canArrange(arr: List<Any>): Int {\n    var maxIndex = -1\n    for (i in arr.indices) {\n        if (i > 0 && arr[i] <= arr[i - 1]) {\n            maxIndex = i\n            break\n        }\n    }\n    return maxIndex\n}"}
{"task_id": "kotlin/63", "language": "kotlin", "completion": "fun largestSmallestIntegers(lst: List<Any>): List<Int?> {\n    val integers = lst.filterIsInstance(Int::class.java)\n    if (integers.isEmpty()) return listOf(null, null)\n\n    val minPos = integers.asSequence()\n        .filter { it > 0 }\n        .min()\n\n    val maxNeg = integers.asSequence()\n        .filter { it < 0 }\n        .max()\n\n    return when {\n        minPos != null && maxNeg != null -> listOf(maxNeg, minPos)\n        else -> listOf(null, null)\n    }\n}"}
{"task_id": "kotlin/64", "language": "kotlin", "completion": "fun specialFactorial(n: Int): Int {\n    if (n <= 0) {\n        throw java.lang.RuntimeException(\"Die Eingabe muss gr\u00f6\u00dfer als null sein.\")\n    }\n    var result = 1\n    for (i in 1..n) {\n        result *= i * specialFactorial(i - 1)\n    }\n    return result\n}"}
{"task_id": "kotlin/65", "language": "kotlin", "completion": "fun wordsInSentence(sentence: String): String {\n    val words = sentence.split(\" \") // Trenne den Satz in W\u00f6rter auf\n    return words.filter { it.length.isPrime() }.joinToString(\" \") // Filter die W\u00f6rter nach Primzahl-L\u00e4nge und verbinde sie wieder zum Ergebnisstring\n}\n\nprivate fun Int.isPrime(): Boolean {\n    if (this <= 1) return false\n    if (this == 2) return true\n    if (this % 2 == 0) return false\n    var i = 3\n    while (i * i <= this) {\n        if (this % i == 0) return false\n        i += 2\n    }\n    return true\n}"}
{"task_id": "kotlin/66", "language": "kotlin", "completion": "fun simplify(x: String, n: String): Boolean {\n    val xParts = x.split(\"/\")\n    val nParts = n.split(\"/\")\n\n    val xDenominator = xParts[1].toInt()\n    val nDenominator = nParts[1].toInt()\n\n    return xDenominator * nParts[0].toInt() == nDenominator * xParts[0].toInt()\n}"}
{"task_id": "kotlin/67", "language": "kotlin", "completion": "fun orderByPoints(nums: List<Any>): List[Any>?> {\n    return nums.sortedBy { num ->\n        when (num) {\n            is Int -> num.toString().sumOf { it.digitToInt() }\n            else -> throw IllegalArgumentException(\"Invalid input\")\n        }\n    }.map { if (it is Int) it else null }\n}"}
{"task_id": "kotlin/68", "language": "kotlin", "completion": "fun specialfilter(nums: List[Any>): Int {\n    var count = 0\n    for (num in nums) {\n        if (num is Int && num > 10) {\n            val lastDigit = num % 10\n            if (lastDigit % 2 != 0) { // check if last digit is odd\n                val firstDigit = (num / 10).toInt() % 10\n                if (firstDigit % 2 != 0) { // check if first digit is odd\n                    count++\n                }\n            }\n        }\n    }\n    return count\n}"}
{"task_id": "kotlin/69", "language": "kotlin", "completion": "fun getMaxTriples(n: Int): Int {\n    val a = IntArray(n + 1)\n    var count = 0\n    for (i in 1..n) {\n        a[i] = i * i - i + 1\n    }\n    \n    for (i in 1 until n) {\n        for (j in i + 1 until n) {\n            if (a[i] + a[j] > a[n]) break // Early exit if sum of a[i] and a[j] exceeds maximum possible value\n    \n            for (k in j + 1 until n) {\n                if (a[i] + a[j] + a[k] % 3 == 0) {\n                    count++\n                    break\n                }\n            }\n        }\n    }\n    \n    return count\n}"}
{"task_id": "kotlin/70", "language": "kotlin", "completion": "enum class Planet { Mercury, Venus, Earth, Mars, Jupiter, Saturn, Uranus, Neptune }\n\nfun bf(planet1: String, planet2: String): List<Any> {\n    val planets = listOf(\n        Planet.Mercury,\n        Planet.Venus,\n        Planet.Earth,\n        Planet.Mars,\n        Planet.Jupiter,\n        Planet.Saturn,\n        Planet.Uranus,\n        Planet.Neptune\n    )\n\n    val indices1 = planets.indexOf(when (planet1) {\n        \"Merkur\" -> Planet.Mercury\n        \"Venus\" -> Planet.Venus\n        \"Earth\" -> Planet.Earth\n        \"Mars\" -> Planet.Mars\n        \"Jupiter\" -> Planet.Jupiter\n        \"Saturn\" -> Planet.Saturn\n        \"Uranus\" -> Planet.Uranus\n        \"Neptune\" -> Planet.Neptune\n        else -> return listOf()\n    })\n\n    val indices2 = planets.indexOf(when (planet2) {\n        \"Merkur\" -> Planet.Mercury\n        \"Venus\" -> Planet.Venus\n        \"Earth\" -> Planet.Earth\n        \"Mars\" -> Planet.Mars\n        \"Jupiter\" -> Planet.Jupiter\n        \"Saturn\" -> Planet.Saturn\n        \"Uranus\" -> Planet.Uranus\n        \"Neptune\" -> Planet.Neptune\n        else -> return listOf()\n    })\n\n    if (indices1 < 0 || indices2 < 0) {\n        return listOf()\n    }\n\n    val result = planets.slice(indices1..indices2)\n            .filter { it != planet1 && it != planet2 }\n            .sortedBy { it.ordinal }\n\n    return result\n}"}
{"task_id": "kotlin/71", "language": "kotlin", "completion": "fun xOrY(n: Int, x: Int, y: Int): Int {\n    if (isPrime(n)) return x else return y\n}\n\nprivate fun isPrime(num: Int): Boolean {\n    if (num <= 1) return false\n    for (i in 2 until num.sqrt() + 1) {\n        if (num % i == 0) return false\n    }\n    return true\n}"}
{"task_id": "kotlin/72", "language": "kotlin", "completion": "fun doubleTheDifference(lst: List[Any>): Int {\n    var sum = 0\n    for (element in lst) {\n        if (element is Int && element % 2 != 0 && element >= 0) {\n            sum += element * element\n        }\n    }\n    return sum\n}"}
{"task_id": "kotlin/73", "language": "kotlin", "completion": "fun strongestExtension(className: String, extensions: List<String>): String {\n    return extensions.map { extension ->\n        val cap = extension.count { it.isUpperCase() }\n        val sm = extension.length - cap\n        Pair(extension, cap - sm)\n    }.maxByOrNull { it.second }?.let { \"${className}.${it.first}\" } ?: \"ClassName.NoExtension\"\n}"}
{"task_id": "kotlin/74", "language": "kotlin", "completion": "fun cycpatternCheck(a: String, b: String): Boolean {\n    val lengthA = a.length\n    val lengthB = b.length\n    for (i in 0..lengthA - lengthB) {\n        if (a.substring(i, i + lengthB) == b || a.substring(i, i + lengthB).rotate().equals(b)) {\n            return true\n        }\n    }\n    return false\n}\n\nprivate fun String.rotate(): String {\n    val reversed = this.reversed()\n    return if (this.length > 1) reversed.dropLast(1) else this\n}"}
{"task_id": "kotlin/75", "language": "kotlin", "completion": "fun intToMiniRoman(number: Int): String {\n    val romanMap = mapOf(\n        1000 to \"m\",\n        900 to \"cm\",\n        500 to \"d\",\n        400 to \"cd\",\n        100 to \"c\",\n        90 to \"xc\",\n        50 to \"l\",\n        40 to \"xl\",\n        10 to \"x\",\n        9 to \"ix\",\n        5 to \"v\",\n        4 to \"iv\",\n        1 to \"i\"\n    )\n\n    val result = StringBuilder()\n\n    var n = number\n    for ((value, roman) in romanMap) {\n        while (n >= value) {\n            result.append(roman)\n            n -= value\n        }\n    }\n\n    return result.toString().lowercase()\n}"}
{"task_id": "kotlin/76", "language": "kotlin", "completion": "fun rightAngleTriangle(a: Int, b: Int, c: Int): Boolean {\n    val halfPerimeter = (a + b + c) / 2.0\n    return Math.sqrt((halfPerimeter - a) * (halfPerimeter - b) * (halfPerimeter - c)) == c.toDouble()\n}"}
{"task_id": "kotlin/77", "language": "kotlin", "completion": "fun solve(s: String): String {\n    var result = \"\"\n    for (c in s) {\n        if (Character.isLetter(c)) {\n            result += if (Character.isUpperCase(c)) c.toLowerCase() else c.toUpperCase()\n        } else {\n            result += c\n        }\n    }\n    return if (result.isEmpty()) s.reversed().toString() else result.reversed().toString()\n}"}
{"task_id": "kotlin/78", "language": "kotlin", "completion": "import java.security.MessageDigest\nimport java.security.NoSuchAlgorithmException\n\nfun stringToMd5(text: String): String? {\n    if (text.isEmpty()) {\n        return null\n    }\n    \n    val md = MessageDigest.getInstance(\"MD5\")\n    val bytes = md.digest(text.toByteArray())\n    val hexString = StringBuilder()\n    for (b in bytes) {\n        val hex = Integer.toHexString(0xff & b)\n        if (hex.length == 1) {\n            hexString.append('0')\n        }\n        hexString.append(hex)\n    }\n    \n    return hexString.toString()\n}"}
{"task_id": "kotlin/79", "language": "kotlin", "completion": "fun generateIntegers(a: Int, b: Int): List<Int> {\n    return (a..b).filter { it % 2 == 0 }.toList()\n}"}
