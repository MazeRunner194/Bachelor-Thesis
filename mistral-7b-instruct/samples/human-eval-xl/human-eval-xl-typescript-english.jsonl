{"task_id": "typescript/0", "language": "typescript", "completion": "const below_zero = (operations: number[]): boolean => {\n  let balance = 0;\n  let hasNegativeBalance = false;\n\n  for (let operation of operations) {\n    balance += operation;\n    if (balance < 0 && !hasNegativeBalance) {\n      hasNegativeBalance = true;\n    }\n  }\n\n  return hasNegativeBalance;\n};"}
{"task_id": "typescript/1", "language": "typescript", "completion": "function sum_product(numbers: number[]): [number, number] {\n  if (numbers.length === 0) {\n    return [0, 1]; // Empty array case\n  }\n\n  const sum = numbers.reduce((accumulator, currentValue) => accumulator + currentValue, 0);\n  const product = numbers.reduce((accumulator, currentValue) => accumulator * currentValue, 1);\n\n  return [sum, product];\n}"}
{"task_id": "typescript/2", "language": "typescript", "completion": "const string_xor = function (a: string, b: string): string {\n    const lenA = a.length;\n    const lenB = b.length;\n\n    if (lenA !== lenB) {\n        throw new Error('Input strings must have the same length.');\n    }\n\n    let result = '';\n    for (let i = 0; i < lenA; i++) {\n        const charA = a[i];\n        const charB = b[i];\n\n        if (charA === '1' && charB === '1') {\n            result += '0';\n        } else if (charA === '0' && charB === '0') {\n            result += '1';\n        } else {\n            result += '1'; // XOR of 1 and 0 is 1, and vice versa.\n        }\n    }\n\n    return result;\n};"}
{"task_id": "typescript/3", "language": "typescript", "completion": "function longest(strings: string[]): string | null {\n  if (strings.length === 0) {\n    return null;\n  }\n\n  const maxLength = strings.reduce((max, current) => Math.max(max.length, current.length), 0);\n\n  return strings.find((string) => string.length === maxLength) || '';\n}"}
{"task_id": "typescript/4", "language": "typescript", "completion": "function greatestCommonDivisor(a: number, b: number): number {\n    if (b === 0) {\n        return a;\n    } else {\n        return greatestCommonDivisor(b, a % b);\n    }\n}"}
{"task_id": "typescript/5", "language": "typescript", "completion": "const numberNames = {\n  'zero': 0,\n  'one': 1,\n  'two': 2,\n  'three': 3,\n  'four': 4,\n  'five': 5,\n  'six': 6,\n  'seven': 7,\n  'eight': 8,\n  'nine': 9\n};\n\nconst sort_numbers = (numbers: string): string => {\n  const numberArray = numbers.split(' ').map((numberName) => numberNames[numberName]);\n  return numberArray.sort().map((number) => numberNames[Object.keys(numberNames)[number] as keyof typeof numberNames]).join(' ');\n};"}
{"task_id": "typescript/6", "language": "typescript", "completion": "function rescaleToUnit(numbers: number[]): number[] {\n  const minNumber = Math.min(...numbers);\n  const maxNumber = Math.max(...numbers);\n  const range = maxNumber - minNumber;\n\n  return numbers.map((number) => (number - minNumber) / range);\n}"}
{"task_id": "typescript/7", "language": "typescript", "completion": "const flip_case = (string0: string): string => {\n  let result = '';\n  for (let i = 0; i < string0.length; i++) {\n    const char = string0[i];\n    if (char === char.toUpperCase()) {\n      result += char.toLowerCase();\n    } else if (char === char.toLowerCase()) {\n      result += char.toUpperCase();\n    } else {\n      result += char; // Keep other characters unchanged\n    }\n  }\n  return result;\n};"}
{"task_id": "typescript/8", "language": "typescript", "completion": "function get_positive(l: number[]): number[] {\n  return l.filter((num) => num > 0);\n}"}
{"task_id": "typescript/9", "language": "typescript", "completion": "function isPrime(n: number): boolean {\n    // Check for edge cases\n    if (n <= 1) return false;\n    if (n === 2) return true;\n\n    // Use a loop to check divisibility starting from 2 up to the square root of n\n    for (let i = 2; i * i <= n; ++i) {\n        if (n % i === 0) {\n            return false;\n        }\n    }\n\n    // If no factors were found, the number is prime\n    return true;\n}"}
{"task_id": "typescript/10", "language": "typescript", "completion": "const unique = (l: number[]): number[] => {\n  const uniqueList = new Set(l);\n  return [...uniqueList].sort((a, b) => a - b);\n};"}
{"task_id": "typescript/11", "language": "typescript", "completion": "import * as math from 'mathjs';\n\nconst fib = (n: number) => {\n  if (n <= 1) return n;\n  let a = 0, b = 1;\n  for (let i = 2; i <= n; i++) {\n    [a, b] = [b, a + b];\n  }\n  return b;\n};\n\nconst isPrime = (num: number): boolean => {\n  if (num < 2) return false;\n  const sqrtNum = Math.sqrt(num);\n  for (let i = 2; i <= sqrtNum; i++) {\n    if (num % i === 0) return false;\n  }\n  return true;\n};\n\nconst prime_fib = function (n: number): number {\n  let index = 1;\n  let fibNumber = fib(index);\n\n  while (index < n) {\n    if (isPrime(fibNumber)) return fibNumber;\n    index++;\n    fibNumber = fib(index + 1);\n  }\n\n  throw new Error(`No prime Fibonacci number found for given input: ${n}`);\n};"}
{"task_id": "typescript/12", "language": "typescript", "completion": "const triples_sum_to_zero = function (l: number[]): boolean {\n  const set = new Set(); // To store the unique elements in the array\n  for (let i = 0; i < l.length; ++i) {\n    const target = -l[i]; // Target sum for finding the other two numbers\n    let found = false;\n    for (let j = i + 1; j < l.length && !found; ++j) {\n      if (set.has(target - l[j])) { // If we find a number that can form a triple with current and j-th elements\n        set.add(l[i]); // Add current element to the set for avoiding duplicates\n        set.add(l[j]); // Add the found element to the set\n        let third = target - l[j]; // Find the remaining number in the triple\n        if (!set.has(third)) { // If it's not a duplicate, we have found a triple summing to zero\n          return true;\n        }\n        found = true; // We have found at least two elements for this target, so we stop looking for others\n      }\n    }\n  }\n  return false;\n};"}
{"task_id": "typescript/13", "language": "typescript", "completion": "const pairs_sum_to_zero = (l: number[]): boolean => {\n  const numToIndex = {};\n  for (let i = 0; i < l.length; i++) {\n    const currentNum = l[i];\n    if (numToIndex[-currentNum] !== undefined) {\n      return true;\n    }\n    numToIndex[currentNum] = i;\n  }\n  return false;\n};"}
{"task_id": "typescript/14", "language": "typescript", "completion": "const fib4 = (n: number): number => {\n  let prevPrev = 0;\n  let prev = 0;\n  let current = 2; // initializing with the first non-zero value in the sequence\n  let result = 0;\n\n  for (let i = 1; i <= n; ++i) {\n    result = current;\n    [prevPrev, prev, current] = [current, result, current + prev + prevPrev];\n  }\n\n  return result;\n};"}
{"task_id": "typescript/15", "language": "typescript", "completion": "const median = (l: Array<number>): number => {\n  let sortedL = [...l].sort((a, b) => a - b);\n  let midIndex = Math.floor(sortedL.length / 2);\n\n  return sortedL[midIndex];\n};"}
{"task_id": "typescript/16", "language": "typescript", "completion": "const is_palindrome = (text: string): boolean => {\n    let cleanText = text.toLowerCase().replace(/[\\W\\d_]/g, '').trim();\n    return cleanText === cleanText.split('').reverse().join('');\n};\n\n// Test cases\nconsole.log(is_palindrome(\"\")); // True\nconsole.log(is_palindrome(\"aba\")); // True\nconsole.log(is_palindrome(\"aaaaa\")); // True\nconsole.log(is_palindrome(\"zbcd\")); // False"}
{"task_id": "typescript/17", "language": "typescript", "completion": "function removeVowels(text: string): string {\n  return text.replace(/[aeiou]/gi, '');\n}"}
{"task_id": "typescript/18", "language": "typescript", "completion": "const below_threshold = function (l: number[], t: number): boolean {\n  return l.every(n => n < t);\n};"}
{"task_id": "typescript/19", "language": "typescript", "completion": "const add = function (x: number, y: number): number {\n    return x + y;\n};"}
{"task_id": "typescript/20", "language": "typescript", "completion": "const same_chars = function (s0: string, s1: string): boolean {\n    const set0 = new Set(s0);\n    const set1 = new Set(s1);\n\n    return set0.size === set1.size;\n};"}
{"task_id": "typescript/21", "language": "typescript", "completion": "type FibResult = number;\n\nconst fib = (n: number): FibResult => {\n  if (n <= 1) return n; // base cases\n\n  return fib(n - 1) + fib(n - 2); // recursive case\n};"}
{"task_id": "typescript/22", "language": "typescript", "completion": "function common(l1: number[], l2: number[]): number[] {\n  const set1 = new Set(l1);\n  const set2 = new Set(l2);\n\n  const result: number[] = [];\n  for (const item of set1) {\n    if (set2.has(item)) {\n      result.push(item);\n      set2.delete(item); // to avoid duplicates in the result array\n    }\n  }\n\n  return result;\n}"}
{"task_id": "typescript/23", "language": "typescript", "completion": "function largest_prime_factor(n: number): number {\n    if (n < 2) return 1; // handle the edge case of n <= 1\n\n    const isPrime = (num: number) => {\n        for (let i = 2, sqrt = Math.sqrt(num); i <= sqrt; i++) {\n            if (num % i === 0) return false;\n        }\n        return num > 1; // handle the edge case of prime numbers greater than 1\n    };\n\n    let factors: number[] = [];\n    for (let potentialFactor = 2; potentialFactor * potentialFactor <= n; potentialFactor += 2) {\n        if (n % potentialFactor === 0) {\n            factors.push(potentialFactor);\n            n /= potentialFactor;\n        }\n    }\n\n    // check the remaining number to see if it's prime or not, and add it to our list of factors if it is\n    if (isPrime(n)) {\n        factors.push(n);\n    }\n\n    return Math.max(...factors);\n}"}
{"task_id": "typescript/24", "language": "typescript", "completion": "const sum_to_n = (n: number): number => {\n  let total = 0;\n  for (let i = 1; i <= n; i++) {\n    total += i;\n  }\n  return total;\n};"}
{"task_id": "typescript/25", "language": "typescript", "completion": "const derivative = function <T extends number>(xs: Array<T>): Array<T> {\n  const derived: Array<T> = [];\n\n  // Iterate over the input array starting from the second element\n  for (let i = 1; i < xs.length; ++i) {\n    derived[i - 1] = xs[i] * i;\n  }\n\n  return derived;\n};"}
{"task_id": "typescript/26", "language": "typescript", "completion": "function fibfib(n: number): number {\n    if (n === 0 || n === 1) return 0;\n    if (n === 2) return 1;\n\n    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n}"}
{"task_id": "typescript/27", "language": "typescript", "completion": "const vowels_count = (s: string): number => {\n  const vowels = ['a', 'e', 'i', 'o', 'u', 'y'];\n  let count = 0;\n\n  for (let i = 0; i < s.length; i++) {\n    if (vowels.includes(s[i].toLowerCase())) {\n      count++;\n    }\n  }\n\n  // If the string ends with 'y', increment the count if there's at least one vowel already\n  if (s.endsWith('y') && count > 0) {\n    count++;\n  }\n\n  return count;\n};"}
{"task_id": "typescript/28", "language": "typescript", "completion": "function search(lst: number[]): number {\n  const freqMap = lst.reduce((acc, num) => {\n    if (!acc[num]) acc[num] = 0;\n    acc[num]++;\n    return acc;\n  }, {} as Record<number, number>);\n\n  for (const num in freqMap) {\n    const frequency = freqMap[num];\n    if (frequency >= parseInt(num)) return parseInt(num);\n  }\n\n  return -1;\n}"}
{"task_id": "typescript/29", "language": "typescript", "completion": "const triangle_area = function (a: number, b: number, c: number): number {\n  if ((a + b > c) && (b + c > a) && (c + a > b)) {\n    const s = (a + b + c) / 2;\n    return Math.round(Math.sqrt(s * (s - a) * (s - b) * (s - c)) * 100) / 100;\n  } else {\n    return -1;\n  }\n};"}
{"task_id": "typescript/30", "language": "typescript", "completion": "function willItFly(q: number[], w: number): boolean {\n  if (!Array.isArray(q) || q.length === 0) {\n    throw new Error(\"Invalid input: q must be a non-empty array.\");\n  }\n\n  const sum = q.reduce((acc, val) => acc + val, 0);\n  if (sum > w) return false;\n\n  // Check if the list is palindromic using two pointers technique\n  let left = 0;\n  let right = q.length - 1;\n  while (left < right) {\n    if (q[left] !== q[right]) return false;\n    left++;\n    right--;\n  }\n\n  return true;\n}"}
{"task_id": "typescript/31", "language": "typescript", "completion": "function is_multiply_prime(a: number): boolean {\n  // Check if 'a' is a prime number (less than 100)\n  if (isPrime(a) && a > 2) return true;\n\n  // If 'a' is not a prime number, check if it can be divided by any of the small primes (up to the square root)\n  const smallPrimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59];\n\n  for (let prime of smallPrimes) {\n    if (a % prime === 0) return false;\n\n    // Optimization: If the square of a prime number exceeds 'a', we can break out from the loop since no larger prime factor exists\n    if (prime * prime > a) break;\n  }\n\n  // Check for other prime factors in pairs (since 'a' is odd, any prime pair that multiplies to 'a' must have one prime greater than sqrt(a) and another less than sqrt(a))\n  const sqrtA = Math.sqrt(a);\n  for (let i = smallPrimes.length - 1; i > 0; --i) {\n    let prime1 = smallPrimes[i];\n    let prime2;\n\n    // Try all remaining primes until we find a pair that multiplies to 'a' or exhaust the list of primes\n    for (let j = 0; j < i; ++j) {\n      prime2 = smallPrimes[j];\n      if ((prime1 * prime2 > sqrtA) || (prime1 * prime2 !== a)) continue;\n      return false;\n    }\n  }\n\n  // If we've reached this point, 'a' is not the product of three primes less than 100.\n  return false;\n}\n\n// Helper function to check if the given number is a prime number\nfunction isPrime(num: number): boolean {\n  if (num < 2) return false;\n  for (let i = 2; i <= Math.sqrt(num); ++i) {\n    if (num % i === 0) return false;\n  }\n  return true;\n}"}
{"task_id": "typescript/32", "language": "typescript", "completion": "function decimal_to_binary(decimal: number): string {\n  const binary = [];\n  let num = decimal;\n\n  while (num > 0) {\n    binary.push((num % 2).toString());\n    num = Math.floor(num / 2);\n  }\n\n  // Add 'db' at the beginning and end of the string\n  return 'db' + binary.reverse().join('') + 'db';\n}"}
{"task_id": "typescript/33", "language": "typescript", "completion": "function is_happy(s: string): boolean {\n  if (s.length < 3) return false;\n\n  const chars = new Set<string>();\n\n  for (let i = 0; i <= s.length - 3; i++) {\n    const substring = s.slice(i, i + 3);\n    if (chars.has(substring)) return false;\n    chars.add(substring);\n  }\n\n  return true;\n}"}
{"task_id": "typescript/34", "language": "typescript", "completion": "type LetterGrade = 'A+' | 'A' | 'A-' | 'B+' | 'B' | 'B-' | 'C+' | 'C' | 'C-' | 'D+' | 'D' | 'D-' | 'E';\n\nfunction grade_equation(grades: Array<number>): Array<LetterGrade> {\n  const letterGradeMap = new Map<number, LetterGrade>([\n    [4.0, 'A+'],\n    [3.7, 'A'],\n    [3.3, 'A-'],\n    [3.0, 'B+'],\n    [2.7, 'B'],\n    [2.3, 'B-'],\n    [2.0, 'C+'],\n    [1.7, 'C'],\n    [1.3, 'C-'],\n    [1.0, 'D+'],\n    [0.7, 'D'],\n    [0.0, 'D-'],\n    [0.0, 'E'] // In case a student gets 0 GPA, the grade should still be E (the lowest possible grade)\n  ]);\n\n  return grades.map(grade => letterGradeMap.get(Math.max(...letterGradeMap.keys())) >= grade ? letterGradeMap.get(grade)! : 'E');\n}"}
{"task_id": "typescript/35", "language": "typescript", "completion": "function prime_length(string0: string): boolean {\n  const length = parseInt(string0.length.toString(), 10);\n\n  if (isNaN(length) || length <= 1) return false;\n\n  // Checking for prime numbers up to the square root of the input number\n  let sqrt = Math.floor(Math.sqrt(length));\n  for (let i = 2; i <= sqrt; i++) {\n    if (length % i === 0) return false;\n  }\n\n  // If no divisors found up to the square root, the number is prime\n  return true;\n}"}
{"task_id": "typescript/36", "language": "typescript", "completion": "function solve(N: number): string {\n    let binary = (N >>> 0).toString(2);\n    let totalSum = 0;\n\n    for (let i = 0, len = binary.length; i < len; ++i) {\n        const digit = parseInt(binary[i], 2);\n        totalSum += digit;\n    }\n\n    return (totalSum >>> 0).toString(2);\n}"}
{"task_id": "typescript/37", "language": "typescript", "completion": "type Coordinate = [number, number];\ntype Result = Array<Coordinate>;\n\nfunction get_row(lst: Array<Array<number>>, x: number): Result {\n  const result: Result = [];\n\n  lst.forEach((row, rowIndex) => {\n    for (let i = 0; i < row.length; ++i) {\n      if (row[i] === x) {\n        result.push([rowIndex, i]);\n      }\n    }\n  });\n\n  result.sort((a, b) => a[0] - b[0]);\n  result.forEach((coordinate) => coordinate.sort((a, b) => b - a));\n\n  return result;\n}"}
{"task_id": "typescript/38", "language": "typescript", "completion": "function nextSmallest(lst: number[]): number | null {\n    if (lst.length < 2) return null;\n\n    const sorted = [...lst].sort((a, b) => a - b);\n    return sorted[1];\n}"}
{"task_id": "typescript/39", "language": "typescript", "completion": "const is_bored = (S: string): number => {\n  let count = 0;\n  let currentWord = \"\";\n  let isInsideSentence = false;\n\n  for (let i = 0; i < S.length; i++) {\n    const char = S[i];\n\n    if (char === \".\" || char === \"!\" || char === \"?\") {\n      // If we found a sentence delimiter and the current word starts with 'I', increment the count\n      if (currentWord.startsWith(\"I\") && isInsideSentence) {\n        count++;\n      }\n\n      // Reset the current word and check for the next sentence\n      currentWord = \"\";\n      isInsideSentence = false;\n    } else if (!isInsideSentence) {\n      // If we haven't found a sentence delimiter, start a new word or check for an opened quote\n      if (char === '\"') {\n        // Check the next character to see if it's not a quote (avoiding problems like \"I'm\")\n        if (i + 1 < S.length && S[i + 1] !== '\"') {\n          isInsideSentence = !isInsideSentence;\n        }\n      } else {\n        currentWord += char;\n      }\n    } else {\n      // If we're in the middle of a sentence, just keep track of the current word\n      currentWord += char;\n    }\n  }\n\n  // Check for the last sentence if it started with 'I'\n  if (currentWord.startsWith(\"I\") && isInsideSentence) {\n    count++;\n  }\n\n  return count;\n};"}
{"task_id": "typescript/40", "language": "typescript", "completion": "function findPrimeSum(lst: Array<number>): number {\n    // Check if array is empty or contains only zeroes\n    if (!lst.length || lst.every(num => num === 0)) return 0;\n\n    // Find the largest prime in the array\n    const primes = new Set();\n    for (let i = 2; i <= Math.max(...lst); i++) {\n        let isPrime = true;\n        if (i < 2) continue;\n        for (let j = 2; j <= Math.sqrt(i); j++) {\n            if (i % j === 0) {\n                isPrime = false;\n                break;\n            }\n        }\n        if (isPrime) primes.add(i);\n    }\n\n    let largestPrime: number | undefined;\n    for (let i of lst) {\n        const prime = [...primes].find(p => p === i);\n        if (prime !== undefined) {\n            largestPrime = prime!;\n            break;\n        }\n    }\n\n    // If no primes were found, return 0\n    if (!largestPrime) return 0;\n\n    // Return the sum of digits of the largest prime number\n    let sum = 0;\n    while (largestPrime > 0) {\n        sum += largestPrime % 10;\n        largestPrime = Math.floor(largestPrime / 10);\n    }\n    return sum;\n}"}
{"task_id": "typescript/41", "language": "typescript", "completion": "type CheckDictCase = { [key: string]: string };\n\nconst check_dict_case = (dict: CheckDictCase): boolean => {\n  const isLower = Array.from(dict).every(([k, v]) => k === k.toLowerCase());\n  return !Object.keys(dict).length || isLower;\n};"}
{"task_id": "typescript/42", "language": "typescript", "completion": "import * as math from 'mathjs';\n\nfunction roundAwayFromZero(num: number): number {\n  if (Math.abs(num) < 1) return Math.round(num);\n  return num > 0 ? Math.ceil(num) : Math.floor(num);\n}\n\nconst closest_integer = function (value: string) : number {\n  const num = math.eval(value).valueOf();\n  const integerPart = Math.floor(num);\n  const fractionalPart = num - integerPart;\n\n  if (Math.abs(fractionalPart) < 0.5) return integerPart;\n  return roundAwayFromZero(integerPart + (fractionalPart > 0 ? 1 : -1));\n};"}
{"task_id": "typescript/43", "language": "typescript", "completion": "const make_a_pile = (n: number): Array<number> => {\n  const levels: Array<number> = [];\n  let currentLevelStones = n;\n\n  // Keep adding levels until we reach 1\n  while (currentLevelStones > 1) {\n    const nextLevelStones = (currentLevelStones % 2 === 0) ? currentLevelStones + 2 : currentLevelStones + 1;\n    levels.push(currentLevelStones);\n    currentLevelStones = nextLevelStones;\n  }\n\n  // Add the last level with remaining stones (level 1)\n  levels.push(currentLevelStones);\n\n  return levels;\n};"}
{"task_id": "typescript/44", "language": "typescript", "completion": "const words_string = (s: string): string[] => s.trim().split(/\\s|,/);"}
{"task_id": "typescript/45", "language": "typescript", "completion": "// This function takes two positive numbers x and y and returns the biggest even integer number that is in the range [x, y] inclusive. If there's no such number, then the function should return -1.\nconst choose_num = (x: number, y: number): number => {\n  // Find the smallest even number within the given range\n  const minEven = Math.floor(Math.min(x, y) / 2) * 2;\n\n  // Check if this even number is greater than or equal to both x and y\n  if (minEven >= x && minEven <= y) {\n    return minEven;\n  } else {\n    return -1;\n  }\n};"}
{"task_id": "typescript/46", "language": "typescript", "completion": "function roundedAvg(n: number, m: number): string | number {\n  if (n > m) return -1;\n\n  let sum = 0;\n  const count = m - n + 1;\n\n  for (let i = n; i <= m; i++) {\n    sum += i;\n  }\n\n  // Round the average to the nearest integer.\n  const avg = Math.round(sum / count);\n\n  return \"0b\" + avg.toString(2);\n}"}
{"task_id": "typescript/47", "language": "typescript", "completion": "const f = (n: number): Array<number> => {\n  const result: Array<number> = new Array(n).fill(0);\n\n  for (let i = 0; i < n; i++) {\n    if (i % 2 === 0) {\n      // calculate factorial using recursion\n      let fact = 1;\n      for (let j = 1; j <= i; j++) {\n        fact *= j;\n      }\n      result[i] = fact;\n    } else {\n      let sum = 0;\n      // calculate sum from 1 to i\n      for (let j = 1; j <= i; j++) {\n        sum += j;\n      }\n      result[i] = sum;\n    }\n  }\n\n  return result;\n};"}
{"task_id": "typescript/48", "language": "typescript", "completion": "function isPalindrome(n: number): boolean {\n  const str = n.toString();\n  let start = 0;\n  let end = str.length - 1;\n\n  while (start < end) {\n    if (str[start] !== str[end]) return false;\n    start++;\n    end--;\n  }\n  return true;\n}\n\nfunction countEvenOddPalindromes(n: number): [number, number] {\n  let evenCount = 0;\n  let oddCount = 0;\n\n  for (let i = 1; i <= n; i++) {\n    if (isPalindrome(i)) {\n      if (i % 2 === 0) evenCount++;\n      else oddCount++;\n    }\n  }\n\n  return [evenCount, oddCount];\n}"}
{"task_id": "typescript/49", "language": "typescript", "completion": "const move_one_ball = (arr: number[]): boolean => {\n  let maxIndex = arr.length - 1;\n  for (let i = maxIndex; i > 0; i--) {\n    if (arr[i] < arr[i - 1]) {\n      // Find the maximum element that is less than its successor\n      let j = findMaxIndex(arr, i);\n      if (j <= maxIndex || arr[j] >= arr[i - 1]) {\n        return false;\n      }\n      // Perform right shift operation until the elements are in the correct order\n      swap(arr, j, i - 1);\n      for (let k = i - 2; k >= 0; k--) {\n        if (arr[k] > arr[k + 1]) {\n          swap(arr, k, k + 1);\n        } else {\n          break;\n        }\n      }\n      return true;\n    }\n  }\n  // If the array is already sorted or empty, return true\n  return true;\n};\n\n// Helper function to find the maximum index with a value less than 'index'\nconst findMaxIndex = (arr: number[], index: number): number => {\n  let maxValue = Number.MIN_VALUE;\n  let maxIndex = -1;\n  for (let i = arr.length - 1; i >= 0; i--) {\n    if (arr[i] > maxValue && arr[i] <= arr[index - 1]) {\n      maxValue = arr[i];\n      maxIndex = i;\n    }\n  }\n  return maxIndex;\n};\n\n// Helper function to swap two elements in an array\nconst swap = (arr: number[], index1: number, index2: number): void => {\n  const temp = arr[index1];\n  arr[index1] = arr[index2];\n  arr[index2] = temp;\n};"}
{"task_id": "typescript/50", "language": "typescript", "completion": "const exchange = (lst1: number[], lst2: number[]): string => {\n  const evenLst1 = lst1.filter(num => num % 2 === 0);\n  const oddLst1 = lst1.filter(num => num % 2 !== 0);\n\n  if (oddLst1.length === 0) return \"YES\";\n\n  for (let i = 0; i < oddLst1.length; i++) {\n    const evenNumInLst2 = lst2.find(num => num % 2 === 0);\n\n    if (evenNumInLst2) {\n      [lst1[i], lst2[lst2.indexOf(evenNumInLst2)]] = [lst2[lst2.indexOf(evenNumInLst2)], lst1[i]];\n      const newEvenLst1 = lst1.filter(num => num % 2 === 0);\n\n      if (newEvenLst1.length === lst1.length) return \"YES\";\n    } else {\n      return \"NO\";\n    }\n  }\n\n  return \"NO\";\n};"}
{"task_id": "typescript/51", "language": "typescript", "completion": "const reverse_delete = (s: string, c: string): [string, boolean] => {\n  const setC = new Set(c);\n  const filteredS = s.filter((char) => !setC.has(char));\n  const isPalindrome = (str: string) => str === str.split('').reverse().join('');\n\n  const resultStr = filteredS;\n  const isResultPalindrome = isPalindrome(resultStr);\n\n  return [resultStr, isResultPalindrome];\n};"}
{"task_id": "typescript/52", "language": "typescript", "completion": "function max_fill(grid: Array<Array<number>>, capacity: number): number {\n  const n = grid.length;\n  let count = 0;\n  for (let i = 0; i < n; ++i) {\n    let water = Math.min(capacity, grid[i].reduce((a, b) => a + b, 0));\n    count += Math.ceil(water / capacity);\n    for (let j = Math.max(i - 1, 0); j < Math.min(i + 2, n) && water > 0; ++j) {\n      grid[j][Math.floor((grid[j].length - 1) / 2)] -= Math.min(capacity, water);\n      water = Math.max(0, water - capacity);\n    }\n  }\n  return count;\n}"}
{"task_id": "typescript/53", "language": "typescript", "completion": "const select_words = (s: string, n: number): Array<string> => {\n  const words = s.split(' ');\n  let result: Array<string> = [];\n\n  function checkWord(word: string) {\n    if (word.length === 0) return;\n\n    let vowelsCount = 0;\n    let consonantsCount = 0;\n    for (let i = 0; i < word.length; i++) {\n      const charCode = word.charCodeAt(i);\n\n      if (charCode >= 97 && charCode <= 122) { // a-z in lowercase\n        if ('aeiou'.indexOf(word[i]) !== -1) vowelsCount++;\n        else consonantsCount++;\n      }\n\n      if (consonantsCount === n && i === word.length - 1) result.push(word);\n      if (consonantsCount > n) return;\n    }\n  }\n\n  for (const word of words) checkWord(word);\n\n  return result;\n};"}
{"task_id": "typescript/54", "language": "typescript", "completion": "function findKthLargest(arr: number[], k: number): number[] {\n  return quickSelect(arr, 0, arr.length - 1, k);\n}\n\nfunction quickSelect(arr: number[], low: number, high: number, k: number): number[] {\n  const pivotIndex = partition(arr, low, high);\n\n  if (pivotIndex === k - 1) {\n    return [arr[pivotIndex]].concat(quickSelect(arr, low, pivotIndex - 1, k));\n  } else if (pivotIndex > k - 1) {\n    return quickSelect(arr, low, pivotIndex - 1, k);\n  } else {\n    return quickSelect(arr, pivotIndex + 1, high, k);\n  }\n}\n\nfunction partition(arr: number[], low: number, high: number): number {\n  const pivot = arr[high];\n  let storeIndex = low;\n\n  for (let i = low; i < high; ++i) {\n    if (arr[i] > pivot) {\n      [arr[storeIndex], arr[i]] = [arr[i], arr[storeIndex]];\n      storeIndex++;\n    }\n  }\n\n  [arr[high], arr[storeIndex]] = [arr[storeIndex], arr[high]];\n  return storeIndex;\n}"}
{"task_id": "typescript/55", "language": "typescript", "completion": "function add_elements(arr: number[], k: number): number {\n  let sum = 0;\n\n  for (let i = 0; i < k && i < arr.length; i++) {\n    const numDigits = (arr[i] + '').length;\n    if (numDigits <= 2) {\n      sum += arr[i];\n    }\n  }\n\n  return sum;\n}"}
{"task_id": "typescript/56", "language": "typescript", "completion": "type Interval = [number, number];\n\nconst intersection = (interval1: Interval, interval2: Interval): string => {\n  const [start1, end1] = interval1;\n  const [start2, end2] = interval2;\n\n  // Check if intervals don't intersect\n  if (start1 > end2 || start2 > end1) return \"NO\";\n\n  // Calculate the intersection start and end\n  const startIntersection = Math.max(start1, start2);\n  const endIntersection = Math.min(end1, end2);\n\n  // If there is no overlap because the intervals are the same or one of them includes the other, return \"NO\"\n  if (startIntersection >= endIntersection) return \"NO\";\n\n  // Calculate the length of the intersection and check if it's a prime number\n  const length = endIntersection - startIntersection + 1;\n  if (isPrime(length)) return \"YES\";\n  return \"NO\";\n};\n\nconst isPrime = (n: number): boolean => {\n  // Check if the number is less than or equal to 1\n  if (n <= 1) return false;\n\n  // Check divisibility by numbers from 2 up to the square root of n\n  for (let i = 2; i * i <= n; ++i) {\n    if (n % i === 0) return false;\n  }\n\n  return true;\n};"}
{"task_id": "typescript/57", "language": "typescript", "completion": "type Tribonacci = (n: number) => Array<number>;\n\nconst tri: Tribonacci = function (n: number) {\n  const tribArray = [3]; // Initializing the first value of the sequence\n\n  for (let i = 1; i <= n; i++) {\n    const current = tribArray[i - 1] + tribArray[i > 2 ? i - 2 : 0] + tribArray[i > 3 ? i - 3 : 0];\n    tribArray.push(current);\n  }\n\n  return tribArray;\n};"}
{"task_id": "typescript/58", "language": "typescript", "completion": "function digits(n: number): number {\n    const str = n.toString();\n    let oddProduct = 1;\n\n    for (let i = 0; i < str.length; i++) {\n        const digit = parseInt(str[i], 10);\n        if (digit % 2 !== 0) {\n            oddProduct *= digit;\n        }\n    }\n\n    return oddProduct;\n}"}
{"task_id": "typescript/59", "language": "typescript", "completion": "function is_nested(string0: string): boolean {\n  let stack: string[] = [];\n\n  for (let char of string0) {\n    if (char === '[') {\n      stack.push(char);\n    } else if (char === ']') {\n      if (stack.length === 0 || stack[stack.length - 1] !== '[') {\n        return false;\n      } else {\n        stack.pop();\n      }\n    }\n  }\n\n  return stack.length > 0;\n}"}
{"task_id": "typescript/60", "language": "typescript", "completion": "import * as math from 'mathjs';\n\nconst ceil = (num: number) => Math.ceil(num);\nconst square = (num: number) => num ** 2;\nconst sum_squares = (lst: Array<number>) : number => {\n    const roundedList = lst.map((num) => ceil(num));\n    return math.sum(roundedList.map(square)).eval();\n};"}
{"task_id": "typescript/61", "language": "typescript", "completion": "const check_if_last_char_is_a_letter = (txt: string): boolean => {\n  const regex = /\\s+$|[^a-zA-Z]$/; // checks if last char is not alphabet or followed by a space\n  return !regex.test(txt);\n};"}
{"task_id": "typescript/62", "language": "typescript", "completion": "function can_arrange(arr: number[]): number {\n  for (let i = arr.length - 1; i >= 0; i--) {\n    if (i === 0 || arr[i] <= arr[i - 1]) {\n      return i;\n    }\n  }\n  return -1;\n}"}
{"task_id": "typescript/63", "language": "typescript", "completion": "const largest_smallest_integers = function (lst: Array<number>): [number | null, number | null] {\n  let minNegative = null;\n  let maxPositive = null;\n\n  for (let i of lst) {\n    if (i < 0 && (minNegative === null || i < minNegative)) {\n      minNegative = i;\n    } else if (i > 0 && (maxPositive === null || i < maxPositive)) {\n      maxPositive = i;\n    }\n  }\n\n  return [minNegative, maxPositive];\n};"}
{"task_id": "typescript/64", "language": "typescript", "completion": "const special_factorial = (n: number): number => {\n    if(n === 0) return 1; // Base case, factorial of 0 is 1\n    return n * special_factorial(n - 1); // Recursive call with n-1\n};"}
{"task_id": "typescript/65", "language": "typescript", "completion": "const isPrime = (num: number): boolean => {\n  if (num < 2) return false;\n  for (let i = 2; i <= Math.sqrt(num); i++) {\n    if (num % i === 0) return false;\n  }\n  return true;\n};\n\nconst wordsInSentence = (sentence: string): string => {\n  const words = sentence.split(' ');\n  const primeWords: string[] = [];\n\n  for (let word of words) {\n    if (word.length > 0 && isPrime(word.length)) {\n      primeWords.push(word);\n    }\n  }\n\n  return primeWords.join(' ');\n};"}
{"task_id": "typescript/66", "language": "typescript", "completion": "const simplify = (x: string, n: string): boolean => {\n  const [numeratorX, denominatorX] = x.split('/').map(Number);\n  const [numeratorN, denominatorN] = n.split('/').map(Number);\n\n  // Multiply the fractions by multiplying their numerators and denominators separately\n  const numeratorProduct = numeratorX * numeratorN;\n  const denominatorProduct = denominatorX * denominatorN;\n\n  // If the product of the numerators divides evenly into the product of the denominators, then the result is a whole number\n  return numeratorProduct % denominatorProduct === 0;\n};"}
{"task_id": "typescript/67", "language": "typescript", "completion": "function orderByDigitSum(nums: number[]): number[] {\n  return nums.slice()\n    .sort((a, b) => {\n      const sumA = sumOfDigits(Math.abs(a));\n      const sumB = sumOfDigits(Math.abs(b));\n\n      if (sumA !== sumB) return sumA - sumB;\n\n      return a < b ? -1 : (a > b ? 1 : 0);\n    });\n}\n\nfunction sumOfDigits(n: number): number {\n  let total = 0;\n  let num = n;\n\n  while (num) {\n    total += num % 10;\n    num = Math.floor(num / 10);\n  }\n\n  return total;\n}"}
{"task_id": "typescript/68", "language": "typescript", "completion": "const specialFilter = function (nums: number[]): number {\n  let count = 0;\n\n  for (let i = 0; i < nums.length; i++) {\n    const num = nums[i];\n\n    // Check if the number is greater than 10\n    if (num > 10) {\n      // Check if the first digit and last digit are odd\n      const firstDigit = Math.floor(Math.abs(num) / 10) % 10;\n      const lastDigit = Math.abs(num) % 10;\n\n      // Check if both digits are odd (1, 3, 5, 7 or 9)\n      if (firstDigit === 1 || firstDigit === 3 || firstDigit === 5 || firstDigit === 7 || firstDigit === 9 && lastDigit === 1 || lastDigit === 3 || lastDigit === 5 || lastDigit === 7 || lastDigit === 9) {\n        count++;\n      }\n    }\n  }\n\n  return count;\n};"}
{"task_id": "typescript/69", "language": "typescript", "completion": "const get_max_triples = (n: number): number => {\n  let count = 0;\n\n  // Iterate through all possible triples and check their sum modulo 3.\n  for (let i = 1; i < n; i++) {\n    for (let j = i + 1; j < n; j++) {\n      const k = (i * i - i + 1 + j * j - j + 1 + (n * n - n + 1)) % 3 === 0 ? j : undefined;\n\n      // If k is found, it means the triple satisfies the condition.\n      if (k !== undefined) {\n        count++;\n        break;\n      }\n    }\n  }\n\n  return count;\n};"}
{"task_id": "typescript/70", "language": "typescript", "completion": "const PLANETS = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"];\n\nfunction isBetween(planetIndex: number, minIndex: number, maxIndex: number): boolean {\n  return minIndex <= planetIndex && planetIndex <= maxIndex;\n}\n\nfunction bf(planet1: string, planet2: string): Array<string> {\n  const index1 = PLANETS.indexOf(planet1);\n  const index2 = PLANETS.indexOf(planet2);\n\n  if (index1 === -1 || index2 === -1) {\n    return [];\n  }\n\n  let startIndex = Math.min(index1, index2);\n  let endIndex = Math.max(index1, index2);\n\n  // Include both planets1 and planet2 in the result if they are not the same.\n  if (index1 !== index2) {\n    startIndex++;\n    endIndex--;\n  }\n\n  const result: string[] = [];\n  for (let i = startIndex; i <= endIndex; i++) {\n    if (isBetween(i, index1, index2)) {\n      result.push(PLANETS[i]);\n    }\n  }\n\n  return result;\n}"}
{"task_id": "typescript/71", "language": "typescript", "completion": "function isPrime(num: number): boolean {\n    if (num <= 1) return false;\n    if (num === 2) return true;\n    if (num % 2 === 0) return false;\n\n    let sqrt = Math.floor(Math.sqrt(num));\n    for (let i = 3; i <= sqrt; i += 2) {\n        if (num % i === 0) return false;\n    }\n\n    return true;\n}\n\nconst x_or_y = function (n: number, x: number, y: number): number {\n    if (isPrime(n)) {\n        return x;\n    } else {\n        return y;\n    }\n}"}
{"task_id": "typescript/72", "language": "typescript", "completion": "function doubleTheDifference(lst: number[]): number {\n  const oddNumbers = lst.filter(num => num % 2 !== 0 && num >= 0).map(num => Math.pow(num, 2));\n  return oddNumbers.reduce((sum, current) => sum + current, 0);\n}"}
{"task_id": "typescript/73", "language": "typescript", "completion": "const Strongest_Extension = function (class_name: string, extensions: Array<string>) : string {\n  let maxStrength = Number.MIN_VALUE; // Initialize maximum strength with smallest possible value\n  let strongestExtensionName = ''; // Initialize the name of the strongest extension\n\n  for(let i = 0; i < extensions.length; i++) {\n    const extensionStrength = extensions[i].length - extensions[i].toLowerCase().length;\n\n    if (extensionStrength > maxStrength) { // Check if this extension has a higher strength\n      maxStrength = extensionStrength; // Update the maximum strength\n      strongestExtensionName = extensions[i]; // Update the name of the strongest extension\n    } else if (extensionStrength === maxStrength && i < extensions.indexOf(strongestExtensionName)) {\n      strongestExtensionName = extensions[i]; // If multiple extensions have the same strength, choose the one that comes first in the list\n    }\n  }\n\n  return class_name + '.' + strongestExtensionName; // Finally, construct and return the final string\n};"}
{"task_id": "typescript/74", "language": "typescript", "completion": "const cycpattern_check = (a: string, b: string): boolean => {\n  const rotations = getRotations(b);\n\n  // Check if the second word is a substring of the first one\n  if (a.includes(b)) return true;\n\n  // Check if any rotation of the second word is a substring of the first one\n  for (const rotation of rotations) {\n    if (a.includes(rotation)) return true;\n  }\n\n  return false;\n};\n\n// Helper function to generate all rotations of a given string\nfunction getRotations(str: string): string[] {\n  const len = str.length;\n  let result: string[] = [];\n\n  for (let i = 0; i < len; ++i) {\n    const firstChar = str[i];\n    const restChars = str.slice(i + 1);\n    let rotatedStr = restChars + firstChar;\n\n    if (len === i + 1) continue;\n\n    result.push(rotatedStr);\n    for (let j = 0; j < len - i - 1; ++j) {\n      const nextChar = rotatedStr[j];\n      const nextRotatedStr = rotatedStr.slice(j + 1) + nextChar;\n      result.push(nextRotatedStr);\n    }\n  }\n\n  return result;\n}"}
{"task_id": "typescript/75", "language": "typescript", "completion": "const int_to_mini_roman = (number: number): string => {\n    const numeralMap = {\n        1: 'I',\n        5: 'V',\n        10: 'X',\n        50: 'L',\n        100: 'C',\n        500: 'D',\n        1000: 'M'\n    };\n\n    let result = '';\n    for (const [num, roman] of Object.entries(numeralMap)) {\n        if (number - num >= 0) {\n            number -= num;\n            result += roman;\n        }\n    }\n\n    // Handle numbers less than 10\n    if (number > 0 && number < 10) {\n        for (let i = 1; i <= number; i++) {\n            result += 'I'.repeat(i);\n        }\n    }\n\n    return result.toLowerCase();\n};"}
{"task_id": "typescript/76", "language": "typescript", "completion": "function right_angle_triangle(a: number, b: number, c: number): boolean {\n  const hypotenuseSquared = a * a + b * b;\n  const otherSideSquared = c * c;\n\n  return hypotenuseSquared === otherSideSquared || (hypotenuseSquared - otherSideSquared) ** 2 < Number.EPSILON;\n}"}
{"task_id": "typescript/77", "language": "typescript", "completion": "const solve = (s: string): string => {\n  const charList = s.split('');\n  let hasLetter = false;\n\n  for (let i = 0; i < charList.length; i++) {\n    if (charList[i].match(/[a-z]/i)) {\n      const isUpperCase = charList[i].toUpperCase() === charList[i];\n      charList[i] = isUpperCase ? charList[i].toLowerCase() : charList[i].toUpperCase();\n      hasLetter = true;\n    }\n  }\n\n  if (!hasLetter) {\n    return charList.reverse().join('');\n  }\n\n  return charList.join('');\n};"}
{"task_id": "typescript/78", "language": "typescript", "completion": "import * as sha3 from 'js-sha3';\n\nconst string_to_md5 = (text: string): string | null => {\n  const hash = sha3.create();\n  hash.update(text);\n  const digest = hash.hex();\n\n  if (digest.length === 64) {\n    return digest;\n  } else {\n    return null; // Return None or an equivalent value for an empty string case\n  }\n};"}
{"task_id": "typescript/79", "language": "typescript", "completion": "const generate_integers = (a: number, b: number): number[] => {\n  const result: number[] = [];\n\n  for (let i = Math.min(a, b); i <= Math.max(a, b); ++i) {\n    if ((i % 10 > 0 && i % 2 === 0) || i >= 10) { // Check for single digits and multi-digit numbers\n      const numberParts = String(i).split('').map(Number);\n\n      let isEven = true;\n      for (const part of numberParts) {\n        if (part % 2 !== 0) {\n          isEven = false;\n          break;\n        }\n      }\n\n      if (isEven) {\n        result.push(i);\n      }\n    }\n  }\n\n  return result;\n};"}
