{"task_id": "kotlin/0", "language": "kotlin", "completion": "fun belowZero(operations: List<Int>): Boolean {\n    var balance = 0\n\n    for (operation in operations) {\n        balance += if (operation > 0) operation else -operation\n        if (balance < 0) return true\n    }\n\n    return false\n}"}
{"task_id": "kotlin/1", "language": "kotlin", "completion": "fun sumProduct(numbers: List<Any>): Pair<Int, Long> {\n    var sum = 0\n    var product = 1L\n\n    for (number in numbers) {\n        if (number is Int) {\n            sum += number\n            product *= number.toLong()\n        }\n    }\n\n    return Pair(sum, product)\n}"}
{"task_id": "kotlin/2", "language": "kotlin", "completion": "fun stringXor(a: String, b: String): String {\n    if (a.length != b.length) throw IllegalArgumentException(\"Strings must have the same length\")\n\n    val result = StringBuilder()\n    for ((i, charA) in a.withIndex()) {\n        result.append(charA ^ b[i])\n    }\n    return result.toString()\n}"}
{"task_id": "kotlin/3", "language": "kotlin", "completion": "fun longest(strings: List<String>): String? {\n    if (strings.isEmpty()) return null\n    val maxLength = strings.maxByOrNull { it.length }!!\n    return strings.find { it == maxLength }\n}"}
{"task_id": "kotlin/4", "language": "kotlin", "completion": "fun greatestCommonDivisor(a: Int, b: Int): Int {\n    if (b == 0) return a\n    else return greatestCommonDivisor(b, a % b)\n}"}
{"task_id": "kotlin/5", "language": "kotlin", "completion": "data class Number(val name: String, val index: Int)\n\nfun sortNumbers(numbers: String): String {\n    val numbersList = listOf(\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\")\n    val numberMap = numbersList.associateBy({ it }, { index -> numbersList.indexOf(it) })\n\n    val numberList = mutableListOf<Number>()\n    for (char in numbers.split(' ')) {\n        numberList.add(Number(char, numberMap[char]!!))\n    }\n\n    numberList.sortBy { it.index }\n\n    return numberList.map { it.name }.joinToString(\" \")\n}"}
{"task_id": "kotlin/6", "language": "kotlin", "completion": "fun rescaleToUnit(numbers: List<Double>): List<Double> {\n    if (numbers.isEmpty()) return emptyList()\n\n    val min = numbers.minOrNull()!!\n    val max = numbers.maxOrNull()!!\n    val range = max - min\n\n    return numbers.map { it - min }.map { (it / range) }\n}"}
{"task_id": "kotlin/7", "language": "kotlin", "completion": "fun flipCase(string : String) : String {\n    val sb = StringBuilder()\n    for (char in string) {\n        if (char.isLowerCase()) {\n            sb.append(char.toUpperCase())\n        } else if (char.isUpperCase()) {\n            sb.append(char.toLowerCase())\n        } else {\n            // If it's neither lowercase nor uppercase, leave the character unchanged and append it to the result string\n            sb.append(char)\n        }\n    }\n    return sb.toString()\n}"}
{"task_id": "kotlin/8", "language": "kotlin", "completion": "fun getPositive(l: List<Int>): List<Int> {\n    val result = mutableListOf<Int>()\n    for (i in l) {\n        if (i > 0) {\n            result.add(i)\n        }\n    }\n    return result\n}"}
{"task_id": "kotlin/9", "language": "kotlin", "completion": "fun isPrime(n: Int): Boolean {\n    if (n <= 1) return false\n    if (n == 2) return true\n    for (i in 2 until Math.sqrt(n.toDouble()).toInt() + 1) {\n        if (n % i == 0) return false\n    }\n    return true\n}"}
{"task_id": "kotlin/10", "language": "kotlin", "completion": "fun unique(l : List<Int>) : List<Int> {\n    return l.sorted().toSet().toList()\n}"}
{"task_id": "kotlin/11", "language": "kotlin", "completion": "fun isPrime(number: Int): Boolean {\n    if (number <= 1) return false\n    if (number == 2) return true\n    val sqrt = Math.sqrt(number.toDouble()).toInt()\n    for (i in 2..sqrt) {\n        if (number % i == 0) return false\n    }\n    return true\n}\n\nfun fibonacci(n: Int): LongArray {\n    val sequence = LongArray(n + 1)\n    sequence[0] = 0L\n    sequence[1] = 1L\n    for (i in 2..n) {\n        sequence[i] = sequence[i - 1] + sequence[i - 2]\n    }\n    return sequence\n}\n\nfun primeFib(n: Int): Int {\n    var fibIndex = n\n    val fibSequence = fibonacci(fibIndex)\n\n    for (i in fibIndex downTo 2) {\n        if (isPrime(fibSequence[i])) {\n            fibIndex = i\n        }\n    }\n\n    return fibIndex.coerceAtLeast(1).coerceAtMost(fibSequence.size - 1).let { fibSequence[it] }\n}"}
{"task_id": "kotlin/12", "language": "kotlin", "completion": "fun triplesSumToZero(l: List<Int>): Boolean {\n    val set = l.toSet()\n    return l.size >= 3 && set.size == l.size && set.any { t -> t + it * 2 in set }\n}"}
{"task_id": "kotlin/13", "language": "kotlin", "completion": "fun pairsSumToZero(l: List<Int>): Boolean {\n    val set = l.toSet()\n    return l.any { number -> set.contains(-number) }\n}"}
{"task_id": "kotlin/14", "language": "kotlin", "completion": "fun fib4(n: Int): Int {\n    if (n <= 3) return 0\n    var prevPrev = 0\n    var prev = 2\n    var current = 0\n    for (i in 4..n) {\n        val temp = current\n        current = current + prev + prevPrev + 0 // 0th Fib4 is always 0\n        prevPrev = prev\n        prev = temp\n    }\n    return current\n}"}
{"task_id": "kotlin/15", "language": "kotlin", "completion": "fun median(l: List<Int>): Any {\n    val sortedList = l.sorted()\n    val n = sortedList.size\n\n    if (n == 0) return \"No elements in the list\" // Handle empty list case\n\n    val middleIndex = n / 2\n    val isEven = n % 2 == 0\n\n    return if (isEven) {\n        val mid1 = sortedList[middleIndex - 1] + sortedList[middleIndex]\n        val avgMid = mid1 / 2.0\n        avgMid\n    } else {\n        sortedList[middleIndex]\n    }\n}"}
{"task_id": "kotlin/16", "language": "kotlin", "completion": "fun isPalindrome(text: String): Boolean {\n    val chars = text.toCharArray()\n    for (i in 0 until chars.size / 2) {\n        if (chars[i] != chars[chars.lastIndex - i]) {\n            return false\n        }\n    }\n    return true\n}"}
{"task_id": "kotlin/17", "language": "kotlin", "completion": "fun removeVowels(text : String) : String {\n    val vowels = \"aeiouAEIOU\"\n    return text.filterNot { vowels.contains(it) }\n}"}
{"task_id": "kotlin/18", "language": "kotlin", "completion": "fun belowThreshold(l: List<Int>, t: Int): Boolean {\n    return l.all { it < t }\n}"}
{"task_id": "kotlin/19", "language": "kotlin", "completion": "fun add(x: Int, y: Int): Int {\n    return x + y\n}"}
{"task_id": "kotlin/20", "language": "kotlin", "completion": "fun sameChars(s0: String, s1: String): Boolean {\n    val sortedS0 = s0.sorted()\n    val sortedS1 = s1.sorted()\n\n    return sortedS0 == sortedS1\n}"}
{"task_id": "kotlin/21", "language": "kotlin", "completion": "fun fib(n: Int): Int {\n    if (n <= 1) return n\n    return fib(n - 1) + fib(n - 2)\n}"}
{"task_id": "kotlin/22", "language": "kotlin", "completion": "fun <T : Comparable<T>> common(l1: List<T>, l2: List<T>): List<T> {\n    return (l1 + l2).distinct().intersect(l1).intersect(l2)\n}"}
{"task_id": "kotlin/23", "language": "kotlin", "completion": "fun largestPrimeFactor(n: Int): Int {\n    if (n <= 1) return -1 // Invalid input, as n should be greater than 1\n\n    var currentDivisor = 2\n    while (true) {\n        if (n % currentDivisor == 0) {\n            n /= currentDivisor\n            if (isPrime(currentDivisor)) return currentDivisor\n        } else {\n            currentDivisor++\n            if (currentDivisor > Math.sqrt(n.toDouble()).toInt()) return -1 // No prime factors greater than sqrt(n)\n        }\n    }\n}\n\nfun isPrime(number: Int): Boolean {\n    if (number <= 1) return false\n    if (number == 2) return true\n    if (number % 2 == 0) return false\n\n    val limit = Math.sqrt(number.toDouble()).toInt()\n    for (i in 3..limit) {\n        if (number % i == 0) return false\n        val remainder = number % (i * 2 + 1)\n        if (remainder == 0) return false\n    }\n\n    return true\n}"}
{"task_id": "kotlin/24", "language": "kotlin", "completion": "fun sumToN(n: Int): Int {\n    return (1..n).sum()\n}"}
{"task_id": "kotlin/25", "language": "kotlin", "completion": "fun derivative(xs : List<Int>) : List<Any> {\n    val result = mutableListOf<Any>()\n\n    for ((index, element) in xs.withIndex()) {\n        if (index < xs.size - 1) {\n            result.add((index + 1) * element)\n        } else {\n            result.add(0)\n        }\n    }\n\n    return result\n}"}
{"task_id": "kotlin/26", "language": "kotlin", "completion": "fun fibfib(n: Int): Int {\n    if (n <= 2) return when (n) {\n        0 -> 0\n        1 -> 0\n        2 -> 1\n        else -> throw IllegalArgumentException(\"Invalid input, n must be between 0 and 2 inclusive.\")\n    }\n\n    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n}"}
{"task_id": "kotlin/27", "language": "kotlin", "completion": "fun vowelsCount(s : String) : Int {\n    val vowels = listOf('a', 'e', 'i', 'o', 'u', 'y')\n    var count = 0\n\n    // Iterate through each character in the string.\n    for (char in s) {\n        // Check if current char is a vowel and not y at the beginning of the word.\n        if (vowels.contains(char) && (!s.startsWith(\"y\") || s.length == 1)) {\n            count++\n        }\n    }\n\n    return count\n}"}
{"task_id": "kotlin/28", "language": "kotlin", "completion": "fun search(lst: List<Int>): Int {\n    val frequencyMap = mutableMapOf<Int, Int>()\n\n    // Iterate through the list and count the frequency of each number.\n    for (number in lst) {\n        frequencyMap[number] = (frequencyMap[number] ?: 0) + 1\n    }\n\n    // Iterate through the numbers starting from the largest one found in the frequency map.\n    for (number in frequencyMap.keys.sortedDescending()) {\n        if (frequencyMap[number] >= number) {\n            return number\n        }\n    }\n\n    // If no such value exists, return -1.\n    return -1\n}"}
{"task_id": "kotlin/29", "language": "kotlin", "completion": "fun triangleArea(a: Double, b: Double, c: Double): Double {\n    if (a <= 0.0 || b <= 0.0 || c <= 0.0) return -1.0\n    if (a + b < c || a + c < b || b + c < a) return -1.0\n    val s = (a + b + c) / 2.0\n    return Math.sqrt(s * (s - a) * (s - b) * (s - c)).toDouble()\n}"}
{"task_id": "kotlin/30", "language": "kotlin", "completion": "fun willItFly(q: List<Int>, w: Int): Boolean {\n    // Check if the list is balanced (palindromic) using the reversed() function\n    val isBalanced = q == q.reversed()\n\n    // Check if the sum of elements in the list is less than or equal to the maximum possible weight (w)\n    val totalWeight = q.sumBy { it }\n    return totalWeight <= w && isBalanced\n}"}
{"task_id": "kotlin/31", "language": "kotlin", "completion": "fun isMultiplyPrime(a : Int) : Boolean {\n    // Generate a list of primes up to 100 using Sieve of Eratosthenes\n    val primes = BooleanArray(101)\n    for (i in 2 until 101) primes[i] = true\n    for (p in 2 until Math.sqrt(100.0).toInt() + 1) {\n        if (primes[p]) {\n            for (j in p * p until 101 step p) primes[j] = false\n        }\n    }\n\n    // Check if a can be expressed as the product of three primes from the list\n    for (i in 2 until 101) {\n        if (primes[i]) {\n            val divisor = a / i\n            if (divisor > 1 && divisor % 2 != 0 && primes[divisor]) {\n                val thirdPrime = a / (i * divisor)\n                if (thirdPrime > 1 && thirdPrime % 2 != 0 && primes[thirdPrime]) {\n                    return true\n                }\n            }\n        }\n    }\n\n    // If we've checked all possible combinations and haven't found a match, return false\n    return false\n}"}
{"task_id": "kotlin/32", "language": "kotlin", "completion": "fun decimalToBinary(decimal: Int): String {\n    val binary = Integer.toBinaryString(decimal)\n    return \"db$binary db\" // Add the extra characters 'db' at the beginning and end of the string\n}"}
{"task_id": "kotlin/33", "language": "kotlin", "completion": "fun isHappy(s: String): Boolean {\n    if (s.length < 3) return false\n\n    val charMap = MutableMap<Char, Int>()\n\n    for (c in s) {\n        if (!charMap.containsKey(c)) {\n            charMap[c] = 1\n        } else {\n            charMap[c] = charMap[c]!! + 1\n        }\n    }\n\n    for (i in 0 until s.length - 2) {\n        if (charMap[s[i]]!! == 0 || charMap[s[i+1]]!! == 0 || charMap[s[i+2]]!! == 0) return false\n        charMap[s[i]]--\n        charMap[s[i + 2]]--\n    }\n\n    return true\n}"}
{"task_id": "kotlin/34", "language": "kotlin", "completion": "fun numericalLetterGrade(grades: List<Double>): List<String> {\n    val gradeTable = mapOf(\n        4.0 to \"A+\",\n        greaterThan(3.7) to \"A\",\n        greaterThan(3.3) to \"A-\",\n        greaterThan(3.0) to \"B+\",\n        greaterThan(2.7) to \"B\",\n        greaterThan(2.3) to \"B-\",\n        greaterThan(2.0) to \"C+\",\n        greaterThan(1.7) to \"C\",\n        greaterThan(1.3) to \"C-\",\n        greaterThan(1.0) to \"D+\",\n        greaterThan(0.7) to \"D\",\n        equalToOrLessThan(0.0) to \"E\"\n    )\n\n    return grades.map { grade -> gradeTable[grade] ?: \"E\" }\n}\n\nprivate fun greaterThan(threshold: Double): (Double) -> Boolean = { it > threshold }\nprivate fun equalToOrLessThan(threshold: Double): (Double) -> Boolean = { it <= threshold }"}
{"task_id": "kotlin/35", "language": "kotlin", "completion": "fun isPrime(number: Int): Boolean {\n    if (number <= 1) return false\n    if (number == 2) return true\n    if (number % 2 == 0) return false\n\n    val sqrt = Math.sqrt(number.toDouble()).toInt()\n    for (i in 3..sqrt step 2) {\n        if (number % i == 0) return false\n    }\n    return true\n}\n\nfun primeLength(str: String): Boolean {\n    val len = str.length\n    return isPrime(len)\n}"}
{"task_id": "kotlin/36", "language": "kotlin", "completion": "fun sumOfBinaryDigits(n: Int): String {\n    var currentSum = 0\n    val binaryStringBuilder = StringBuilder()\n\n    // Convert the number to binary and keep track of the carry\n    while (n > 0) {\n        val remainder = n % 2\n        currentSum += remainder\n        n /= 2\n\n        binaryStringBuilder.append(remainder)\n    }\n\n    // Add any remaining carry to the final sum and reverse the binary string\n    if (currentSum > 0) {\n        binaryStringBuilder.append(currentSum)\n    }\n    return binaryStringBuilder.reverse().toString()\n}"}
{"task_id": "kotlin/37", "language": "kotlin", "completion": "fun getRow(lst: List<Any>, x: Int): List<Pair<Int, Int>> {\n    // Flatten the input list\n    val flatLst = lst.flatMap { it as? List<Any> ?: emptyList() }\n\n    // Filter and sort elements according to the rules\n    return flatLst.filterIsInstance<Int>()\n        .filter { it == x }\n        .mapIndexed { index, _ -> Pair(index / lst.size, index % lst.size) }\n        .sortedWith(compareBy({ it.first }, { it.second }, greaterFirst = true))\n}"}
{"task_id": "kotlin/38", "language": "kotlin", "completion": "fun nextSmallest(lst: List<Int>): Int? {\n val sorted = lst.sorted()\n return if (sorted.size >= 2) sorted[1] else null\n}"}
{"task_id": "kotlin/39", "language": "kotlin", "completion": "fun isBored(s: String): Int {\n    var count = 0\n    var currentWord = \"\"\n    var inSentence = false\n\n    for (c in s) {\n        when (c) {\n            '.' -> inSentence = false\n            '!' -> inSentence = false\n            '?' -> inSentence = false\n            ' ' -> {\n                if (!inSentence && currentWord.startsWith(\"I\", true)) {\n                    count++\n                }\n                currentWord = \"\"\n            }\n            else -> currentWord += c\n        }\n\n        if (!inSentence) {\n            inSentence = c == ' '\n        }\n    }\n\n    // If the last word is \"I\", add to the count.\n    if (currentWord.startsWith(\"I\", true)) {\n        count++\n    }\n\n    return count\n}"}
{"task_id": "kotlin/40", "language": "kotlin", "completion": "import kotlin.math.abs\nimport kotlin.math.sqrt\n\nfun isPrime(n: Int): Boolean {\n    if (n < 2) return false\n    if (n == 2) return true\n    if (n % 2 == 0) return false\n    var limit = sqrt(n.toDouble()).toInt()\n        for (i in 3..limit - 1) {\n            if (n % i == 0) return false\n            val temp = n - i\n            if (temp % i == 0) return false\n        }\n    return true\n}\n\nfun sumOfDigits(num: Int): Int {\n    var result = 0\n    while (num > 0) {\n        result += num % 10\n        num /= 10\n    }\n    return result\n}\n\nfun largestPrimeSumOfDigits(lst: List<Int>): Int {\n    var max = Int.MIN_VALUE\n    for (num in lst) {\n        if (isPrime(num)) {\n            val currentMax = Math.max(max, num)\n            max = currentMax\n        }\n    }\n    return sumOfDigits(max)\n}"}
{"task_id": "kotlin/41", "language": "kotlin", "completion": "fun checkDictCase(dict: Map<Any?, Any?>): Boolean {\n    val case = if (dict.keys.any { it!!.toString().isUpperCase() }) UpperCase else LowerCase\n\n    return dict.all { (it.key as String).toLowerCase() == case(it.key as String) }\n}"}
{"task_id": "kotlin/42", "language": "kotlin", "completion": "fun closestInteger(value: String): Int {\n    val number = value.toDoubleOrNull() ?: throw IllegalArgumentException(\"Invalid number\")\n    val intValue = Math.round(number)\n    if (Math.abs(intValue - number) > Math.abs(intValue + 1 - number)) {\n        return intValue + 1\n    } else {\n        return intValue\n    }\n}"}
{"task_id": "kotlin/43", "language": "kotlin", "completion": "fun makeAPile(n: Int): List<Int> {\n    val result = mutableListOf<Int>()\n    var currentLevelStones = n\n\n    // Iterate while we have stones left for the current level\n    while (currentLevelStones > 0) {\n        // Add the number of stones for the current level to the result list\n        result.add(currentLevelStones)\n\n        // Calculate the next level's stones based on the current level being odd or even\n        val nextLevelStones = if (currentLevelStones % 2 == 0) {\n            currentLevelStones + 1 // Even number, add 1 to get the next even number\n        } else {\n            currentLevelStones * 2 // Odd number, double it to get the next odd number\n        }\n\n        // Update the current level with the next level's stones\n        currentLevelStones = nextLevelStones\n    }\n\n    return result.reversed() // Reverse the list so that the levels are in the correct order (level 1 is first)\n}"}
{"task_id": "kotlin/44", "language": "kotlin", "completion": "fun wordsString(s: String): List<String> {\n    return s.split(Regex(\"\\\\s|,\"))\n}"}
{"task_id": "kotlin/45", "language": "kotlin", "completion": "fun chooseNum(x: Int, y: Int): Int {\n    if (x % 2 != 0 || y % 2 != 0) return -1 // If x or y is not even, return -1\n\n    // Find the smallest even number that's greater than or equal to x and less than or equal to y\n    val evenX = x + 2\n    var result = evenX\n\n    while (result <= y) {\n        result += 2\n    }\n\n    return if (result > y) -1 else result - 2 // If the found number is greater than y, return -1; otherwise, return the result minus 2 (since it was incremented by 2 at each loop and we need to subtract one extra time)\n}"}
{"task_id": "kotlin/46", "language": "kotlin", "completion": "fun roundedAvg(n: Int, m: Int): String {\n    if (n > m) return \"-1\"\n\n    val sum = ((m.toLong() + 1) / 2) * (m - n + 1)\n    val avg = Math.round(sum.toDouble() / 2.0).toInt()\n    val binary = Integer.toBinaryString(avg)\n    return \"0b$binary\"\n}"}
{"task_id": "kotlin/47", "language": "kotlin", "completion": "fun f(n: Int): List<Int> {\n    val result = mutableListOf<Int>()\n    for (i in 1..n) {\n        if (i % 2 == 0) {\n            // calculate the factorial of i\n            var fact = 1\n            for (j in 1 until (i + 1)) {\n                fact *= j\n            }\n            result.add(fact)\n        } else {\n            // sum up numbers from 1 to i\n            var sum = 0\n            for (j in 1..i) {\n                sum += j\n            }\n            result.add(sum)\n        }\n    }\n    return result\n}"}
{"task_id": "kotlin/48", "language": "kotlin", "completion": "fun evenOddPalindrome(n: Int): Pair<Int, Int> {\n    var evenCount = 0\n    var oddCount = 0\n    val palindromes = mutableListOf(1) // start with the smallest palindrome, 1\n\n    for (i in 2 until n + 1) {\n        val reversedNumber = i.toString().reversed()\n        val reversedInt = reversedNumber.toInt()\n        if (i == reversedInt && isPalindrome(i)) {\n            if (i % 2 == 0) evenCount++ else oddCount++\n            palindromes.add(i)\n        }\n    }\n\n    return Pair(evenCount, oddCount)\n}\n\nfun isPalindrome(number: Int): Boolean {\n    val numberString = number.toString()\n    for (i in 0 until numberString.length / 2) {\n        if (numberString[i] != numberString[numberString.length - i - 1]) return false\n    }\n    return true\n}"}
{"task_id": "kotlin/49", "language": "kotlin", "completion": "fun moveOneBall(arr : List<Any>): Boolean {\n    if (arr.isEmpty()) return true\n\n    // Stable sort using insertion sort\n    for (i in 1 until arr.size) {\n        var j = i\n        val key = arr[j]\n        while (j > 0 && arr[j - 1] > key) {\n            arr[j] = arr[j - 1]\n            j--\n        }\n        arr[j] = key\n    }\n\n    // Check if the sorted array is equal to the original array\n    return arr == sortedSetOf(*arr).toList()\n}"}
{"task_id": "kotlin/50", "language": "kotlin", "completion": "fun exchange(lst1: List<Int>, lst2: List<Int>): String {\n    val oddCount1 = lst1.count { it % 2 != 0 }\n    val evenCount2 = lst2.count { it % 2 == 0 }\n\n    if (oddCount1 > evenCount2) return \"NO\"\n\n    val evenCount1 = lst1.count { it % 2 == 0 }\n    if (evenCount1 != lst1.size) return \"NO\"\n\n    val swapsNeeded = oddCount1 - evenCount2\n    val canSwap = swapsNeeded <= lst2.size\n\n    if (!canSwap) return \"NO\"\n\n    // Perform the exchanges and check if all elements of lst1 are even\n    for (i in 0 until swapsNeeded) {\n        val oddIndex = lst2.indexOfFirst { it % 2 != 0 }\n        val evenIndex = lst1.indexOfFirst { it % 2 == 0 }\n        if (oddIndex == -1 || evenIndex == -1) break\n\n        val temp = lst1[evenIndex]\n        lst1[evenIndex] = lst2[oddIndex]\n        lst2[oddIndex] = temp\n    }\n\n    return \"YES\"\n}"}
{"task_id": "kotlin/51", "language": "kotlin", "completion": "fun reverseDelete(s: String, c: String): List<Any> {\n    val charsToRemove = c.toSet()\n    var sWithoutChars = s\n    for (i in 0 until sWithoutChars.length) {\n        if (charsToRemove.contains(sWithoutChars[i])) {\n            sWithoutChars = sWithoutChars.filterIndexedNot { _, index -> index != i }\n        }\n    }\n    val isPalindrome = checkPalindrome(sWithoutChars)\n    return listOf(sWithoutChars, isPalindrome)\n}\n\nprivate fun checkPalindrome(str: String): Boolean {\n    if (str.length <= 1) return true\n    val midIndex = str.length / 2\n    return str[0] == str[str.length - 1] && checkPalindrome(str.substring(1 until midIndex) + str.substring(midIndex..-1).reversed())\n}"}
{"task_id": "kotlin/52", "language": "kotlin", "completion": "fun maxFill(grid: List<List<Int>>, capacity: Int): Int {\n    val n = grid.size\n    var water = 0 // total amount of water in the wells\n    for (row in grid) water += row.sumBy { it }\n\n    var fillCount = 0 // number of times we can fully fill a bucket\n    if (water <= capacity * n) return water // if all water can be removed with one bucket per well, return the amount of water\n\n    for (row in grid) { // iterate over each row\n        var bucket = capacity\n        val rowWater = row.filter { it == 1 }.sumBy { minOf(it, bucket) } // fill the bucket up to its capacity from this row\n        bucket -= rowWater // simulate emptying the bucket from this row\n        if (bucket > 0) { // if there's still water left in the bucket\n            val remainingBucket = Math.min(bucket, row.filter { it == 1 }.sum()) // empty the rest of the bucket on this row\n            water -= remainingBucket // update the total amount of water\n        }\n        fillCount += rowWater // count the water we removed from this row\n    }\n    return fillCount * capacity + (water / n) // return the number of full buckets plus any leftover water divided by the average bucket capacity per iteration\n}"}
{"task_id": "kotlin/53", "language": "kotlin", "completion": "fun selectWords(s : String, n : Int) : List<String> {\n    val regex = Regex(\"\\\\b(\\\\w+)\\\\b\") // matches words with any characters (letters or digits)\n    val matches = regex.findAll(s).toList() // finds all matches in the input string\n\n    return matches.filter { it.value.length - it.value.filter { c -> c.isLetter() && !c.isLowerCase()}.count() == n }\n}"}
{"task_id": "kotlin/54", "language": "kotlin", "completion": "fun maximum(arr: List<Int>, k: Int): List<Int> {\n    val sortedArray = arr.sorted()\n    return sortedArray.reversed().take(k)\n}"}
{"task_id": "kotlin/55", "language": "kotlin", "completion": "fun addElements(arr: List<Int>, k: Int): Int {\n    val result = mutableListOf<Int>() // Store the elements with at most two digits\n    for (i in arr) {\n        if (i < 100 || i >= 1000) { // If the number has more than two digits, we skip it\n            continue\n        }\n        result.add(i) // Otherwise, we add the number to our result list\n    }\n\n    return result.subList(0, Math.min(result.size, k)).sum() // Return the sum of the first k numbers in the result list\n}"}
{"task_id": "kotlin/56", "language": "kotlin", "completion": "fun intersection(interval1: List<Int>, interval2: List<Int>): String {\n    if (interval1[0] > interval2[1] || interval2[0] > interval1[1]) {\n        return \"NO\"\n    }\n\n    val start = maxOf(interval1[0], interval2[0])\n    val end = minOf(interval1[1], interval2[1])\n\n    if (start == end) {\n        // The intersection is a single point, which can't be prime.\n        return \"NO\"\n    }\n\n    return if (isPrime(end - start + 1)) {\n        \"YES\"\n    } else {\n        \"NO\"\n    }\n}\n\nfun isPrime(n: Int): Boolean {\n    if (n <= 1) {\n        return false\n    }\n    if (n == 2) {\n        return true\n    }\n    if (n % 2 == 0) {\n        return n == 2\n    }\n    val limit = Math.sqrt(n.toDouble()).toInt()\n    for (i in 3..limit step 2) {\n        if (n % i == 0) {\n            return false\n        }\n    }\n    return true\n}"}
{"task_id": "kotlin/57", "language": "kotlin", "completion": "fun tri(n: Int): List<Int> {\n    if (n <= 0) return listOf()\n    val tribo = mutableListOf(3) // initialize the first element of the sequence\n\n    for (i in 2..n) {\n        when (i % 2) {\n            0 -> tribo.add(1 + tribo[i / 2])\n            else -> tribo.add((tribo[i - 1] + tribo[i - 2] + tribo[i + 1]))\n        }\n    }\n\n    return tribo\n}"}
{"task_id": "kotlin/58", "language": "kotlin", "completion": "fun digits(n: Int): Int {\n    val str = n.toString()\n    var product = 1\n\n    for (i in str) {\n        if (i - '0' % 2 != 0) {\n            product *= (i - '0')\n        }\n    }\n\n    return if (product == 1) 0 else product\n}"}
{"task_id": "kotlin/59", "language": "kotlin", "completion": "fun isNested(string : String) : Boolean {\n    var openBracketsCount = 0\n    for (c in string) {\n        when (c) {\n            '[' -> openBracketsCount++\n            ']' -> if (openBracketsCount > 0) openBracketsCount-- else return false\n        }\n    }\n    return openBracketsCount == 0 // If the string has any unclosed brackets, it means there is no nested sequence.\n}"}
{"task_id": "kotlin/60", "language": "kotlin", "completion": "fun sumSquares(lst: List<Any>): Int {\n    val squaredAndRoundedList = lst.map { Math.ceil(it.toDouble()).toInt() * it.toDouble() }\n    return squaredAndRoundedList.sum()\n}"}
{"task_id": "kotlin/61", "language": "kotlin", "completion": "import java.util.regex.Pattern\n\nfun checkIfLastCharIsALetter(txt : String) : Boolean {\n    if (txt.isEmpty()) return false\n\n    val wordRegex = Pattern.compile(\"\\\\s+\")\n    val words = txt.split(wordRegex)\n\n    // Check for the case when the string contains only one word\n    if (words.size == 1) {\n        val lastChar = words[0].last()\n        return lastChar.isLetter() && !lastChar.isLowerCase() // Only consider uppercase letters as they can be at the end of a word, like \"A\" in \"hello A\"\n    }\n\n    // Check if the last character is alphabetical and not part of the last word\n    val lastWord = words[words.lastIndex]\n    return lastWord.length > 1 && lastWord.last() == lastWord.last().toUpperCase() && lastWord.last() != lastWord.last().toLowerCase()\n}"}
{"task_id": "kotlin/62", "language": "kotlin", "completion": "fun canArrange(arr: List<Int>): Int {\n    if (arr.isEmpty()) return -1\n\n    var currentMax = arr[0]\n    var currentIndex = 0\n\n    for ((i, value) in arr.withIndex()) {\n        if (value <= currentMax) {\n            currentMax = Math.min(currentMax, value)\n            currentIndex = i\n        } else {\n            return currentIndex\n        }\n    }\n\n    return -1\n}"}
{"task_id": "kotlin/63", "language": "kotlin", "completion": "fun largestSmallestIntegers(lst: List<Any>): Pair<Int?, Int?> {\n    val negative = lst.filterIsInstance<Int>().filter { it < 0 }.maxOrNull()\n    val positive = lst.filterIsInstance<Int>().filter { it > 0 }.minOrNull()\n\n    return Pair(negative, positive)\n}"}
{"task_id": "kotlin/64", "language": "kotlin", "completion": "fun specialFactorial(n: Int): Long {\n    require(n > 0) { \"Input number must be greater than zero\" }\n    var result = 1L\n    for (i in n downTo 2) {\n        result *= i.toLong()\n    }\n    return result * factorial(n)\n}\n\nprivate fun factorial(n: Int): Long {\n    require(n >= 0) { \"Input number must be non-negative\" }\n    if (n == 0 || n == 1) {\n        return 1\n    }\n    var result = 1L\n    for (i in 2..n) {\n        result *= i.toLong()\n    }\n    return result\n}"}
{"task_id": "kotlin/65", "language": "kotlin", "completion": "fun isPrime(n: Int): Boolean {\n    if (n <= 1) return false\n    for (i in 2 until n) {\n        if (n % i == 0) return false\n    }\n    return true\n}\n\nfun wordsInSentence(sentence : String) : String {\n    val words = sentence.split(\" \")\n    val primeWords: MutableList<String> = mutableListOf()\n    for (word in words) {\n        if (isPrime(word.length)) {\n            primeWords.add(word)\n        }\n    }\n    return primeWords.joinToString(\" \")\n}"}
{"task_id": "kotlin/66", "language": "kotlin", "completion": "fun simplify(x: String, n: String): Boolean {\n    val (numX, denX) = x.split(\"/\").map { it.toInt() }\n    val (numN, denN) = n.split(\"/\").map { it.toInt() }\n\n    // GCD of numX and denX, and numN and denN should be 1 if the fractions are simplified\n    val gcdX = gcd(numX, denX)\n    val gcdN = gcd(numN, denN)\n\n    // Check if both GCDs are 1, otherwise the fractions are not simplified\n    return (gcdX == 1 && gcdN == 1) && (numX * denN == numN * denX)\n}\n\n// Function to calculate the greatest common divisor of two numbers\nfun gcd(a: Int, b: Int): Int {\n    if (b == 0) return a\n    else return gcd(b, a % b)\n}"}
{"task_id": "kotlin/67", "language": "kotlin", "completion": "fun orderByPoints(nums: List<Int>): List<Int> {\n    val numMap = mutableMapOf<Int, MutableList<Int>>()\n    for ((i, n) in nums.withIndex()) {\n        val sum = n.toString().map { it - '0' }.sum()\n        if (!numMap.containsKey(sum)) {\n            numMap[sum] = mutableListOf()\n        }\n        numMap[sum]!!.add(i)\n    }\n\n    val sortedNums = numMap.mapValues { (k, v) -> v.sortedBy(Comparators.natural()) }.flatMap { it.value }.toMutableList()\n\n    return sortedNums\n}"}
{"task_id": "kotlin/68", "language": "kotlin", "completion": "fun specialFilter(nums: List<Any>): Int {\n    val result = mutableListOf<Int>()\n\n    for (num in nums) {\n        if (num is Int && num > 10) {\n            val firstDigit = (num / 10).toInt() % 10\n            val lastDigit = num % 10\n            if (firstDigit == 1 || firstDigit == 3 || firstDigit == 5 || firstDigit == 7 || firstDigit == 9 &&\n                lastDigit == 1 || lastDigit == 3 || lastDigit == 5 || lastDigit == 7 || lastDigit == 9) {\n                result.add(num)\n            }\n        }\n    }\n\n    return result.size\n}"}
{"task_id": "kotlin/69", "language": "kotlin", "completion": "fun getMaxTriples(n: Int): Int {\n    val a = Array(n) { it * it - it + 1 } // Create the array a with given length n and fill it according to task description\n    var count = 0 // Initialize counter for triples that satisfy the condition\n    for (i in 0 until a.size - 2) { // Iterate through the array from index 0 to n-3 (excluding the last element because we don't need it for valid triples)\n        for (j in i + 1 until a.size - 1) {\n            for (k in j + 1 until a.size) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) { // Check if the sum of current triple is a multiple of 3\n                    count++ // If it is, increment the counter\n                }\n            }\n        }\n    }\n    return count * 3 // Since we've only counted triples where i < j < k, multiply by 3 to account for all valid triples (with any permutations)\n}"}
{"task_id": "kotlin/70", "language": "kotlin", "completion": "val planets = listOf(\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n\nfun bf(planet1 : String, planet2 : String) : List<String> {\n    if (!planets.contains(planet1) || !planets.contains(planet2)) {\n        return emptyList()\n    }\n\n    val index1 = planets.indexOf(planet1) + 1\n    val index2 = planets.indexOf(planet2)\n\n    val result = mutableListOf<String>()\n    for (i in index1..index2 - 1) {\n        result.add(planets[i])\n    }\n\n    return result.sorted()\n}"}
{"task_id": "kotlin/71", "language": "kotlin", "completion": "fun isPrime(num: Int): Boolean {\n    if (num <= 1) return false\n    if (num == 2) return true\n    if (num % 2 == 0) return false\n\n    var i = 3\n    while (i * i <= num) {\n        if (num % i == 0) return false\n        i += 2\n    }\n\n    return true\n}\n\nfun xOrY(n: Int, x: Int, y: Int): Int {\n    if (isPrime(n)) {\n        return x\n    } else {\n        return y\n    }\n}"}
{"task_id": "kotlin/72", "language": "kotlin", "completion": "fun doubleTheDifference(lst: List<Any>): Int {\n    val result = lst.filterIsInstance<Int>() // filter out non-integer values\n        .filter { it > 0 && it % 2 != 0 } // filter out negative numbers and even numbers\n        .map { it * it } // square each remaining number\n        .fold(0, Int::plus) // sum up all squared odd numbers\n    return result\n}"}
{"task_id": "kotlin/73", "language": "kotlin", "completion": "fun strongestExtension(className: String, extensions: List<String>): String {\n    val extensionStrengthMap = mutableMapOf<String, Int>()\n\n    // Calculate the strength of each extension\n    for (extension in extensions) {\n        val uppercaseCount = extension.count { it.isUpperCase() }\n        val lowercaseCount = extension.count { it.isLowerCase() }\n        val strength = uppercaseCount - lowercaseCount\n        extensionStrengthMap[extension] = strength\n    }\n\n    // Find the strongest extension and return its fully qualified name\n    var strongestExtension: String? = null\n    for ((extension, strength) in extensionStrengthMap.entries) {\n        if (strongestExtension == null || strongestExtension!!.compareTo(strength) > 0) {\n            strongestExtension = extension\n        }\n    }\n\n    return \"$className.$strongestExtension\"\n}"}
{"task_id": "kotlin/74", "language": "kotlin", "completion": "fun cycpatternCheck(a: String, b: String): Boolean {\n    val rotations = generateRotations(b)\n    return rotations.any { a.contains(it) }\n}\n\nprivate fun generateRotations(word: String): List<String> {\n    var result = mutableListOf<String>()\n    for (i in 1 until word.length) {\n        val prefixLength = i\n        val suffixLength = word.length - prefixLength\n        result.add(word.substring(suffixLength).also { prefixedWord ->\n            result.add(prefixedWord + word.subSequence(0, prefixLength))\n        })\n    }\n    return result\n}"}
{"task_id": "kotlin/75", "language": "kotlin", "completion": "fun intToMiniRoman(number: Int): String {\n    val romanNumbers = mapOf(\n        1 to \"i\",\n        4 to \"iv\",\n        5 to \"v\",\n        9 to \"ix\",\n        10 to \"x\",\n        40 to \"xl\",\n        50 to \"l\",\n        90 to \"xc\",\n        100 to \"c\",\n        400 to \"cd\",\n        500 to \"d\",\n        900 to \"cm\",\n        1000 to \"m\"\n    )\n\n    fun convert(number: Int, symbol: String): String {\n        val result = StringBuilder()\n        while (number >= symbol.length) {\n            number -= symbol.length\n            result.append(symbol)\n        }\n        if (number > 0) result.append(StringBuilder().repeat(number)(symbol[0]))\n        return result.toString()\n    }\n\n    return romanNumbers.entries\n        .filter { number >= it.key }\n        .map { convert(number / it.key, it.value) }\n        .reversed()\n        .joinToString(\"\")\n}"}
{"task_id": "kotlin/76", "language": "kotlin", "completion": "fun rightAngleTriangle(a: Int, b: Int, c: Int): Boolean {\n    val aSquared = a * a\n    val bSquared = b * b\n    val cSquared = c * c\n\n    return (aSquared + bSquared) == cSquared || (bSquared + cSquared) == aSquared || (cSquared + aSquared) == bSquared\n}"}
{"task_id": "kotlin/77", "language": "kotlin", "completion": "fun solve(s: String): String {\n    if (s.all { it !is Char }) return s.reversed()\n\n    val sb = StringBuilder()\n    for (c in s) {\n        when (c) {\n            in 'a'..'z' -> sb.append(Character.toUpperCase(c))\n            in 'A'..'Z' -> sb.append(Character.toLowerCase(c))\n            else         -> sb.append(c)\n        }\n    }\n\n    return sb.toString()\n}"}
{"task_id": "kotlin/78", "language": "kotlin", "completion": "import java.security.MessageDigest\nimport java.math.BigInteger\nimport java.lang.String\n\nfun stringToMd5(text : String) : String? {\n    if (text.isEmpty()) return null\n\n    val md = MessageDigest.getInstance(\"MD5\")\n    val digest = md.digest(text.toByteArray())\n\n    return BigInteger(1, digest).toString(16).padStart(32, '0')\n}"}
{"task_id": "kotlin/79", "language": "kotlin", "completion": "fun generateIntegers(a: Int, b: Int): List<Int> {\n    val result = mutableListOf<Int>()\n    if (a % 2 > 0 && b % 2 <= 0 || a % 2 <= 0 && b % 2 > 0) {\n        if (a < b) {\n            for (i in a until b step 2) {\n                result.add(i)\n            }\n        } else {\n            for (i in b downTo a step 2) {\n                result.add(i)\n            }\n        }\n    }\n    return result\n}"}
