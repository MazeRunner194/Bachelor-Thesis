{"task_id": "typescript/0", "language": "typescript", "completion": "const below_zero = function (operations: Array<number>): boolean {\n  let balance = 0;\n  for (let operation of operations) {\n    balance += operation;\n    if (balance < 0) return true;\n  }\n  return false;\n}"}
{"task_id": "typescript/1", "language": "typescript", "completion": "const sum_product = (numbers: number[]): [number, number] => {\n  let sum = 0;\n  let product = 1;\n\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= numbers[i];\n  }\n\n  return [sum, product];\n};"}
{"task_id": "typescript/2", "language": "typescript", "completion": "const string_xor = function (a: string, b: string) : string {\n  let result = '';\n  const len = Math.max(a.length, b.length);\n\n  for (let i = 0; i < len; i++) {\n    // Pad shorter string with zeros at the end if necessary\n    const charA = a[i] || '0';\n    const charB = b[i] || '0';\n\n    result += (charA === charB) ? '0' : '1';\n  }\n\n  return result;\n}"}
{"task_id": "typescript/3", "language": "typescript", "completion": "function longest(strings: string[]): string | null {\n  if (!strings.length) return null;\n\n  let maxLength = strings[0].length;\n  let resultIndex = 0;\n\n  for (let i = 1; i < strings.length; i++) {\n    if (strings[i].length > maxLength) {\n      maxLength = strings[i].length;\n      resultIndex = i;\n    } else if (strings[i].length === maxLength) {\n      resultIndex = i;\n    }\n  }\n\n  return strings[resultIndex];\n}"}
{"task_id": "typescript/4", "language": "typescript", "completion": "function greatest_common_divisor(a: number, b: number): number {\n    if (!Number.isInteger(a) || !Number.isInteger(b)) {\n        throw new Error(\"Both a and b must be integers\");\n    }\n\n    // Handle the edge case where one of the numbers is 0\n    if (b === 0) return a;\n    if (a < b) [a, b] = [b, a]; // Swap a and b so that a >= b\n\n    // Recursively call the function with the remainder until it's 0\n    return greatest_common_divisor(b, a % b);\n}"}
{"task_id": "typescript/5", "language": "typescript", "completion": "const sort_numbers = function (numbers: string): string {\n  const sortedNumbers = numbers.split(' ')\n    .map(word => parseInt(word, 10)) // Convert the words to numbers\n    .sort((a, b) => a - b); // Sort the numbers in ascending order\n\n  return sortedNumbers.map(number => number.toString()).join(' '); // Convert the sorted numbers back to strings and join them into a single string\n}"}
{"task_id": "typescript/6", "language": "typescript", "completion": "const rescale_to_unit = function (numbers: Array<number>): Array<number> {\n  const [min, max] = Math.min(...numbers), ...restNumbers = numbers;\n  return restNumbers.map((number) => (number - min) / (max - min));\n};"}
{"task_id": "typescript/7", "language": "typescript", "completion": "const flip_case = (str: string): string => {\n  return str.split('').map(char => char === char.toUpperCase() ? char.toLowerCase() : char.toUpperCase()).join('');\n}"}
{"task_id": "typescript/8", "language": "typescript", "completion": "const get_positive = (l: number[]): number[] => {\n  return l.filter(num => num > 0);\n};"}
{"task_id": "typescript/9", "language": "typescript", "completion": "const isPrime = (n: number): boolean => {\n  // If n is less than or equal to 1, return false as neither 1 nor any negative numbers are prime.\n  if (n <= 1) return false;\n\n  // Start from 2 since it's the first prime number and check divisibility up to the square root of n.\n  for (let i = 2; i <= Math.sqrt(n); i++) {\n    if (n % i === 0) return false;\n  }\n\n  // If no divisors were found, return true as it's a prime number.\n  return true;\n};"}
{"task_id": "typescript/10", "language": "typescript", "completion": "function unique(arr: number[]): number[] {\n    let set = new Set(arr);\n    return Array.from(set);\n}"}
{"task_id": "typescript/11", "language": "typescript", "completion": "import * as math from 'mathjs';\n\nconst isPrime = (n: number): boolean => {\n  if (n <= 1) return false;\n  const sqrtN = Math.sqrt(n);\n  for (let i = 2; i <= sqrtN; i++) {\n    if (n % i === 0) return false;\n  }\n  return true;\n};\n\nconst fibonacci = (n: number): number => {\n  const fib = [0, 1];\n  for (let i = 2; i <= n; i++) {\n    fib[i] = math.add(fib[i - 1], fib[i - 2]);\n  }\n  return fib[n];\n};\n\nconst prime_fib = function (n: number): number {\n  let found = false;\n  for (let i = 0; !found && i <= n; i++) {\n    const fibNumber = fibonacci(i);\n    if (isPrime(fibNumber)) {\n      found = true;\n    }\n  }\n  return Math.min(...Array.from({ length: n + 1 }, (_, idx) => {\n    const fibNumber = fibonacci(idx);\n    return fibNumber && isPrime(fibNumber) ? fibNumber : Infinity;\n  }));\n};"}
{"task_id": "typescript/12", "language": "typescript", "completion": "function triples_sum_to_zero(l: number[]): boolean {\n  const map: Record<number, number> = {};\n\n  for (let i = 0; i < l.length; i++) {\n    if (!map[0 - l[i]]) {\n      map[l[i]] = i;\n    } else if (map[-(l[i] + l[map[0 - l[i]]))] !== undefined) {\n      return true;\n    }\n  }\n\n  return false;\n}"}
{"task_id": "typescript/13", "language": "typescript", "completion": "const pairs_sum_to_zero = function (l: number[]): boolean {\n  const numCounts = {};\n  for (let i = 0; i < l.length; ++i) {\n    if (numCounts[-l[i]] !== undefined) {\n      return true;\n    }\n    numCounts[l[i]] = (numCounts[l[i]] || 0) + 1;\n  }\n  return false;\n};"}
{"task_id": "typescript/14", "language": "typescript", "completion": "function fib4(n: number): number {\n  let current = [0, 0, 2]; // initial values for the first four terms\n  let len = current.length;\n\n  if (n < len) {\n    return current[n]; // return value if n is less than 4\n  }\n\n  for (let i = len; i <= n; i++) {\n    const next = current[i - 1] + current[i - 2] + current[i - 3] + current[i - 4];\n    current.push(next);\n  }\n\n  return current[n]; // return the requested value\n}"}
{"task_id": "typescript/15", "language": "typescript", "completion": "const median = function (l: Array<number>) : number {\n    let sortedL = [...l].sort((a, b) => a - b);\n    const n = sortedL.length;\n\n    if (n === 0) {\n        throw new Error('Die Liste ist leer.');\n    }\n\n    if (n % 2 === 0) { // gerade Anzahl Elemente\n        return (sortedL[Math.floor(n / 2)] + sortedL[Math.ceil(n / 2)]) / 2;\n    } else { // ungerade Anzahl Elemente\n        return sortedL[(n - 1) / 2];\n    }\n};"}
{"task_id": "typescript/16", "language": "typescript", "completion": "const is_palindrome = function (text: string): boolean {\n  let leftIndex = 0;\n  let rightIndex = text.length - 1;\n\n  while (leftIndex < rightIndex) {\n    if (text[leftIndex] !== text[rightIndex]) {\n      return false;\n    }\n    leftIndex++;\n    rightIndex--;\n  }\n\n  return true;\n};"}
{"task_id": "typescript/17", "language": "typescript", "completion": "const remove_vowels = function (text: string): string {\n  const vowelRegex = /[aeiouAEIOU]/g;\n  return text.replace(vowelRegex, '');\n}"}
{"task_id": "typescript/18", "language": "typescript", "completion": "const below_threshold = (l: number[], t: number): boolean => {\n  return l.every(num => num < t);\n};"}
{"task_id": "typescript/19", "language": "typescript", "completion": "function add(x: number, y: number): number {\n  return x + y;\n}"}
{"task_id": "typescript/20", "language": "typescript", "completion": "const same_chars = function (s0: string, s1: string) : boolean {\n    const set0 = new Set(s0);\n    const set1 = new Set(s1);\n\n    // If the two sets have different sizes, they cannot contain the same characters.\n    if (set0.size !== set1.size) return false;\n\n    // If all elements in set0 are also present in set1, then the strings have the same characters.\n    for (const char of set0) {\n        if (!set1.has(char)) return false;\n    }\n\n    return true;\n};"}
{"task_id": "typescript/21", "language": "typescript", "completion": "const fib = (n: number): number => {\n  if (n <= 1) return n; // Base case, return 1 for n=1 and n itself for n<1\n  return fib(n - 1) + fib(n - 2); // Recursive case\n};"}
{"task_id": "typescript/22", "language": "typescript", "completion": "const common = (l1: number[], l2: number[]): number[] => {\n  const setL1 = new Set(l1);\n  const resultSet = new Set<number>();\n\n  for (const element of l2) {\n    if (setL1.has(element)) {\n      resultSet.add(element);\n      setL1.delete(element);\n    }\n  }\n\n  return [...resultSet].sort((a, b) => a - b);\n};"}
{"task_id": "typescript/23", "language": "typescript", "completion": "const isPrime = (num: number) => {\n    if (num <= 1) return false;\n    if (num === 2) return true;\n    for (let i = 2; i * i <= num; i++) {\n        if (num % i === 0) return false;\n    }\n    return true;\n}\n\nconst largest_prime_factor = function (n: number) : number {\n    let sqrtN = Math.sqrt(n);\n\n    for (let i = sqrtN; i >= 2; i--) {\n        if (isPrime(i) && n % i === 0) return i;\n    }\n\n    // If no prime factors are found, the input number itself is a prime number.\n    return n;\n}"}
{"task_id": "typescript/24", "language": "typescript", "completion": "function sum_to_n(n: number): number {\n  let total = 0;\n  for (let i = 1; i <= n; i++) {\n    total += i;\n  }\n  return total;\n}"}
{"task_id": "typescript/25", "language": "typescript", "completion": "const derivative = (xs: Array<number>): Array<number> => {\n    const n = xs.length;\n    return Array(n + 1).fill(0).map((_, i) => i < n ? xs[i + 1] * (n + 1 - i) : 0);\n};"}
{"task_id": "typescript/26", "language": "typescript", "completion": "function fibfib(n: number): number {\n    if (n <= 2) return 0;\n    let prevPrev = 0, prev = 0, current = 1;\n\n    for (let i = 3; i <= n; i++) {\n        [prevPrev, prev, current] = [prev, current, prev + prevPrev + current];\n    }\n\n    return current;\n}"}
{"task_id": "typescript/27", "language": "typescript", "completion": "const vowelsRegex = /[aeiouy]/gi;\n\nfunction vowels_count(s: string): number {\n  let matches = s.match(vowelsRegex);\n  let vowelCount: number = matches ? matches.length : 0;\n\n  // Check for the 'y' at the end of the string, if present, increment the count by 1\n  if (s[s.length - 1] === \"y\") {\n    vowelCount++;\n  }\n\n  return vowelCount;\n}"}
{"task_id": "typescript/28", "language": "typescript", "completion": "function search(lst: number[]): number {\n    let maxFrequency = -1;\n    let maxValue: number|undefined;\n\n    for (const num of lst) {\n        let count = lst.filter(n => n === num).length;\n        if (count >= num && count > maxFrequency) {\n            maxFrequency = count;\n            maxValue = num;\n        }\n    }\n\n    return maxValue !== undefined ? maxValue : -1;\n}"}
{"task_id": "typescript/29", "language": "typescript", "completion": "const triangle_area = function (a: number, b: number, c: number) : number {\n  if (a + b > c && a + c > b && b + c > a) {\n    // Calculate the semi-perimeter of the triangle\n    const s = (a + b + c) / 2;\n\n    // Calculate the area using Heron's formula\n    return Math.sqrt(s * (s - a) * (s - b) * (s - c));\n  } else {\n    return -1; // The given sides do not form a valid triangle\n  }\n};"}
{"task_id": "typescript/30", "language": "typescript", "completion": "function will_it_fly(q: number[], w: number): boolean {\n  // Check if the list is palindrome (symmetrical)\n  const isPalindrome = (arr: number[]): boolean => {\n    let i = 0;\n    let j = arr.length - 1;\n    while (i < j) {\n      if (arr[i] !== arr[j]) return false;\n      i++;\n      j--;\n    }\n    return true;\n  };\n\n  // Check if the sum is less than or equal to w and if it's a palindrome\n  return isPalindrome(q) && q.reduce((acc, val) => acc + val, 0) <= w;\n}"}
{"task_id": "typescript/31", "language": "typescript", "completion": "function is_multiply_prime(a: number): boolean {\n    // Initialize an array to store prime numbers up to a square root of a\n    const primes = new Array(Math.floor(Math.sqrt(a)) + 1).fill(true);\n    primes[0] = false;\n    primes[1] = false;\n\n    // Sieve of Eratosthenes algorithm to find prime numbers\n    for (let i = 2; i <= Math.floor(Math.sqrt(a)); i++) {\n        if (primes[i]) {\n            for (let j = i * i; j <= Math.floor(Math.sqrt(a)); j += i) {\n                primes[j] = false;\n            }\n        }\n    }\n\n    // Check combinations of three prime numbers that equal a\n    for (let p1 of primes) {\n        if (!p1) continue;\n\n        let multiplier = a / p1;\n        for (let p2 = p1 + 1; p2 <= Math.floor(Math.sqrt(multiplier)); p2++) {\n            if (!primes[p2]) continue;\n\n            if ((multiplier % p2 === 0) && (a % p1 * p2 === multiplier)) {\n                let p3 = a / (p1 * p2);\n                if (primes[p3] && (p1 * p2 * p3 === a)) return true;\n            }\n        }\n    }\n    return false;\n}"}
{"task_id": "typescript/32", "language": "typescript", "completion": "const decimal_to_binary = (decimal: number): string => {\n  let binary: string = 'db';\n\n  while (decimal > 0) {\n    binary += (decimal % 2).toString();\n    decimal = Math.floor(decimal / 2);\n  }\n\n  return binary + 'db';\n}"}
{"task_id": "typescript/33", "language": "typescript", "completion": "function isHappy(s: string): boolean {\n  // Check if the length of the string is less than 3\n  if (s.length < 3) return false;\n\n  let group = s[0] + s[1] + s[2];\n\n  for (let i = 3; i < s.length - 2; i += 3) {\n    // Check if the current group is not equal to the previous group\n    if (group === s[i] + s[i+1] + s[i+2]) return false;\n\n    // Update the group for the next comparison\n    group = s[i] + s[i+1] + s[i+2];\n  }\n\n  return true;\n}"}
{"task_id": "typescript/34", "language": "typescript", "completion": "const numerical_letter_grade = (grades: number[]) : string[] => {\n  return grades.map(gpa => {\n    const letterGrade = getLetterGrade(gpa);\n    if (isNaN(gpa)) throw new Error(`Invalid GPA value provided: ${gpa}`);\n    return letterGrade;\n  });\n}\n\nconst getLetterGrade = (gpa: number) => {\n  const gradeRanges = [\n    [4.0, \"A+\"],\n    [3.7, \"A\"],\n    [3.3, \"A-\"],\n    [3.0, \"B+\"],\n    [2.7, \"B\"],\n    [2.3, \"B-\"],\n    [2.0, \"C+\"],\n    [1.7, \"C\"],\n    [1.3, \"C-\"],\n    [1.0, \"D+\"],\n    [0.7, \"D\"],\n    [0.0, \"D-\"],\n    [0.0, \"E\"]\n  ];\n\n  for (let i = 0; i < gradeRanges.length - 1; i += 2) {\n    if (gpa >= gradeRanges[i][0]) {\n      return gradeRanges[i][1];\n    }\n  }\n  // If no match is found, the GPA is less than 0.0 and will be assigned an E.\n  return gradeRanges[gradeRanges.length - 1][1];\n}"}
{"task_id": "typescript/35", "language": "typescript", "completion": "function isPrime(num: number): boolean {\n  if (num <= 1) return false;\n  if (num <= 3) return true;\n\n  for (let i = 2; i * i <= num; i++) {\n    if (num % i === 0) return false;\n  }\n\n  return true;\n}\n\nconst prime_length = function (string: string): boolean {\n  const len = Number(string.length);\n  return isPrime(len);\n};"}
{"task_id": "typescript/36", "language": "typescript", "completion": "const solve = (N: number): string => {\n    let bin = '';\n\n    while (N > 0) {\n        const remainder = N % 2;\n        bin = (remainder ? '1' : '0') + bin;\n        N = Math.floor(N / 2);\n    }\n\n    return bin;\n};"}
{"task_id": "typescript/37", "language": "typescript", "completion": "function get_row(lst: Array<Array<number>>, x: number): Array<[number, number]> {\n  const coordinates: [number, number][] = [];\n  let rowIndex = -1; // Initialize the row index to -1 since we'll be using it as a flag\n\n  for (let i = 0; i < lst.length; i++) {\n    // Iterate over the rows\n    if (rowIndex === -1 && lst[i].includes(x)) {\n      // If x is found in the current row, set the row index to the current iteration index\n      rowIndex = i;\n    }\n\n    for (let j = 0; j < lst[i].length; j++) {\n      // Iterate over the columns within each row\n      if (lst[i][j] === x) {\n        // If x is found in the current column, push its coordinates to the result array\n        coordinates.push([rowIndex, j]);\n      }\n    }\n  }\n\n  // Sort the resulting array by row and then by column indices in ascending and descending order respectively\n  const sortedCoordinates = coordinates.sort((a, b) => a[0] - b[0] || b[1] - a[1]);\n  return sortedCoordinates;\n}"}
{"task_id": "typescript/38", "language": "typescript", "completion": "type ResultType = number | null;\n\nconst nextSmallest = (lst: Array<number>): ResultType => {\n    if (lst.length === 0) return null;\n\n    const sortedLst = [...lst].sort((a, b) => a - b);\n\n    if (sortedLst.length < 2) return null;\n\n    return sortedLst[1];\n}"}
{"task_id": "typescript/39", "language": "typescript", "completion": "const isBored = (S: string): number => {\n  const regex = /(^Ich\\.)/g; // matches any line starting with \"Ich\" and followed by a period\n  let match: RegExpExecArray | null;\n  let count = 0;\n\n  while ((match = regex.exec(S))) {\n    count++;\n  }\n\n  return count;\n};"}
{"task_id": "typescript/40", "language": "typescript", "completion": "function isPrime(num: number): boolean {\n  // If the number is less than 2 or not an integer, it's not prime\n  if (num < 2 || num % 1 !== 0) return false;\n\n  // Check for divisors up to the square root of the number\n  const sqrt = Math.sqrt(num);\n  for (let i = 2; i <= sqrt; i++) {\n    if (num % i === 0) return false;\n  }\n\n  // If we didn't find any divisors, the number is prime\n  return true;\n}\n\nfunction largestPrimeSumOfDigits(lst: Array<number>): number {\n  let maxPrime = -1;\n  let maxSum = 0;\n\n  for (const num of lst) {\n    if (isPrime(num)) {\n      // If the current number is prime, update the maximum prime and its sum of digits\n      if (maxPrime < 0 || num > maxPrime) {\n        maxPrime = num;\n        maxSum = sumOfDigits(num);\n      }\n    }\n  }\n\n  // Return the sum of the largest prime's digits\n  return maxSum;\n}\n\nfunction sumOfDigits(num: number): number {\n  let total = 0;\n  const strNum = num.toString();\n  for (const char of strNum) {\n    total += parseInt(char, 10);\n  }\n  return total;\n}"}
{"task_id": "typescript/41", "language": "typescript", "completion": "const check_dict_case = function (dict: Map<string, string>): boolean {\n  if (!dict || dict.size === 0) return false;\n\n  const keysArray = Array.from(dict.keys());\n  const [firstKey] = keysArray;\n\n  // Check for consistent case across all keys\n  const isFirstUpperCase = firstKey[0].toUpperCase() === firstKey[0];\n  return keysArray.every((key) => key === firstKey.toLowerCase() || (isFirstUpperCase && key === firstKey.toUpperCase()));\n};"}
{"task_id": "typescript/42", "language": "typescript", "completion": "import * as math from 'mathjs';\n\nconst closest_integer = function (value: string) : number {\n  const num = parseFloat(value); // Parse the input string to a floating-point number\n\n  if (!isFinite(num)) {\n    throw new Error('Invalid number');\n  }\n\n  let result: number;\n  if (math.abs(num).isLessThan(1)) {\n    result = Math.round(num); // If the absolute value of the number is less than 1, round normally\n  } else {\n    const roundUp = Math.ceil(Math.abs(num));\n    const roundDown = Math.floor(Math.abs(num));\n    result = (roundUp - roundDown) % 2 === 0 ? Math.sign(num) * roundDown : Math.sign(num) * roundUp;\n  }\n\n  return result;\n};"}
{"task_id": "typescript/43", "language": "typescript", "completion": "const make_a_pile = function(n: number): Array<number> {\n  if (n === 1) return [n];\n  const nextNum = n % 2 === 0 ? n + 1 : n + 2;\n  return [...make_a_pile(nextNum), nextNum];\n};"}
{"task_id": "typescript/44", "language": "typescript", "completion": "function words_string(s: string): string[] {\n  return s.split(/[ ,]+/);\n}"}
{"task_id": "typescript/45", "language": "typescript", "completion": "const choose_num = (x: number, y: number): number => {\n  // Ensure that x and y are positive integers\n  if (x <= 0 || y <= 0) {\n    throw new Error(\"Both numbers must be positive integers\");\n  }\n\n  let maxEvenNumber = -1;\n\n  for (let i = Math.floor(Math.max(x, y)); i >= Math.ceil(Math.min(x, y)); i -= 2) {\n    // Check if the number is even and update the maxEvenNumber variable\n    if (i === maxEvenNumber || i < maxEvenNumber) continue;\n    maxEvenNumber = i;\n  }\n\n  return maxEvenNumber;\n};"}
{"task_id": "typescript/46", "language": "typescript", "completion": "const rounded_avg = (n: number, m: number): string => {\n    if (n > m) return -1;\n\n    const sum = (n + m) * (m - n + 1) / 2;\n    const avg = Math.round(sum);\n\n    // Convert the average to binary format\n    let binary = (avg).toString(2);\n    if (binary.length < 32) {\n        while (binary.length < 32) {\n            binary = '0' + binary;\n        }\n    }\n\n    return \"0b\" + binary;\n}"}
{"task_id": "typescript/47", "language": "typescript", "completion": "function f(n: number): number[] {\n    let result: number[] = [];\n\n    for (let i = 1; i <= n; i++) {\n        if (i % 2 === 0) {\n            // Calculate factorial using recursion\n            result.push(factorial(i));\n        } else {\n            // Sum of numbers from 1 to i\n            let sum = 0;\n            for (let j = 1; j <= i; j++) {\n                sum += j;\n            }\n            result.push(sum);\n        }\n    }\n\n    return result;\n}\n\n// Recursive function to calculate factorial\nfunction factorial(n: number): number {\n    if (n === 1) {\n        return 1;\n    } else {\n        return n * factorial(n - 1);\n    }\n}"}
{"task_id": "typescript/48", "language": "typescript", "completion": "function isPalindrome(num: number): boolean {\n  const str = num.toString();\n  let leftIndex = 0;\n  let rightIndex = str.length - 1;\n\n  while (leftIndex < rightIndex) {\n    if (str[leftIndex] !== str[rightIndex]) return false;\n    leftIndex++;\n    rightIndex--;\n  }\n\n  return true;\n}\n\nfunction countPalindromes(start: number, end: number): number {\n  let count = 0;\n  for (let i = start; i <= end; i++) {\n    if (isPalindrome(i)) count++;\n  }\n  return count;\n}\n\nfunction evenOddPalindromes(n: number): [number, number] {\n  const totalPalindromes = countPalindromes(1, n);\n  return [countPalindromes(1, n) % 2 === 0 ? totalPalindromes / 2 : Math.floor(totalPalindromes / 2), totalPalindromes - (totalPalindromes % 2 === 0 ? totalPalindromes / 2 : Math.floor(totalPalindromes / 2))];\n}"}
{"task_id": "typescript/49", "language": "typescript", "completion": "function move_one_ball(arr: number[]): boolean {\n  // Check if the array is empty or not\n  if (arr.length === 0) {\n    return true;\n  }\n\n  // If all elements in the array are sorted in non-descending order, return true\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] < arr[i - 1]) {\n      return false;\n    }\n  }\n  return true;\n}"}
{"task_id": "typescript/50", "language": "typescript", "completion": "const exchange = (lst1: number[], lst2: number[]): string => {\n  let evenCount = lst1.filter(num => num % 2 === 0).length;\n  let oddCount = lst2.filter(num => num % 2 !== 0).length;\n\n  if (evenCount > lst1.length || oddCount > lst2.length) {\n    return \"NO\";\n  }\n\n  for (let i = 0; i < evenCount; i++) {\n    let evenIndex = lst1.findIndex(num => num % 2 === 0);\n    let oddIndex = lst2.findIndex(num => num % 2 !== 0);\n\n    if (evenIndex !== -1 && oddIndex !== -1) {\n      [lst1[evenIndex], lst2[oddIndex]] = [lst2[oddIndex], lst1[evenIndex]];\n    } else {\n      break;\n    }\n  }\n\n  return lst1.every(num => num % 2 === 0) ? \"YES\" : \"NO\";\n};"}
{"task_id": "typescript/51", "language": "typescript", "completion": "function reverse_delete(s: string, c: string): [string, boolean] {\n  // Create an object to store the characters in s and their count\n  const charCount = {};\n  for (let i = 0; i < s.length; i++) {\n    if (!charCount[s[i]]) {\n      charCount[s[i]] = 1;\n    } else {\n      charCount[s[i]]++;\n    }\n  }\n\n  // Remove characters from c in the count object, and update s accordingly\n  for (let j = 0; j < c.length; j++) {\n    if (charCount[c[j]]) {\n      const count = charCount[c[j]];\n      charCount[c[j]] = count - 1;\n      if (count === 1) {\n        delete charCount[c[j]];\n      }\n      s = s.split(c[j]).join('');\n    }\n  }\n\n  // Reverse the resulting string and compare it with the original for palindrome check\n  const reversedS = s.split('').reverse().join('');\n  return [reversedS, s === reversedS];\n}"}
{"task_id": "typescript/52", "language": "typescript", "completion": "const max_fill = function (grid: Array<Array<number>>, capacity: number) : number {\n  let totalSteps = 0;\n\n  // Iterate through each row in the grid\n  for (let i = 0; i < grid.length; i++) {\n    const maxWaterInRow = Math.max(...grid[i]); // Find the maximum water volume in this row\n\n    if (maxWaterInRow <= capacity) {\n      totalSteps += Math.floor(maxWaterInRow / capacity); // If it's less than or equal to the bucket capacity, increment the counter by the quotient (number of times the bucket needs to be filled for this tank)\n    } else {\n      const numFullBuckets = Math.ceil(maxWaterInRow / capacity); // Else, find the smallest multiple of the capacity greater than or equal to the maximum water volume in this row\n      totalSteps += numFullBuckets; // Add the number of full buckets needed for this row to the counter variable\n    }\n  }\n\n  return totalSteps; // Return the final result, i.e., the minimum number of times the bucket needs to be dipped into the tanks to empty them\n}"}
{"task_id": "typescript/53", "language": "typescript", "completion": "function isConsonant(c: string): boolean {\n  const vowels = ['a', 'e', 'i', 'o', 'u'];\n  return !vowels.includes(c.toLowerCase()) && (!!c.match(/[aeiou]/)); // Check if the character is not a vowel or starts with a vowel (to handle cases like \"h2o\")\n}\n\nfunction hasExactNConsons(str: string, n: number): boolean {\n  const consonantCount = str.length - str.split(/[aeiou]/gi).filter(Boolean).length; // Count the number of consonants in a string (ignoring case)\n  return consonantCount === n;\n}\n\nfunction select_words(s: string, n: number): Array<string> {\n  const words = s.split(' ');\n  return words.filter((word) => hasExactNConsons(word, n));\n}"}
{"task_id": "typescript/54", "language": "typescript", "completion": "const quickSelect = (arr: number[], k: number): number[] => {\n  let low = 0;\n  let high = arr.length - 1;\n\n  while (low <= high) {\n    const pivotIndex = partition(arr, low, high);\n\n    if (pivotIndex === k - 1) return arr.slice(0, k);\n    else if (pivotIndex > k - 1) high = pivotIndex - 1;\n    else low = pivotIndex + 1;\n  }\n};\n\nconst partition = (arr: number[], low: number, high: number): number => {\n  const pivot = arr[high];\n  let i = low - 1;\n\n  for (let j = low; j < high; j++) {\n    if (arr[j] <= pivot) {\n      i++;\n      [arr[i], arr[j]] = [arr[j], arr[i]];\n    }\n  }\n  [arr[i + 1], arr[high]] = [arr[high], arr[i + 1]];\n  return i + 1;\n};\n\nconst maximum = (arr: number[], k: number): number[] => {\n  const sortedArray = quickSelect(arr, k);\n  return sortedArray.slice(0, k);\n};"}
{"task_id": "typescript/55", "language": "typescript", "completion": "function add_elements(arr: number[], k: number): number {\n    return arr\n        .slice(0, k) // take only the first k elements\n        .filter((num) => String(num).length <= 2) // filter out numbers with more than two digits\n        .reduce((acc, num) => acc + num); // reduce the filtered array to a single sum\n}"}
{"task_id": "typescript/56", "language": "typescript", "completion": "const intersection = function (interval1: number[], interval2: number[]) : string {\n  const [start1, end1] = interval1;\n  const [start2, end2] = interval2;\n\n  // Find the intersection of the two intervals\n  let startIntersection = Math.max(start1, start2);\n  let endIntersection = Math.min(end1, end2);\n\n  if (startIntersection > endIntersection) {\n    return \"NO\"; // The intervals do not intersect\n  }\n\n  // Check if the intersection is a prime number\n  const lengthIntersection = endIntersection - startIntersection + 1;\n\n  // Implement a method to check if a number is prime (e.g., using a Prime Number Theorem or Sieve of Eratosthenes algorithm)\n  function isPrime(number: number): boolean {\n    // ...\n  }\n\n  return isPrime(lengthIntersection) ? \"YES\" : \"NO\";\n};"}
{"task_id": "typescript/57", "language": "typescript", "completion": "const tri = (n: number): number[] => {\n    const triboSequence: number[] = [0, 0, 1]; // initialize array with first three numbers of Tribonacci sequence\n\n    for (let i = 3; i <= n + 1; i++) {\n        if (i % 2 === 0) {\n            triboSequence[i] = 1 + triboSequence[i / 2];\n        } else {\n            let sum = triboSequence[i - 1] + triboSequence[i - 2] + triboSequence[i + 1];\n            triboSequence[i] = sum;\n        }\n    }\n    return triboSequence; // return the requested sequence\n};"}
{"task_id": "typescript/58", "language": "typescript", "completion": "function digits(n: number): number {\n  if (n <= 0) return 0;\n  const strNum = n.toString();\n  let product = 1;\n\n  for (let i = 0; i < strNum.length; i++) {\n    const digit = parseInt(strNum[i], 10);\n    if (digit % 2 !== 0) product *= digit;\n  }\n\n  return product;\n}"}
{"task_id": "typescript/59", "language": "typescript", "completion": "function is_nested(string0: string): boolean {\n    // Match any sequence of opening and closing square brackets, as long as there are an equal number of both.\n    const regex = /(\\[.*?\\])/g;\n\n    // Find a match for the given regular expression in the input string.\n    let match = regex.exec(string0);\n\n    // If no match is found, return false as there are no nested brackets.\n    if (!match) {\n        return false;\n    }\n\n    // Iterate over each matched substring (which should always be a pair of nested brackets).\n    for (let i = 0; i < match.length; i++) {\n        const innerString = string0.slice(match[i].index, match[i].index + match[i].length);\n\n        // Check if the inner substring also contains nested brackets.\n        if (is_nested(innerString)) {\n            return true; // If it does, we have found a nested sequence and can return early.\n        }\n    }\n\n    // If no inner sequences contain nested brackets, return false.\n    return false;\n}"}
{"task_id": "typescript/60", "language": "typescript", "completion": "import * as math from 'mathjs';\n\n/**\n * This function calculates the sum of the squared, ceilinged numbers in an array\n *\n * @param {Array<number>} lst - The list of numbers to be processed\n * @returns {number} The sum of the squared, ceilinged numbers\n */\nconst sum_squares = function (lst: Array<number>) : number  {\n    const roundedNumbers = lst.map(num => Math.ceil(num)); // Round each element to the nearest integer using Math.ceil\n    const squaredNumbers = roundedNumbers.map(num => math.pow(num, 2)); // Square each rounded number using mathjs's pow function\n    return math.sum(squaredNumbers); // Sum up all the squared numbers using mathjs's sum function\n}"}
{"task_id": "typescript/61", "language": "typescript", "completion": "const check_if_last_char_is_a_letter = (txt: string): boolean => {\n  const lastCharIndex = txt.length - 1;\n  const isLastCharALetter = txt[lastCharIndex].match(/[a-zA-Z]/); // Check if the last character is an alphabetical character\n  const isLastCharInWord = /\\s+$/.test(txt.slice(0, lastCharIndex)); // Check if the last character is part of a word (by checking if there's a trailing whitespace before the character)\n\n  return isLastCharALetter && !isLastCharInWord;\n};"}
{"task_id": "typescript/62", "language": "typescript", "completion": "const can_arrange = (arr: number[]): number => {\n    let currentIndex = -1;\n\n    for (let i = 0; i < arr.length; i++) {\n        if (i > 0 && arr[i] <= arr[i - 1]) {\n            currentIndex = i;\n            break;\n        }\n    }\n\n    return currentIndex === -1 ? -1 : currentIndex;\n};"}
{"task_id": "typescript/63", "language": "typescript", "completion": "function largest_smallest_integers(lst: number[]): [number | null, number | null] {\n  let negativeNumbers = lst.filter(num => num < 0).sort((a, b) => a - b)[0];\n  let positiveNumbers = lst.filter(num => num > 0).sort((a, b) => a - b)[0];\n\n  return [negativeNumbers < 0 ? null : negativeNumbers, positiveNumbers > 0 ? positiveNumbers : null];\n}"}
{"task_id": "typescript/64", "language": "typescript", "completion": "function brazilianFactorial(n: number): number {\n    if (n <= 1) return 1;\n    else return n * brazilianFactorial(n - 1);\n}\n\n// Example usage:\nconsole.log(brazilianFactorial(4)); // Outputs: 288"}
{"task_id": "typescript/65", "language": "typescript", "completion": "function isPrime(n: number): boolean {\n  if (n < 2) return false;\n  for (let i = 2; i * i <= n; i++) {\n    if (n % i === 0) return false;\n  }\n  return true;\n}\n\nfunction wordsInSentence(sentence: string): string {\n  const words = sentence.split(' ');\n  const resultWords = [];\n\n  for (const word of words) {\n    if (isPrime(word.length)) {\n      resultWords.push(word);\n    }\n  }\n\n  return resultWords.join(' ');\n}"}
{"task_id": "typescript/66", "language": "typescript", "completion": "const GCD = (a: number, b: number) => {\n  if (b === 0) return a;\n  return GCD(b, a % b);\n}\n\nconst simplify = (x: string, n: string): boolean => {\n  const [numX, denomX] = x.split('/').map(Number);\n  const [numN, denomN] = n.split('/').map(Number);\n\n  // Find the Greatest Common Divisor (GCD) of both denominators\n  const gcd = GCD(denomX, denomN);\n\n  // Multiply the numerator and denominator by GCD to simplify the fractions\n  return numX * (denomN / gcd) === Math.floor(numX * (denomN / gcd)) ||\n    numN * (denomX / gcd) === Math.floor(numN * (denomX / gcd));\n}"}
{"task_id": "typescript/67", "language": "typescript", "completion": "const order_by_points = (nums: number[]): number[] => {\n  const digitSumComparator = (a: number, b: number) => {\n    const sumA = numToDigitSum(a);\n    const sumB = numToDigitSum(b);\n\n    if (sumA === sumB) return a - b; // If the digit sums are equal, compare the numbers by their index in the original array.\n    return sumA - sumB; // Compare the digit sums.\n  };\n\n  const numToDigitSum = (num: number): number => {\n    let sum = 0;\n    const stringNum = Math.abs(num).toString();\n\n    for (let i = 0; i < stringNum.length; i++) {\n      sum += parseInt(stringNum[i]);\n    }\n\n    return sum;\n  };\n\n  nums.sort(digitSumComparator);\n  return nums;\n};"}
{"task_id": "typescript/68", "language": "typescript", "completion": "function specialFilter(nums: number[]): number {\n  let count = 0;\n\n  for (let i = 0; i < nums.length; i++) {\n    const num = nums[i];\n\n    // Check if the number is greater than 10, and if its first and last digits are odd\n    if (num > 10 && (num % 10 === 3 || num % 10 === 7)) {\n      count++;\n    }\n  }\n\n  return count;\n}"}
{"task_id": "typescript/69", "language": "typescript", "completion": "const get_max_triples = function (n: number): number {\n    let triplesCount = 0;\n    let sumOfThree = 0;\n    const a = new Array(n);\n\n    for (let i = 0; i < n; i++) {\n        a[i] = i * i - i + 1;\n        for (let j = i + 1; j < n; j++) {\n            let k = n - 1 - i - j;\n            if (k >= 0) {\n                sumOfThree = a[i] + a[j] + a[k];\n                if (sumOfThree % 3 === 0) {\n                    triplesCount++;\n                }\n            }\n        }\n    }\n\n    return triplesCount;\n};"}
{"task_id": "typescript/70", "language": "typescript", "completion": "const PLANETS_ORDER = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"];\n\ninterface PlanetOrbit {\n  name: string;\n  distanceFromSun: number;\n}\n\nconst PLANET_DISTANCES_FROM_SUN = [3.9, 6.2, 9.3, 1.524, 5.2, 9.58, 19.2, 30.1];\n\nfunction bf(planet1: string, planet2: string): Array<string> {\n  if (!PLANETS_ORDER.includes(planet1) || !PLANETS_ORDER.includes(planet2)) {\n    return []; // Return an empty array if planet names are invalid\n  }\n\n  const indexOfPlanet1 = PLANETS_ORDER.indexOf(planet1);\n  const indexOfPlanet2 = PLANETS_ORDER.indexOf(planet2);\n\n  let result: PlanetOrbit[] = [];\n\n  for (let i = Math.min(indexOfPlanet1, indexOfPlanet2) + 1; i <= Math.max(indexOfPlanet1, indexOfPlanet2); i++) {\n    const planet = PLANETS_ORDER[i];\n    if (result.length > 0 && result[result.length - 1].distanceFromSun >= PLANET_DISTANCES_FROM_SUN[indexOfPlanet2]) {\n      break; // Stop searching once we've found a planet with a greater distance from the sun than the second input planet\n    }\n\n    result.push({ name: planet, distanceFromSun: PLANET_DISTANCES_FROM_SUN[PLANETS_ORDER.indexOf(planet)] });\n  }\n\n  return result.sort((a, b) => a.distanceFromSun - b.distanceFromSun); // Sort the results by their distance from the sun\n}"}
{"task_id": "typescript/71", "language": "typescript", "completion": "const x_or_y = function (n: number, x: number, y: number) : number {\n  if (isPrime(n)) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nfunction isPrime(num: number): boolean {\n  for (let i = 2, sqrt = Math.sqrt(num); i <= sqrt; i++) {\n    if (num % i === 0) {\n      return false;\n    }\n  }\n  return num > 1;\n}"}
{"task_id": "typescript/72", "language": "typescript", "completion": "function double_the_difference(lst: number[]): number {\n  // Filter out negative, non-integer or even numbers\n  const filteredList = lst.filter((num) => {\n    return Number.isInteger(num) && num > 0 && num % 2 !== 0;\n  });\n\n  let sumOfSquares: number = 0;\n\n  // Calculate the sum of squares for each filtered number in the list\n  filteredList.forEach((num) => {\n    sumOfSquares += Math.pow(num, 2);\n  });\n\n  return sumOfSquares * 2;\n}"}
{"task_id": "typescript/73", "language": "typescript", "completion": "const Strongest_Extension = function (class_name: string, extensions: Array<string>) : string {\n  let strongestExtensionIndex: number | undefined;\n  let maxStrength: number = -Infinity;\n\n  for (let i = 0; i < extensions.length; i++) {\n    const extension = extensions[i];\n    let capCount = 0;\n    let smallCount = 0;\n\n    // Iterate over the characters in the extension and count capital letters and small letters\n    for (let j = 0; j < extension.length; j++) {\n      const char = extension[j];\n      if (char >= 'A' && char <= 'Z') {\n        capCount++;\n      } else if (char >= 'a' && char <= 'z') {\n        smallCount++;\n      }\n    }\n\n    // Compute the strength of this extension and compare it with the maximum found so far\n    const strength = capCount - smallCount;\n    if (strength > maxStrength) {\n      strongestExtensionIndex = i;\n      maxStrength = strength;\n    }\n  }\n\n  // If we have found a strongest extension, return the fully qualified name. Otherwise, return an empty string.\n  if (strongestExtensionIndex !== undefined) {\n    const strongestExtension = extensions[strongestExtensionIndex];\n    return `${class_name}.${strongestExtension}`;\n  } else {\n    return '';\n  }\n};"}
{"task_id": "typescript/74", "language": "typescript", "completion": "function cycpattern_check(a: string, b: string): boolean {\n  const length = b.length;\n  let shifted: string[] = [];\n\n  // Generate rotations of b.\n  for (let i = 0; i < length; ++i) {\n    shifted[i] = b.substring(i % length) + b.substring(0, i % length);\n  }\n\n  // Check if any rotation of b is a substring of a.\n  for (const rotation of shifted) {\n    if (a.indexOf(rotation) !== -1) {\n      return true;\n    }\n  }\n\n  // If no match found, return false.\n  return false;\n}"}
{"task_id": "typescript/75", "language": "typescript", "completion": "const int_to_mini_roman = function (number: number): string {\n  const numerals = [\"I\", \"V\", \"X\", \"L\", \"C\", \"D\", \"M\"];\n  const values = [1, 5, 10, 50, 100, 500, 1000];\n  let output = \"\";\n\n  for (let i = 0; i < numerals.length; i++) {\n    while (number >= values[i]) {\n      number -= values[i];\n      output += numerals[i];\n    }\n  }\n\n  return output;\n};"}
{"task_id": "typescript/76", "language": "typescript", "completion": "const right_angle_triangle = function (a: number, b: number, c: number): boolean {\n  const hypotenuseSquared = Math.pow(c, 2);\n  const otherSideSquaresSum = Math.pow(a, 2) + Math.pow(b, 2);\n\n  return hypotenuseSquared === otherSideSquaresSum;\n};"}
{"task_id": "typescript/77", "language": "typescript", "completion": "const solve = function (s: string): string {\n  let result = '';\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] >= 'a' && s[i] <= 'z') {\n      result += String.fromCharCode(s[i].charCodeAt(0) - 32);\n    } else if (s[i] >= 'A' && s[i] <= 'Z') {\n      result += String.fromCharCode(s[i].charCodeAt(0) + 32);\n    } else {\n      result += s[i];\n    }\n  }\n  return result;\n};"}
{"task_id": "typescript/78", "language": "typescript", "completion": "import crypto from 'crypto';\n\nconst string_to_md5 = (text: string): string => {\n  if (!text) return null;\n\n  const hash = crypto.createHash('md5');\n  hash.update(text);\n  return hash.digest('hex');\n}"}
{"task_id": "typescript/79", "language": "typescript", "completion": "const generate_integers = (a: number, b: number): Array<number> => {\n  if (a > b) {\n    const temp = a;\n    a = b;\n    b = temp;\n  }\n\n  const result: Array<number> = [];\n\n  for (let i = a; i <= b; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    }\n  }\n\n  return result;\n};"}
