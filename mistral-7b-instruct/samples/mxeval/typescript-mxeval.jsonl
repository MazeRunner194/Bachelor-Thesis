{"task_id": "HumanEval_typescript/0", "language": "typescript", "completion": "function has_close_elements(numbers: number[], threshold: number): boolean {\n  for (let i = 0; i < numbers.length - 1; i++) {\n    for (let j = i + 1; j < numbers.length; j++) {\n      if (Math.abs(numbers[i] - numbers[j]) <= threshold) {\n        return true;\n      }\n    }\n  }\n  return false;\n}"}
{"task_id": "HumanEval_typescript/1", "language": "typescript", "completion": "function separate_paren_groups(paren_string: string): Array<string> {\n  const regex = /(?:\\(([^()]+)\\)|([^()]))/g;\n  let match: RegExpExecArray | null;\n  const result: Array<string> = [];\n\n  while ((match = regex.exec(paren_string))) {\n    if (match[1]) {\n      // If there's a subgroup, recursively process it\n      result.push(separate_paren_groups(match[1]));\n    } else {\n      // Else, push the chunk as is\n      result.push(match[2]);\n    }\n  }\n\n  return result;\n}"}
{"task_id": "HumanEval_typescript/2", "language": "typescript", "completion": "function truncate_number(number0: number): number {\n  return Math.trunc(number0) - Math.trunc(number0);\n}"}
{"task_id": "HumanEval_typescript/3", "language": "typescript", "completion": "const below_zero = (operations: number[]): boolean => {\n  let balance = 0;\n  return operations.reduce((accumulator, operation) => {\n    const newBalance = balance + operation;\n    return newBalance < 0 ? true : accumulator;\n  }, false);\n};"}
{"task_id": "HumanEval_typescript/4", "language": "typescript", "completion": "const mean_absolute_deviation = (numbers: Array<number>): number => {\n  if (!numbers.length) return 0;\n\n  const avg = numbers.reduce((sum, num) => sum + num, 0) / numbers.length;\n\n  return numbers.map(n => Math.abs(n - avg)).reduce((sum, n) => sum + n, 0) / numbers.length;\n};"}
{"task_id": "HumanEval_typescript/5", "language": "typescript", "completion": "const intersperse = (numbers: number[], delimeter: number): number[] => {\n  return numbers.flatMap((_, index) => [numbers[index], index < numbers.length - 1 ? delimeter : undefined]);\n};"}
{"task_id": "HumanEval_typescript/6", "language": "typescript", "completion": "const parse_nested_parens = (paren_string: string): number[] => {\n  const parseGroup = (parenthesis: string): [number, string] => {\n    let count = 1;\n    let currentParenthesis = parenthesis[0];\n\n    for (let i = 1; i < parenthesis.length; i++) {\n      if (parenthesis[i] === '(') count++;\n      else if (parenthesis[i] === ')') {\n        if (count > 1) count--;\n        else return [count, parenthesis.slice(0, i)];\n      }\n    }\n\n    // If the parentheses are not closed properly, throw an error\n    if (count !== 1) throw new Error('Invalid parentheses');\n\n    return [count, currentParenthesis];\n  };\n\n  const parse = (parentheses: string): number[] => {\n    let result: number[] = [];\n\n    let currentParenthesis = '';\n    let i = 0;\n\n    while (i < parentheses.length) {\n      if (parentheses[i] === ' ') {\n        const [depth, group] = parseGroup(currentParenthesis);\n        result.push(depth);\n        currentParenthesis = '';\n        i++;\n      } else {\n        currentParenthesis += parentheses[i];\n        i++;\n      }\n    }\n\n    if (currentParenthesis !== '') {\n      const [depth, _] = parseGroup(currentParenthesis);\n      result.push(depth);\n    }\n\n    return result;\n  };\n\n  return parse(paren_string);\n};"}
{"task_id": "HumanEval_typescript/7", "language": "typescript", "completion": "const filter_by_substring = (strings: string[], substring: string): string[] => {\n  return strings.filter(str => str.includes(substring));\n}"}
{"task_id": "HumanEval_typescript/8", "language": "typescript", "completion": "type SumProductTuple = [number, number];\n\nconst sum_product = (numbers: number[]): SumProductTuple => {\n    let sum = 0;\n    let product = 1;\n\n    for(let i = 0; i < numbers.length; i++) {\n        sum += numbers[i];\n        product *= numbers[i];\n    }\n\n    return [sum, product];\n};"}
{"task_id": "HumanEval_typescript/9", "language": "typescript", "completion": "const rolling_max = (numbers: Array<number>): Array<number> => {\n    let maxSeq: number[] = [];\n    let maxValue: number;\n\n    for (let i = 0; i < numbers.length; i++) {\n        const currentNumber = numbers[i];\n\n        if (!maxSeq.length) {\n            maxValue = currentNumber;\n            maxSeq.push(currentNumber);\n            continue;\n        }\n\n        if (currentNumber > maxValue) {\n            maxSeq.push(currentNumber);\n            maxValue = currentNumber;\n        }\n\n        maxSeq.shift(); // Remove the first element from the sequence\n    }\n\n    return maxSeq;\n};"}
{"task_id": "HumanEval_typescript/10", "language": "typescript", "completion": "const make_palindrome = function (string0: string): string {\n  // Helper function to check if a substring is a palindrome\n  const isPalindrome = (substring: string): boolean => {\n    for (let i = 0, j = substring.length - 1; i < j; i++, j--) {\n      if (substring[i] !== substring[j]) return false;\n    }\n    return true;\n  };\n\n  // Initialize start and end pointers for prefix and suffix respectively\n  let start = 0,\n    end = string0.length - 1;\n\n  // Iterate from both ends until we find a palindrome or the end of the string is reached\n  while (start < end) {\n    if (string0[start] !== string0[end]) break;\n\n    start++;\n    end--;\n  }\n\n  // If no palindromic substring was found, return an empty string\n  if (start === string0.length || end === -1) return '';\n\n  const palindromeLength = end - start + 1;\n  let prefixLength = start,\n    suffixLength = end - start + 1;\n\n  // If the length of the suffix is greater than that of the prefix, swap them.\n  if (suffixLength > prefixLength) {\n    [prefixLength, suffixLength] = [suffixLength, prefixLength];\n  }\n\n  // Reverse the suffix and concatenate it to the original string\n  const reversedSuffix = Array.from(string0.slice(end + 1, start - prefixLength))\n    .reverse()\n    .join('');\n  return string0.slice(0, start) + reversedSuffix + string0.slice(start);\n};"}
{"task_id": "HumanEval_typescript/11", "language": "typescript", "completion": "const string_xor = (a: string, b: string): string => {\n    let result = '';\n    for (let i = 0; i < Math.max(a.length, b.length); i++) {\n        const aIndex = i < a.length ? i : a.length - 1;\n        const bIndex = i < b.length ? i : b.length - 1;\n\n        result += String.fromCharCode(a[aIndex].charCodeAt(0) ^ b[bIndex].charCodeAt(0));\n    }\n\n    return result;\n};"}
{"task_id": "HumanEval_typescript/12", "language": "typescript", "completion": "function longest(strings: string[]): string | null {\n  if (strings.length === 0) {\n    return null; // or throw an error, your choice\n  }\n\n  let maxLength = strings[0].length;\n  let longestString: string | undefined;\n\n  for (const str of strings) {\n    if (str.length > maxLength) {\n      maxLength = str.length;\n      longestString = str;\n    }\n  }\n\n  return longestString!;\n}"}
{"task_id": "HumanEval_typescript/13", "language": "typescript", "completion": "function greatestCommonDivisor(a: number, b: number): number {\n    while (b !== 0) {\n        const temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return Math.abs(a);\n}"}
{"task_id": "HumanEval_typescript/14", "language": "typescript", "completion": "const all_prefixes = (string0: string): Array<string> => {\n  let result: Array<string> = [];\n  for (let i = 0; i <= string0.length; i++) {\n    for (let j = string0.length - i; j >= 1; j--) {\n      result.push(string0.slice(0, j));\n    }\n  }\n  return result;\n}"}
{"task_id": "HumanEval_typescript/15", "language": "typescript", "completion": "function string_sequence(n: number): string {\n  let result = '';\n  for (let i = 0; i <= n; i++) {\n    if (result !== '') {\n      result += ' ';\n    }\n    result += String(i);\n  }\n  return result;\n}"}
{"task_id": "HumanEval_typescript/16", "language": "typescript", "completion": "const count_distinct_characters = function (string0: string) : number {\n    const charSet: Set<string> = new Set();\n    for (let char of string0.toLowerCase()) {\n        charSet.add(char);\n    }\n    return charSet.size;\n}"}
{"task_id": "HumanEval_typescript/17", "language": "typescript", "completion": "const parse_music = (music_string: string): number[] => {\n  const notePattern = /(o|o\\\\||\\.)(\\|)/g; // Matches whole notes, half notes with or without vertical bar, and quarter notes with a vertical bar\n\n  let match: RegExpExecArray | null;\n  const notes = [] as number[];\n\n  while (match = notePattern.exec(music_string)) {\n    if (match[1] === 'o') { // Whole note\n      notes.push(4);\n    } else if (match[1] === 'o\\\\' || match[1] === '.') { // Half note\n      notes.push(2);\n    } else { // Quarter note\n      notes.push(1);\n    }\n  }\n\n  return notes;\n};"}
{"task_id": "HumanEval_typescript/18", "language": "typescript", "completion": "function how_many_times(string0: string, substring: string): number {\n  let count = 0;\n  let index = string0.indexOf(substring);\n\n  // If the index is not -1 (which means the substring was found), we increment the counter and find the next occurrence from the index + length of substring.\n  while (index !== -1) {\n    count++;\n    index = string0.indexOf(substring, index + substring.length);\n  }\n\n  return count;\n}"}
{"task_id": "HumanEval_typescript/19", "language": "typescript", "completion": "type NumberType = 'zero' | 'one' | 'two' | 'three' | 'four' | 'five' | 'six' | 'seven' | 'eight' | 'nine';\n\nfunction sort_numbers(numbers: string): string {\n  // Split the input string into an array of numbers\n  const numberArray: NumberType[] = numbers.split(' ').map((number) => number as NumberType);\n\n  // Sort the array in ascending order using the JavaScript sort function\n  numberArray.sort();\n\n  // Join the sorted array back into a string and return it\n  return numberArray.join(' ');\n}"}
{"task_id": "HumanEval_typescript/20", "language": "typescript", "completion": "function findClosestElements(numbers: number[]): [number, number] {\n    if (numbers.length < 2) throw new Error(\"Array must have at least two elements\");\n\n    let closestNumbers: [number, number] = [numbers[0], numbers[1]];\n    let minDistance = Math.abs(closestNumbers[0] - closestNumbers[1]);\n\n    for (let i = 2; i < numbers.length; i++) {\n        const currentNumber = numbers[i];\n        let newDistance: number;\n\n        // Calculate the distance between the current number and each of the two closest numbers found so far\n        for (let j = 0; j < 2; j++) {\n            newDistance = Math.abs(currentNumber - closestNumbers[j]);\n\n            if (newDistance < minDistance) {\n                // If the distance is less than the current minimum distance, update the closest numbers and minimum distance\n                if (j === 0) {\n                    closestNumbers[1] = currentNumber;\n                } else {\n                    closestNumbers[0] = currentNumber;\n                }\n                minDistance = newDistance;\n            }\n        }\n    }\n\n    return closestNumbers;\n}"}
{"task_id": "HumanEval_typescript/21", "language": "typescript", "completion": "const rescaleToUnit = (numbers: number[]): number[] => {\n  const minValue = Math.min(...numbers);\n  const maxValue = Math.max(...numbers);\n  return numbers.map((n) => (n - minValue) / (maxValue - minValue));\n};"}
{"task_id": "HumanEval_typescript/22", "language": "typescript", "completion": "const filter_integers = (values: any[]): number[] => {\n  return values.filter(item => typeof item === 'number' && Number.isInteger(item));\n};"}
{"task_id": "HumanEval_typescript/23", "language": "typescript", "completion": "const strlen = (string0: string): number => {\n  return string0.length;\n};"}
{"task_id": "HumanEval_typescript/24", "language": "typescript", "completion": "const largest_divisor = function (n: number): number {\n  for(let i = 2; i < n; i++) {\n    if(n % i === 0) {\n      return i;\n    }\n  }\n\n  // If no divisors were found, the largest divisor is '1' (itself)\n  return 1;\n};"}
{"task_id": "HumanEval_typescript/25", "language": "typescript", "completion": "import * as math from 'mathjs';\n\n/**\n * Returns true if n is a prime number\n */\nconst isPrime = (n: number): boolean => {\n  for (let i = 2; i <= Math.sqrt(n); i++) {\n    if (n % i === 0) return false;\n  }\n  return n > 1;\n}\n\n/**\n * Returns array of prime factors of the given number n\n */\nconst findPrimeFactors = (n: number): Array<number> => {\n  const factors: Array<number> = [];\n  for (let i = 2; i <= n; i++) {\n    if (isPrime(i)) {\n      let count = 0;\n      while (n % i === 0) {\n        count++;\n        n /= i;\n      }\n      if (count > 0) factors.push(...Array(count).fill(i));\n    }\n  }\n  return factors;\n}\n\n/**\n * You're an expert TypeScript programmer\n * Return list of prime factors of given integer in the order from smallest to largest.\n * Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n * Input number should be equal to the product of all factors\n */\nconst factorize = (n: number): Array<number> => {\n  if (!math.number(n).eq(math.add(...findPrimeFactors(n)))) throw new Error(\"Input number is not a perfect square\");\n  return findPrimeFactors(n);\n}"}
{"task_id": "HumanEval_typescript/26", "language": "typescript", "completion": "const remove_duplicates = function (numbers: number[]): number[] {\n  return [...new Set(numbers)].sort((a, b) => a - b);\n}"}
{"task_id": "HumanEval_typescript/27", "language": "typescript", "completion": "const flip_case = (string0: string) : string => {\n  let result = '';\n  for (let char of string0) {\n    if (char === char.toUpperCase()) {\n      result += char.toLowerCase();\n    } else if (char === char.toLowerCase()) {\n      result += char.toUpperCase();\n    } else {\n      result += char; // If the character is neither uppercase nor lowercase, keep it as is\n    }\n  }\n  return result;\n};"}
{"task_id": "HumanEval_typescript/28", "language": "typescript", "completion": "const concatenate = (strings: string[]): string => strings.join('');"}
{"task_id": "HumanEval_typescript/29", "language": "typescript", "completion": "const filter_by_prefix = function (strings: Array<string>, prefix: string): Array<string> {\n  return strings.filter(str => str.startsWith(prefix));\n};"}
{"task_id": "HumanEval_typescript/30", "language": "typescript", "completion": "const get_positive = (l: number[]): number[] => {\n  return l.filter(num => num > 0);\n};"}
{"task_id": "HumanEval_typescript/31", "language": "typescript", "completion": "function isPrime(n: number): boolean {\n    if (n <= 1) return false;\n    if (n === 2) return true;\n    // If n is even and greater than 2, it's not prime\n    if (n % 2 === 0) return false;\n\n    let rootSquare = Math.sqrt(n);\n    for (let i = 3; i <= rootSquare; i += 2) {\n        if (n % i === 0) return false;\n    }\n\n    // If no factors found, n is prime\n    return true;\n}"}
{"task_id": "HumanEval_typescript/33", "language": "typescript", "completion": "const sort_third = (l: number[]): number[] => {\n  const indicesToSort = l.map((_, i) => i).filter((i, idx) => idx % 3 === 0);\n  const sortedIndicesValues = indicesToSort.map(i => l[i]).sort();\n  return l.reduce((acc, curr, idx) => {\n    if (indicesToSort.includes(idx)) {\n      acc[idx] = sortedIndicesValues[indicesToSort.indexOf(idx)]\n    } else {\n      acc[idx] = curr;\n    }\n    return acc;\n  }, [] as number[]);\n}"}
{"task_id": "HumanEval_typescript/34", "language": "typescript", "completion": "const unique = function (l: Array<number>): Array<number> {\n    return [...new Set(l)].sort((a, b) => a - b);\n};"}
{"task_id": "HumanEval_typescript/35", "language": "typescript", "completion": "const max_element = (l: number[]): number => {\n  let max = l[0];\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i];\n    }\n  }\n  return max;\n}"}
{"task_id": "HumanEval_typescript/36", "language": "typescript", "completion": "function fizzBuzz(n: number): number {\n    let count = 0;\n    for (let i = 1; i < n; i++) {\n        if ((i % 11 === 0 || i % 13 === 0) && String(i).includes('7')) {\n            count++;\n        }\n    }\n    return count;\n}"}
{"task_id": "HumanEval_typescript/37", "language": "typescript", "completion": "function sort_even(l: number[]): number[] {\n  const result: number[] = [];\n  let i = 0;\n\n  while (i < l.length) {\n    if (i % 2 === 0) {\n      result.push(...l.slice(i, i + 2).sort((a, b) => a - b));\n      i += 2;\n    } else {\n      result.push(l[i]);\n      i++;\n    }\n  }\n\n  return result;\n}"}
{"task_id": "HumanEval_typescript/39", "language": "typescript", "completion": "import * as math from 'mathjs';\n\nconst isPrime = (num: number): boolean => {\n  // A number greater than 1 that can only be divided by 1 and itself is a prime number.\n  if (num < 2) return false;\n\n  for (let i = 2; i <= Math.sqrt(num); i++) {\n    if (num % i === 0) return false;\n  }\n\n  return true;\n};\n\nconst fibonacci = (n: number): number => {\n  // Base case: Fibonacci sequence starts with 0 and 1.\n  if (n <= 2) return n - 1;\n\n  let a = 0;\n  let b = 1;\n\n  for (let i = 3; i <= n; i++) {\n    // Fibonacci formula: next number is the sum of the previous two.\n    const c = math.add(a, b);\n    a = b;\n    b = c;\n  }\n\n  return b;\n};\n\nconst prime_fib = function (n: number): number {\n  let candidate: number;\n  let index: number = 1;\n\n  // Generate Fibonacci numbers and check if they are primes.\n  while (index < n) {\n    candidate = fibonacci(index);\n    if (isPrime(candidate)) return candidate;\n    index++;\n  }\n\n  throw new Error(`No prime Fibonacci number found within given range.`);\n};"}
{"task_id": "HumanEval_typescript/40", "language": "typescript", "completion": "function triplesSumToZero(arr: number[]): boolean {\n  const set = new Set();\n  for (const num of arr) {\n    const complement = -num;\n    if (set.has(complement)) {\n      const [a, b] = Array.from(set).sort((a, b) => a - b);\n      return arr.includes(a) && arr.includes(b) && arr.includes(complement);\n    } else {\n      set.add(num);\n    }\n  }\n  return false;\n}"}
{"task_id": "HumanEval_typescript/41", "language": "typescript", "completion": "const car_race_collision = (n: number) => {\n  // Calculate the time it takes for both groups to reach the midpoint\n  let t = 2 * n; // Initial assumption that there are no collisions, so they meet at twice the number of cars\n\n  while (true) {\n    // Create two arrays, one for cars moving left and one for cars moving right\n    const leftCars: Array<[number, number]> = [];\n    const rightCars: Array<[number, number]> = [];\n\n    // Populate the arrays with car objects\n    for (let i = 0; i < n; ++i) {\n      leftCars.push([i * t + Math.floor(t / 2), t]);\n      rightCars.unshift([-(i * t + Math.floor(t / 2)), t]);\n    }\n\n    // Sort the arrays by their x-coordinates, which represents position on the road\n    leftCars.sort((a, b) => a[0] - b[0]);\n    rightCars.sort((a, b) => a[0] - b[0]);\n\n    // Check for collisions by iterating through both arrays and comparing their positions\n    let collisionCount = 0;\n    for (let i = 1; i < leftCars.length; ++i) {\n      if (leftCars[i][0] <= rightCars[i - 1][0]) {\n        // Collision occurred, increment the counter\n        collisionCount++;\n      }\n    }\n\n    // If no new collisions were found in this iteration, it means all cars have passed each other\n    if (collisionCount === 0) break;\n\n    // Update time t for the next iteration by reducing it slightly to account for potential collisions\n    t -= 1;\n  }\n\n  return collisionCount;\n};"}
{"task_id": "HumanEval_typescript/42", "language": "typescript", "completion": "const incr_list = <T extends number[]>(l: T): T => {\n  return l.map((num) => num + 1);\n};"}
{"task_id": "HumanEval_typescript/43", "language": "typescript", "completion": "const pairs_sum_to_zero = function (l: Array<number>): boolean {\n  let seenNumbers: Record<number, number> = {};\n  for (let i = 0; i < l.length; ++i) {\n    const currentNumber = l[i];\n    if (seenNumbers[-currentNumber] !== undefined) { // found a pair!\n      return true;\n    }\n    seenNumbers[currentNumber] = i; // store the number and its index for next iteration\n  }\n  return false; // didn't find any pairs, so return false\n};"}
{"task_id": "HumanEval_typescript/44", "language": "typescript", "completion": "const changeBase = (x: number, base: number): string => {\n    const digits = \"0123456789ABCDEF\";\n    let result = \"\";\n\n    if (x === 0) return \"0\";\n\n    while (x !== 0) {\n        const remainder = x % base;\n        x = Math.floor(x / base);\n        result += digits[remainder];\n    }\n\n    return result.split(\"\").reverse().join(\"\");\n};"}
{"task_id": "HumanEval_typescript/45", "language": "typescript", "completion": "const triangle_area = function (base: number, height: number): number {\n    return (1 / 2) * base * height;\n}"}
{"task_id": "HumanEval_typescript/46", "language": "typescript", "completion": "function fib4(n: number): number {\n    let fibArr = [0, 0, 2, 0]; // Initialize with the first 4 Fib4 numbers\n\n    for (let i = 4; i <= n; i++) {\n        fibArr[i] = fibArr[i - 1] + fibArr[i - 2] + fibArr[i - 3] + fibArr[i - 4];\n    }\n\n    return fibArr[n];\n}"}
{"task_id": "HumanEval_typescript/47", "language": "typescript", "completion": "function median(l: number[]): number {\n  l = l.slice().sort((a, b) => a - b); // Sort the input array\n\n  const len = l.length;\n  let midIndex: number | undefined;\n\n  if (len % 2 === 0) {\n    midIndex = Math.floor(len / 2) * 2;\n  } else {\n    midIndex = Math.floor(len / 2);\n  }\n\n  return len % 2 === 0\n    ? (l[midIndex] + l[midIndex + 1]) / 2\n    : l[Math.floor(midIndex)];\n}"}
{"task_id": "HumanEval_typescript/48", "language": "typescript", "completion": "function is_palindrome(text: string): boolean {\n  let start = 0;\n  let end = text.length - 1;\n\n  while (start < end) {\n    if (text[start] !== text[end]) {\n      return false;\n    }\n\n    start++;\n    end--;\n  }\n\n  return true;\n}"}
{"task_id": "HumanEval_typescript/49", "language": "typescript", "completion": "const modp = function (n: bigint, p: number): number {\n  const bn = BigInt(n);\n  let result = BigInt(1);\n  let x = bn;\n\n  while (x !== BigInt(0)) {\n    if ((x & BigInt(1)) === BigInt(1)) {\n      result = (result * bn) % BigInt(p);\n    }\n    x >>= 1;\n    bn = (bn * bn) % p;\n  }\n\n  return Number(result % BigInt(p));\n};"}
{"task_id": "HumanEval_typescript/51", "language": "typescript", "completion": "function remove_vowels(text: string): string {\n    const vowels = 'aeiouAEIOU';\n    return text.split('').filter((char) => !vowels.includes(char)).join('');\n}"}
{"task_id": "HumanEval_typescript/52", "language": "typescript", "completion": "function below_threshold(l: number[], t: number): boolean {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] >= t) {\n      return false;\n    }\n  }\n  return true;\n}"}
{"task_id": "HumanEval_typescript/53", "language": "typescript", "completion": "const add = function (x: number, y: number): number {\n  return x + y;\n};"}
{"task_id": "HumanEval_typescript/54", "language": "typescript", "completion": "const same_chars = function (s0: string, s1: string) : boolean {\n  const set0 = new Set(s0);\n  const set1 = new Set(s1);\n\n  return set0.size === set1.size && [...set0].every((char) => set1.has(char));\n}"}
{"task_id": "HumanEval_typescript/55", "language": "typescript", "completion": "const fib = function (n: number): number {\n  if (n <= 1) return n;\n\n  return fib(n - 1) + fib(n - 2);\n};"}
{"task_id": "HumanEval_typescript/56", "language": "typescript", "completion": "type Bracket = \"(\" | \")\" | \"{\" | \"}\" | \"<\" | \">\" | \"[`]\";\n\nconst correct_bracketing = (brackets: string): boolean => {\n  const validBrackets: Record<Bracket, Bracket> = {\n    \"(\": \")\",\n    \")\": \"(\",\n    \"{\": \"}\",\n    \"}\": \"{\",\n    \"<\": \">\",\n    \">\": \"<\",\n    \"[`]\": \"\\\\]\",\n    \"\\\\]\": \"[`]\",\n  };\n\n  const stack: Bracket[] = [];\n  for (const bracket of brackets) {\n    if (validBrackets[bracket]) {\n      stack.push(bracket);\n    } else if (stack.length > 0 && validBrackets[stack[stack.length - 1]] === bracket) {\n      stack.pop();\n    } else {\n      return false;\n    }\n  }\n\n  return stack.length === 0;\n};"}
{"task_id": "HumanEval_typescript/57", "language": "typescript", "completion": "const monotonic = (l: number[]) : boolean => {\n    let isIncreasing = l[1] - l[0] >= 0;\n\n    for (let i = 1; i < l.length; i++) {\n        if ((isIncreasing && l[i] < l[i - 1]) || (!isIncreasing && l[i] > l[i - 1])) {\n            return false;\n        }\n    }\n\n    return true;\n};"}
{"task_id": "HumanEval_typescript/58", "language": "typescript", "completion": "function common(l1: number[], l2: number[]): number[] {\n  const setL1 = new Set(l1);\n  const setL2 = new Set(l2);\n  const resultSet = new Set<number>();\n\n  for (const num of l1) {\n    if (setL2.has(num)) {\n      resultSet.add(num);\n      setL2.delete(num);\n    }\n  }\n\n  return [...resultSet].sort((a, b) => a - b);\n}"}
{"task_id": "HumanEval_typescript/59", "language": "typescript", "completion": "const isPrime = (number: number): boolean => {\n    if (number < 2) return false; // numbers less than 2 are not primes\n\n    for(let i = 2; i <= Math.sqrt(number); i++) {\n        if(number % i === 0) return false; // if the number is divisible by any number up to its square root, it's not prime\n    }\n\n    return true; // if no factors were found, the number must be prime\n};\n\nconst gcd = (a: number, b: number): number => {\n    if (b === 0) return a;\n    else return gcd(b, a % b);\n};\n\nconst largest_prime_factor = function (n: number) : number  {\n    let largestFactor = 1;\n\n    for(let i = 2; i <= n / 2 + 1; i++) { // iterate up to half of n since if a factor exists, it must be smaller than half of n\n        const isCurrentFactorPrime = isPrime(i);\n        if (isCurrentFactorPrime) {\n            let currentFactor = i;\n            while(gcd(n, currentFactor) !== 1) { // check for factors\n                largestFactor = currentFactor;\n                currentFactor -= largestFactor;\n            }\n        }\n    }\n\n    return largestFactor;\n};"}
{"task_id": "HumanEval_typescript/60", "language": "typescript", "completion": "It seems like you have already written the TypeScript code for the `sum_to_n` function. This function takes an integer as an argument and returns the sum of all numbers from 1 up to (and including) the given number `n`. Here's a brief explanation of your code:\n\n- `function (n: number) : number` is how you define a function in TypeScript that takes one parameter of type `number` and returns a value of type `number`.\n- The loop inside the function uses the `for` statement to iterate over all numbers from 1 up to (and including) the provided `n`.\n- The body of the loop uses the `sum += currentNum` statement to incrementally add each number to the variable `sum`.\n- Finally, the function returns the value stored in the `sum` variable.\n\nThis implementation is concise and efficient, making use of TypeScript's type annotations and control structures. Good job! \ud83d\udc4d"}
{"task_id": "HumanEval_typescript/61", "language": "typescript", "completion": "const correct_bracketing = (brackets: string): boolean => {\n  let stack: string[] = [];\n\n  for (let char of brackets) {\n    if (char === '(') {\n      stack.push(char);\n    } else if (char === ')') {\n      if (stack.length > 0 && stack[stack.length - 1] === '(') {\n        stack.pop();\n      } else {\n        return false;\n      }\n    }\n  }\n\n  // Check if the stack is empty after iterating through all characters\n  return stack.length === 0;\n};"}
{"task_id": "HumanEval_typescript/62", "language": "typescript", "completion": "const derivative = (xs: Array<number>): Array<number> => {\n  const len = xs.length;\n  if (len === 0) {\n    throw new Error('Array cannot be empty');\n  }\n\n  let result: Array<number> = [];\n  for (let i = 1; i < len; i++) {\n    // Multiply the number by 'i' and subtract it from the next coefficient.\n    result[i - 1] = xs[i] * i;\n  }\n\n  // For the first element, take the next element (which doesn't exist for the last case)\n  result[len - 1] = xs[0];\n\n  return result;\n};"}
{"task_id": "HumanEval_typescript/63", "language": "typescript", "completion": "const fibfibMemo = (function () {\n    const memo: { [key: number]: number } = {};\n\n    return function (n: number): number {\n        if (n <= 2) return n; // base cases\n        if (memo[n]) return memo[n]; // if result is already computed, return it\n\n        let result = fibfibMemo(n - 1) + fibfibMemo(n - 2) + fibfibMemo(n - 3);\n        memo[n] = result; // store the result for future use\n        return result;\n    };\n})();"}
{"task_id": "HumanEval_typescript/64", "language": "typescript", "completion": "const vowels_count = (s: string): number => {\n  let count = 0;\n  const vowels = ['a', 'e', 'i', 'o', 'u', 'y'];\n\n  for (let i = 0; i < s.length; i++) {\n    if (vowels.includes(s[i].toLowerCase())) {\n      count++;\n    }\n  }\n\n  // If the last character is 'y' and the length of the string is greater than one, add to the count.\n  if (s[s.length - 1] === 'y' && s.length > 1) {\n    count++;\n  }\n\n  return count;\n};"}
{"task_id": "HumanEval_typescript/65", "language": "typescript", "completion": "const circular_shift = function (x: number, shift: number): string {\n    const strX = String(x);\n    let result = '';\n\n    for (let i = strX.length - 1; i >= 0; i--) {\n        if (i < shift) {\n            result += strX[i + shift];\n        } else {\n            result += strX[i];\n        }\n    }\n\n    if (shift > strX.length) {\n        // Reverse the digits if shift is greater than the number of digits\n        for (let i = 0; i < strX.length; i++) {\n            result += strX[strX.length - 1 - i];\n        }\n    }\n\n    return result;\n};"}
{"task_id": "HumanEval_typescript/66", "language": "typescript", "completion": "const digitSum = (s: string): number => {\n  let sum = 0;\n  const asciiCodes = Array.from(s.toUpperCase()).map((char) => char.codePointAt(0));\n\n  for (let i = 0; i < asciiCodes.length; i++) {\n    if (asciiCodes[i] > 64 && asciiCodes[i] <= 90) {\n      sum += asciiCodes[i];\n    }\n  }\n\n  return sum;\n};"}
{"task_id": "HumanEval_typescript/67", "language": "typescript", "completion": "const fruit_distribution = function (s: string, n: number): number {\n  // Split the string into an array using 'and' as a delimiter\n  const fruitsArray = s.split(' and ');\n\n  // Initialize variables to store the counts of apples, oranges, and mangoes\n  let applesCount = 0;\n  let orangesCount = 0;\n  let mangoesCount = 0;\n\n  // Iterate through the fruitsArray\n  for (const fruitInfo of fruitsArray) {\n    // Split each fruit information into an array using a space as a delimiter\n    const [fruit, count] = fruitInfo.split(' ');\n\n    // Based on the fruit type, increment the corresponding count variable\n    if (fruit === 'apples') {\n      applesCount += Number(count);\n    } else if (fruit === 'oranges') {\n      orangesCount += Number(count);\n    }\n  }\n\n  // Calculate the number of mangoes by subtracting the counts of apples and oranges from the total count of fruits\n  const mangoesCount = n - applesCount - orangesCount;\n\n  return mangoesCount;\n};"}
{"task_id": "HumanEval_typescript/68", "language": "typescript", "completion": "function pluck(arr: number[]): number[] {\n  let smallestEvenValue = Number.MAX_SAFE_INTEGER;\n  let smallestIndex = -1;\n\n  for (let i = 0; i < arr.length; i++) {\n    const value = arr[i];\n    if (value % 2 === 0 && value < smallestEvenValue) {\n      smallestEvenValue = value;\n      smallestIndex = i;\n    }\n  }\n\n  return smallestEvenValue !== Number.MAX_SAFE_INTEGER ? [smallestEvenValue, smallestIndex] : [];\n}"}
{"task_id": "HumanEval_typescript/69", "language": "typescript", "completion": "function search(lst: number[]): number {\n  const freqObj = lst.reduce((acc, val) => {\n    if (!acc[val]) acc[val] = 0;\n    acc[val]++;\n    return acc;\n  }, {} as Record<number, number>);\n\n  for (const [key, value] of Object.entries(freqObj)) {\n    if (value >= Number(key)) return Number(key);\n  }\n\n  return -1;\n}"}
{"task_id": "HumanEval_typescript/70", "language": "typescript", "completion": "function strange_sort_list(lst: number[]): number[] {\n    let sorted = [...lst]; // make a copy of the array\n    const n = sorted.length;\n\n    for (let i = 0; i < Math.floor(n / 2); i++) {\n        const minIndex = i;\n        const maxIndex = findMaxIndex(sorted, i, n);\n\n        // Swap the found min and max elements\n        [sorted[minIndex], sorted[maxIndex]] = [sorted[maxIndex], sorted[minIndex]];\n    }\n\n    return sorted;\n\n    function findMaxIndex(arr: number[], start: number, end: number): number {\n        let maxValue = Number.MIN_VALUE;\n        let maxIndex = -1;\n\n        for (let i = start; i < end; i++) {\n            if (arr[i] > maxValue) {\n                maxValue = arr[i];\n                maxIndex = i;\n            }\n        }\n        return maxIndex;\n    }\n}"}
{"task_id": "HumanEval_typescript/71", "language": "typescript", "completion": "function triangle_area(a: number, b: number, c: number): number {\n  // Check if the three sides form a valid triangle\n  if (a + b <= c || b + c <= a || c + a <= b) {\n    return -1;\n  }\n\n  // Calculate semi-perimeter\n  const s = (a + b + c) / 2;\n\n  // Calculate area using Heron's formula\n  const area = Math.sqrt(s * (s - a) * (s - b) * (s - c));\n\n  return Math.round(area * 100) / 100;\n}"}
{"task_id": "HumanEval_typescript/72", "language": "typescript", "completion": "const willItFly = (q: number[], w: number): boolean => {\n  // Check if array is palindromic (balanced) by comparing elements at index i and length - i\n  const isBalanced = () => q.every((_, i, arr) => arr[i] === arr[arr.length - i - 1]);\n\n  // Sum the elements in the array\n  const totalWeight = q.reduce((acc, val) => acc + val, 0);\n\n  return isBalanced() && totalWeight <= w;\n};"}
{"task_id": "HumanEval_typescript/73", "language": "typescript", "completion": "const smallest_change = function (arr: number[]): number {\n  let left = 0;\n  let right = arr.length - 1;\n  let changes = 0;\n\n  // Check if the array is already palindromic or not\n  while (left < right) {\n    if (arr[left] !== arr[right]) {\n      changes++;\n    }\n    left++;\n    right--;\n  }\n\n  // If the array is odd-length, we need to change the middle element to make it palindromic\n  if (arr.length % 2 !== 0) {\n    changes++;\n  }\n\n  // Now we iterate through the array again and find the minimum number of changes needed to make each half a mirror image of the other\n  for (let i = left; i < right; i++) {\n    const temp = arr[i];\n    if (arr[i] !== arr[right - i]) {\n      changes++;\n      arr[i] = arr[right - i];\n      arr[right - i] = temp;\n      right--;\n    }\n  }\n\n  return changes;\n}"}
{"task_id": "HumanEval_typescript/74", "language": "typescript", "completion": "const total_match = (lst1: string[], lst2: string[]) => {\n  const totalCharsLst1 = lst1.reduce((acc, str) => acc + str.length, 0);\n  const totalCharsLst2 = lst2.reduce((acc, str) => acc + str.length, 0);\n\n  if (totalCharsLst1 < totalCharsLst2) {\n    return lst1;\n  } else if (totalCharsLst1 > totalCharsLst2) {\n    return lst2;\n  } else {\n    return [...lst1, ...lst2];\n  }\n};"}
{"task_id": "HumanEval_typescript/75", "language": "typescript", "completion": "const is_multiply_prime = (a: number): boolean => {\n    // Create an array to store whether each number up to sqrt(a) is prime or not\n    const primes = new Array(Math.floor(Math.sqrt(a)) + 1).fill(true);\n    primes[0] = false;\n    primes[1] = false;\n\n    // Sieve of Eratosthenes to find prime numbers up to sqrt(a)\n    for (let i = 2; i <= Math.floor(Math.sqrt(a)); i++) {\n        if (primes[i]) {\n            const multiple = Math.floor(a / i);\n            primes[multiple * i] = false;\n            for (let j = i + i; j <= Math.floor(Math.sqrt(a)); j += i) {\n                primes[j] = false;\n            }\n        }\n    }\n\n    // Check if a can be expressed as the product of three prime numbers from the array 'primes'\n    for (let i = 3; i < primes.length; i++) {\n        if (primes[i] && a % i !== 0) continue;\n        let multiplier = 1;\n        for (let j = i + 2; j <= primes.length; j += 2) {\n            if (primes[j] && a % j !== 0) continue;\n            multiplier++;\n            if (multiplier > 3 || (i * j > a)) break;\n            if (a === i * j * primes[multiplier]) return true;\n        }\n    }\n    return false;\n};"}
{"task_id": "HumanEval_typescript/76", "language": "typescript", "completion": "const is_simple_power = (x: number, n: number): boolean => {\n  if (x <= 0 || n <= 0) return false;\n\n  const log2X = Math.log2(x);\n  const power = Math.floor(log2X / Math.log2(n));\n\n  return (power * n ** power === x);\n};"}
{"task_id": "HumanEval_typescript/77", "language": "typescript", "completion": "const isCube = (a: number): boolean => {\n  const cubeRoot = Math.cbrt(a);\n  return Math.abs(cubeRoot * cubeRoot * cubeRoot - a) < Number.EPSILON;\n};"}
{"task_id": "HumanEval_typescript/78", "language": "typescript", "completion": "function hex_key(num: string): number {\n  const primeDigits: Record<string, number> = {\n    '2': 1,\n    '3': 1,\n    '5': 1,\n    '7': 1,\n    'B': 1,\n    'D': 1\n  };\n\n  let count = 0;\n\n  for (let i = 0; i < num.length; i++) {\n    const c = num[i];\n    if (c >= '0' && c <= '9') {\n      continue;\n    } else if (primeDigits[c]) {\n      count++;\n    }\n  }\n\n  return count;\n}"}
{"task_id": "HumanEval_typescript/79", "language": "typescript", "completion": "const decimal_to_binary = (decimal: number): string => {\n  let binary = 'db';\n\n  while (decimal > 0) {\n    binary += String(decimal % 2);\n    decimal = Math.floor(decimal / 2);\n    if (decimal > 0) binary += 'db';\n  }\n\n  return binary + 'db';\n}"}
{"task_id": "HumanEval_typescript/80", "language": "typescript", "completion": "function is_happy(s: string): boolean {\n  const length = s.length;\n  if (length < 3) return false;\n\n  for (let i = 0; i < length - 2; i += 3) {\n    const set = new Set();\n    for (let j = i; j < i + 3 && j < length; j++) {\n      set.add(s[j]);\n    }\n    if (set.size !== 3) return false;\n  }\n\n  return true;\n}"}
{"task_id": "HumanEval_typescript/81", "language": "typescript", "completion": "type GradeTable = { [gpa: number]: string };\nconst gradeTable: GradeTable = {\n  4.0: 'A+',\n  [4.01 > x && x > 3.7]: 'A',\n  [3.71 > x && x > 3.3]: 'A-',\n  [3.31 > x && x > 3.0]: 'B+',\n  [3.01 > x && x > 2.7]: 'B',\n  [2.71 > x && x > 2.3]: 'B-',\n  [2.31 > x && x > 2.0]: 'C+',\n  [2.01 > x && x > 1.7]: 'C',\n  [1.71 > x && x > 1.3]: 'C-',\n  [1.31 > x && x > 1.0]: 'D+',\n  [1.01 > x && x > 0.7]: 'D',\n  [0.71 > x && x >= 0.0]: 'D-',\n  0.0: 'E'\n};\n\nconst numerical_letter_grade = function (grades: Array<number>) : Array<string> {\n  return grades.map(gpa => gradeTable[gpa] || 'E');\n};"}
{"task_id": "HumanEval_typescript/82", "language": "typescript", "completion": "const isPrime = (num: number): boolean => {\n  if (num <= 1) return false;\n  for (let i = 2; i <= Math.sqrt(num); i++) {\n    if (num % i === 0) return false;\n  }\n  return true;\n};\n\nconst prime_length = function (string0: string): boolean {\n  const length = string0.length;\n  return isPrime(length);\n};"}
{"task_id": "HumanEval_typescript/83", "language": "typescript", "completion": "function starts_one_ends(n: number): number {\n    if (n <= 0) return 0;\n\n    let oneStartCount = Math.pow(10, n - 1); // Generate numbers starting with '1'\n    for (let i = 1; i < 9 * Math.pow(10, n - 1); i++) {\n        if (String(i).length !== n) continue;\n        let currentNumber = String(i + 1).repeat(n - 1) + '1';\n        oneStartCount += Number(currentNumber);\n    }\n\n    let oneEndCount = Math.pow(10, n - 1) * 9; // Generate numbers ending with '1'\n    for (let i = 10; i <= 99 * Math.pow(10, n - 2); i *= 10) {\n        let currentNumber = i.toString() + '1'.repeat(n - 1);\n        oneEndCount += Number(currentNumber);\n    }\n\n    return oneStartCount + oneEndCount;\n}"}
{"task_id": "HumanEval_typescript/84", "language": "typescript", "completion": "function solve(N: number): string {\n    let decimalDigitSum = 0;\n    let binaryString = '';\n\n    // Loop through each digit of N while N is greater than zero.\n    while (N > 0) {\n        // Calculate the sum of decimal digits for this iteration.\n        decimalDigitSum += N % 10;\n\n        // Remove the last digit from N and append it to binaryString in binary format.\n        N = Math.floor(N / 10);\n        binaryString = (N % 2) + binaryString;\n    }\n\n    // Calculate the total sum of digits in binary.\n    decimalDigitSum *= Math.floor(Math.log2(10));\n\n    // Convert decimalDigitSum to binary and prepend it to binaryString.\n    return (decimalDigitSum).toString(2) + binaryString;\n}"}
{"task_id": "HumanEval_typescript/85", "language": "typescript", "completion": "function add(lst: number[]): number {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 !== 0 && lst[i] % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n}"}
{"task_id": "HumanEval_typescript/86", "language": "typescript", "completion": "function anti_shuffle(s: string): string {\n  return s.split(' ').map((word) => word.split('').sort().join('')).join(' ');\n}"}
{"task_id": "HumanEval_typescript/87", "language": "typescript", "completion": "type Coordinate = [number, number];\n\nfunction get_row(lst: Array<Array<number>>, x: number): Coordinate[] {\n  let result: Coordinate[] = [];\n\n  lst.forEach((row, index) => {\n    row.forEach((element, columnIndex) => {\n      if (element === x) {\n        result.push([index, columnIndex]);\n      }\n    });\n  });\n\n  // Sort by rows in ascending order and columns in descending order\n  result.sort((a, b) => a[0] - b[0] || b[1] - a[1]);\n\n  return result;\n}"}
{"task_id": "HumanEval_typescript/88", "language": "typescript", "completion": "const sort_array = function (array: number[]): number[] {\n  const sumFirstLast = array[0] + array[array.length - 1];\n  let sortedArray;\n\n  if (sumFirstLast % 2 === 0) {\n    sortedArray = [...array].sort((a, b) => b - a);\n  } else {\n    sortedArray = [...array].sort((a, b) => a - b);\n  }\n\n  return sortedArray;\n};"}
{"task_id": "HumanEval_typescript/89", "language": "typescript", "completion": "const encrypt = (s: string): string => {\n  let result = '';\n  const rotatedAlphabet = 'abcdefghijklmnopqrstuvwxyz'.split('');\n\n  for (let i = 0; i < s.length; i++) {\n    if (s[i].match(/[a-z]/)) {\n      let index = rotatedAlphabet.indexOf(s[i]) + (2 * 2);\n      result += rotatedAlphabet[(index % 26)];\n    } else {\n      result += s[i]; // If the character is not a letter, leave it unchanged.\n    }\n  }\n\n  return result;\n};"}
{"task_id": "HumanEval_typescript/90", "language": "typescript", "completion": "type None = { kind: 'none' };\n\nconst next_smallest = (lst: number[]): any => {\n  if (lst.length === 0 || lst.length === 1) return new None();\n\n  const sorted = [...lst].sort((a, b) => a - b);\n\n  return sorted.length >= 2 ? sorted[1] : new None();\n};"}
{"task_id": "HumanEval_typescript/91", "language": "typescript", "completion": "const is_bored = (S: string): number => S.match(/^I\\s.*[\\.\\?!]$/g)?.length || 0;"}
{"task_id": "HumanEval_typescript/92", "language": "typescript", "completion": "function any_int(x: number, y: number, z: number): boolean {\n    // Check if all numbers are integers\n    if (!Number.isInteger(x) || !Number.isInteger(y) || !Number.isInteger(z)) {\n        return false;\n    }\n\n    // Check if one of the numbers is equal to the sum of the other two\n    let sum = x + y + z;\n    let uniqueNumbers = new Set([x, y, z]);\n\n    for (let number of uniqueNumbers) {\n        if (sum - number === number || sum - number === -number) {\n            return true;\n        }\n    }\n\n    return false;\n}"}
{"task_id": "HumanEval_typescript/93", "language": "typescript", "completion": "const encode = function (message: string): string {\n  const vowelChars = ['a', 'e', 'i', 'o', 'u'];\n  const vowelSubstitutions: string[] = Array(vowelChars.length).fill('').map((_, i) => String.fromCharCode(vowelChars[i].charCodeAt(0) + 3));\n  return message.replace(/./g, (letter) => letter.toLowerCase() === letter ? vowelChars.includes(letter) ? vowelSubstitutions[vowelChars.indexOf(letter)] : letter.toUpperCase() : letter);\n};"}
{"task_id": "HumanEval_typescript/94", "language": "typescript", "completion": "function isPrime(num: number): boolean {\n  if (num < 2) return false;\n\n  for (let i = 2; i <= Math.sqrt(num); i++) {\n    if (num % i === 0) return false;\n  }\n\n  return true;\n}\n\nfunction sumDigits(num: number): number {\n  let sum = 0;\n  const strNum = num.toString();\n\n  for (let i = 0; i < strNum.length; i++) {\n    sum += parseInt(strNum[i]);\n  }\n\n  return sum;\n}\n\nfunction largestPrimeSumOfDigits(lst: Array<number>): number {\n  let maxPrime = -Infinity;\n  let result = 0;\n\n  for (let i = 0; i < lst.length; i++) {\n    if (isPrime(lst[i]) && lst[i] > maxPrime) {\n      maxPrime = lst[i];\n    }\n  }\n\n  if (maxPrime === -Infinity) return -1; // Return -1 if no prime number is found in the list\n\n  result = sumDigits(maxPrime);\n  return result;\n}"}
{"task_id": "HumanEval_typescript/95", "language": "typescript", "completion": "function check_dict_case(dict: Map<string | number, string>): boolean {\n  if (dict.size === 0) return false;\n\n  const keySet = new Set(Array.from(dict.keys()));\n  const isLowerCase = [...keySet].every((key) => key === key.toLowerCase());\n  const isUpperCase = [...keySet].every((key) => key === key.toUpperCase());\n\n  return isLowerCase || isUpperCase;\n}"}
{"task_id": "HumanEval_typescript/96", "language": "typescript", "completion": "function isPrime(num: number): boolean {\n  if (num <= 1) return false;\n  if (num === 2) return true;\n  if (num % 2 === 0) return false;\n\n  let root = Math.sqrt(num);\n  for (let i = 3; i <= root; i += 2) {\n    if (num % i === 0) return false;\n  }\n\n  return true;\n}\n\nfunction count_up_to(n: number): Array<number> {\n  const primes: Array<number> = [];\n  let num = 2;\n\n  while (num < n) {\n    if (isPrime(num)) {\n      primes.push(num);\n    }\n\n    num++;\n  }\n\n  return primes;\n}"}
{"task_id": "HumanEval_typescript/97", "language": "typescript", "completion": "const multiply = function (a: number, b: number): number {\n  // Extract the unit digits by applying modulo operation on both numbers\n  const aUnitDigit = a % 10;\n  const bUnitDigit = b % 10;\n\n  // Multiply them and return the result\n  return aUnitDigit * bUnitDigit;\n};"}
{"task_id": "HumanEval_typescript/98", "language": "typescript", "completion": "const count_upper = (s: string): number => {\n  let count = 0;\n  const vowels = ['A', 'E', 'I', 'O', 'U'];\n\n  for (let i = 0; i < s.length; i++) {\n    if (vowels.includes(s[i].toUpperCase()) && i % 2 === 0) {\n      count++;\n    }\n  }\n\n  return count;\n};"}
{"task_id": "HumanEval_typescript/99", "language": "typescript", "completion": "import * as math from 'mathjs';\n\nconst closest_integer = (value: string): number => {\n  const parsedValue = math.eval(value); // Parses the input value as a number\n\n  // Round to the nearest integer and use the rounding rule that rounds away from zero if equidistant\n  const roundedValue = Math.round(parsedValue) + (Math.sign(parsedValue) * Math.floor(Math.abs(parsedValue)));\n\n  return roundedValue;\n};"}
{"task_id": "HumanEval_typescript/100", "language": "typescript", "completion": "const make_a_pile = function (n: number): Array<number> {\n  const pile: Array<number> = [n];\n  let currentLevel = n;\n\n  while (currentLevel > 1) {\n    const nextLevel = currentLevel % 2 === 0 ? currentLevel + 2 : currentLevel + 1;\n    pile.push(nextLevel);\n    currentLevel = nextLevel;\n  }\n\n  return pile;\n};"}
{"task_id": "HumanEval_typescript/101", "language": "typescript", "completion": "function words_string(s: string): string[] {\n  return s.split(/\\s*,\\s*/);\n}"}
{"task_id": "HumanEval_typescript/102", "language": "typescript", "completion": "const choose_num = (x: number, y: number): number => {\n    const bigger = Math.max(x, y);\n    let result = bigger - 1;\n\n    if (result % 2 !== 0) {\n        return -1;\n    }\n\n    if (bigger === x && bigger <= result) {\n        return x;\n    }\n\n    return result;\n};"}
{"task_id": "HumanEval_typescript/103", "language": "typescript", "completion": "function roundedAvg(n: number, m: number): string | number {\n  // Ensure n is not greater than m\n  if (n > m) return -1;\n\n  // Calculate the average of all integers from n to m (inclusive)\n  const total = (m - n + 1) * ((n + m) / 2);\n\n  // Round the average to the nearest integer and store it in an intermediate variable\n  let avg = Math.round(total);\n\n  // Convert the rounded average to a binary string\n  const binaryStr = (avg >>> 0).toString(2);\n\n  return binaryStr;\n}"}
{"task_id": "HumanEval_typescript/104", "language": "typescript", "completion": "const unique_digits = function (x: Array<number>): Array<number> {\n  const filteredNumbers = x.filter(num => !hasEvenDigit(num));\n  return filteredNumbers.sort((a, b) => a - b);\n}\n\nconst hasEvenDigit = function (n: number): boolean {\n  const strNum = n.toString();\n  for (let i = 0; i < strNum.length; i++) {\n    if (parseInt(strNum[i]) % 2 === 0) {\n      return true;\n    }\n  }\n  return false;\n}"}
{"task_id": "HumanEval_typescript/105", "language": "typescript", "completion": "type NumberNames = \"One\" | \"Two\" | \"Three\" | \"Four\" | \"Five\" | \"Six\" | \"Seven\" | \"Eight\" | \"Nine\";\nconst numberNamesMap: Record<number, NumberNames> = {\n  1: 'One',\n  2: 'Two',\n  3: 'Three',\n  4: 'Four',\n  5: 'Five',\n  6: 'Six',\n  7: 'Seven',\n  8: 'Eight',\n  9: 'Nine'\n};\n\nfunction by_length(arr: Array<number>): Array<NumberNames> {\n  const validNumbers = arr.filter((num) => num >= 1 && num <= 9);\n  if (validNumbers.length === 0) return [];\n\n  let sortedValidNumbers = [...validNumbers].sort((a, b) => a - b);\n  let result: NumberNames[] = sortedValidNumbers.map((num) => numberNamesMap[num]);\n\n  for (let i = 0; i < arr.length; i++) {\n    if (!Number.isInteger(arr[i]) || arr[i] < 1 || arr[i] > 9) continue;\n    result[sortedValidNumbers.indexOf(arr[i])] = numberNamesMap[arr[i]];\n  }\n\n  return result.reverse();\n}"}
{"task_id": "HumanEval_typescript/106", "language": "typescript", "completion": "const f = (n: number): Array<number> => {\n  const result: Array<number> = [];\n\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      result.push(fact(i));\n    } else {\n      result.push(sumOfNumbersUpTo(i));\n    }\n  }\n\n  return result;\n};\n\nconst fact = (n: number): number => {\n  if (n === 0 || n === 1) {\n    return 1;\n  } else {\n    return n * fact(n - 1);\n  }\n};\n\nconst sumOfNumbersUpTo = (n: number): number => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};"}
{"task_id": "HumanEval_typescript/107", "language": "typescript", "completion": "const isPalindrome = (num: number): boolean => {\n  const numStr = num.toString();\n  let start = 0;\n  let end = numStr.length - 1;\n\n  while (start < end) {\n    if (numStr[start] !== numStr[end]) {\n      return false;\n    }\n    start++;\n    end--;\n  }\n\n  return true;\n};\n\nconst even_odd_palindrome = function (n: number): [number, number] {\n  let countEven = 0;\n  let countOdd = 0;\n\n  for (let i = 1; i <= n; i++) {\n    if (isPalindrome(i) && i % 2 === 0) {\n      countEven++;\n    } else if (isPalindrome(i) && i % 2 !== 0) {\n      countOdd++;\n    }\n  }\n\n  return [countEven, countOdd];\n};"}
{"task_id": "HumanEval_typescript/108", "language": "typescript", "completion": "const count_nums = (arr: Array<number>): number => {\n  let result = 0;\n\n  // Loop through the input array\n  for (let i = 0; i < arr.length; i++) {\n    const num = Math.abs(arr[i]); // Absolute value to handle negatives\n\n    // Check if the number is positive or zero, and calculate its sum of digits\n    if (num > 0) {\n      let sumOfDigits = 0;\n      let currentNum = num;\n\n      while (currentNum !== 0) {\n        const remainder = currentNum % 10;\n        sumOfDigits += remainder;\n        currentNum = Math.floor(currentNum / 10);\n      }\n\n      // If the sum of digits is greater than zero, increment the result counter\n      if (sumOfDigits > 0) {\n        result++;\n      }\n    }\n  }\n\n  return result;\n};"}
{"task_id": "HumanEval_typescript/109", "language": "typescript", "completion": "function move_one_ball(arr: number[]): boolean {\n  if (arr.length === 0) return true;\n\n  let smallest = arr[0];\n  let indexOfSmallest = 0;\n\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] < smallest) {\n      smallest = arr[i];\n      indexOfSmallest = i;\n    }\n  }\n\n  return indexOfSmallest !== 0 && arr[indexOfSmallest - 1] <= arr[indexOfSmallest];\n}"}
{"task_id": "HumanEval_typescript/110", "language": "typescript", "completion": "const exchange = function (lst1: Array<number>, lst2: Array<number>): string {\n  let countEvenInLst1 = 0;\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2 === 0) countEvenInLst1++;\n  }\n\n  let countOddInLst2 = 0;\n  for (let i = 0; i < lst2.length; i++) {\n    if (lst2[i] % 2 !== 0) countOddInLst2++;\n  }\n\n  let filledEvenInLst1 = 0;\n\n  // Swap elements until all even numbers in lst1 are filled\n  while (filledEvenInLst1 < countEvenInLst1) {\n    if (countOddInLst2 === 0) return \"NO\";\n\n    const evenIndex = Math.floor(Math.random() * countEvenInLst1);\n    const oddIndex = Math.floor(Math.random() * countOddInLst2);\n\n    lst1[evenIndex] = lst1[evenIndex] % 2 !== 0 ? lst1[evenIndex] : undefined;\n    lst2[oddIndex] = lst2[oddIndex] % 2 === 0 ? lst2[oddIndex] : undefined;\n\n    if (lst1[evenIndex] !== undefined) {\n      filledEvenInLst1++;\n    }\n\n    countOddInLst2--;\n  }\n\n  return \"YES\";\n};"}
{"task_id": "HumanEval_typescript/111", "language": "typescript", "completion": "function histogram(test: string): Map<string, number> {\n  const result = new Map();\n\n  // Iterate through each character in the input string\n  for (let char of test) {\n    if (!result.has(char)) {\n      // If the current character is not present in the map, add it with a count of 1\n      result.set(char, 1);\n    } else {\n      // If the current character already exists in the map, increment its count\n      const currentCount = result.get(char)!;\n      result.set(char, currentCount + 1);\n    }\n  }\n\n  return result;\n}"}
{"task_id": "HumanEval_typescript/112", "language": "typescript", "completion": "function reverse_delete(s: string, c: string): [string, boolean] {\n  const result = s.split('').filter((char) => !c.includes(char)).join('');\n\n  // Check if the resulting string is palindrome by comparing it with its reversed version\n  const isPalindrome = result === result.split('').reverse().join('');\n\n  return [result, isPalindrome];\n}"}
{"task_id": "HumanEval_typescript/113", "language": "typescript", "completion": "function odd_count(lst: Array<string>): Array<string> {\n    const result = lst.map((str) => {\n        let count = 0;\n        for (let i = 0; i < str.length; i++) {\n            const num = parseInt(str[i], 10);\n            if (isNaN(num)) continue; // skip non-digits\n            if ((num & 1) === 1) count++; // check if the number is odd using bitwise AND and then incrementing count if true\n        }\n\n        return `the number of odd elements in the string ${str} of the input. is ${count}.`;\n    });\n    return result;\n}"}
{"task_id": "HumanEval_typescript/114", "language": "typescript", "completion": "const minSubArraySum = (nums: Array<number>): number => {\n  let minSum = Infinity;\n  let currentSum = 0;\n\n  for (let i = 0; i < nums.length; i++) {\n    currentSum += nums[i];\n\n    // If the current sum is less than or equal to the minimum sum found, update it\n    if (currentSum <= minSum || minSum === Infinity) {\n      minSum = currentSum;\n    }\n\n    // If we've seen a larger subarray, and the current subarray has become negative, reset it to 0 and continue.\n    if (currentSum > minSum && currentSum < 0) {\n      currentSum = 0;\n      continue;\n    }\n  }\n\n  return minSum;\n};"}
{"task_id": "HumanEval_typescript/115", "language": "typescript", "completion": "const max_fill = function (grid: Array<Array<number>>, capacity: number) : number {\n  let times = 0;\n  const rows = grid.length;\n  const cols = grid[0].length;\n  let bucket = new Array(capacity).fill(0); // Initialize the bucket with zeros\n\n  for (let i = 0; i < rows; i++) {\n    for (let j = 0; j < cols; j++) {\n      if (grid[i][j] > 0 && bucket.every((val, idx) => val < grid[i][j])) { // If there's room in the bucket and water in the well\n        let minFillAmount = Math.min(...bucket);\n        for (let k = 0; k < minFillAmount; k++) {\n          bucket[k] += grid[i][j];\n          grid[i][j] -= grid[i][j];\n        }\n      }\n    }\n\n    if (bucket.every((val) => val === 0)) { // If the bucket is empty after iterating through all wells in a row\n      times++;\n      bucket = new Array(capacity).fill(0); // Reset the bucket for the next row\n    }\n  }\n\n  return times;\n}"}
{"task_id": "HumanEval_typescript/116", "language": "typescript", "completion": "function sort_array(arr: number[]): number[] {\n  const sortedByOnes = arr.slice().sort((a, b) => {\n    // Convert numbers to binary and find the count of ones\n    let aBinary = a.toString(2);\n    let bBinary = b.toString(2);\n\n    while (aBinary.length < bBinary.length) {\n      aBinary = '0' + aBinary;\n    }\n\n    while (bBinary.length < aBinary.length) {\n      bBinary = '0' + bBinary;\n    }\n\n    let countA = aBinary.split('1').length - 1;\n    let countB = bBinary.split('1').length - 1;\n\n    // If the number of ones is equal, sort based on decimal value\n    if (countA === countB) {\n      return a - b;\n    }\n\n    return countA - countB;\n  });\n\n  return sortedByOnes;\n}"}
{"task_id": "HumanEval_typescript/117", "language": "typescript", "completion": "const select_words = function (s: string, n: number) : Array<string> {\n  const words = s.split(' '); // Split the input string into an array of words\n  const result: Array<string> = []; // Initialize an empty array to store our selected words\n\n  for(let i = 0; i < words.length; i++) {\n    let count = 0; // Initialize the consonant counter to zero\n\n    for (let j = 1; j <= words[i].length; j++) {\n      const currentCharCode = words[i].charCodeAt(j - 1); // Get the character code of the current character\n\n      if ((currentCharCode >= 65 && currentCharCode <= 90) || (currentCharCode >= 97 && currentCharCode <= 122)) { // Check if it's a consonant\n        const vowelPositions = ['a', 'e', 'i', 'o', 'u']; // List of vowels\n        const indexOfVowel = vowelPositions.indexOf(words[i][j - 1].toLowerCase()); // Check if the current character is a vowel\n\n        if (indexOfVowel === -1) { // If the current character is not a vowel, increment the consonant counter\n          count++;\n        }\n      }\n    }\n\n    if (count === n) { // Check if the number of consonants in this word matches our desired value\n      result.push(words[i]); // If it does, add the word to our result array\n    }\n  }\n\n  return result; // Return the final result array\n};"}
{"task_id": "HumanEval_typescript/118", "language": "typescript", "completion": "type Vowels = 'a' | 'e' | 'i' | 'o' | 'u';\n\nconst get_closest_vowel = (word: string): string => {\n  let result = '';\n\n  // Iterate through the word from right to left\n  for (let i = word.length - 1; i >= 0; i--) {\n    const char = word[i].toLowerCase();\n\n    // Check if the character is a vowel and both its neighbors are consonants\n    if (\n      isVowel(char) &&\n      (i < word.length - 1 && !isConsonant(word[i + 1])) &&\n      (i > 0 && !isConsonant(word[i - 1]))\n    ) {\n      result = char.toUpperCase();\n      break;\n    }\n  }\n\n  return result;\n};\n\nconst isVowel = (char: string): char is Vowels => /[aeiou]/i.test(char);\nconst isConsonant = (char: string): boolean => !isVowel(char) && /[bcdfghjklmnpqrstvwxyz]/i.test(char);"}
{"task_id": "HumanEval_typescript/119", "language": "typescript", "completion": "function match_parens(lst: Array<string>): string {\n  const openCount = lst[0].split('').filter(c => c === '(').length;\n  const closeCount = lst[0].split('').filter(c => c === ')').length;\n  if (openCount !== closeCount) return \"No\";\n\n  const combined = lst[0] + lst[1];\n  let closedCount = 0;\n  for (let i = 0; i < combined.length; i++) {\n    if (combined[i] === ')') closedCount++;\n    else if (closedCount > 0) closedCount--;\n  }\n\n  return closedCount === 0 ? \"Yes\" : \"No\";\n}"}
{"task_id": "HumanEval_typescript/120", "language": "typescript", "completion": "function quickSelect(arr: number[], k: number) {\n  let left = 0;\n  let right = arr.length - 1;\n  let pivotIndex = Math.floor((left + right) / 2);\n\n  while (true) {\n    const pivotValue = arr[pivotIndex];\n    // Find the index where all elements smaller than pivot are on the left,\n    // and all greater on the right.\n    let storeIndex = left;\n\n    for (let i = left; i <= right; i++) {\n      if (arr[i] < pivotValue) {\n        [arr[storeIndex], arr[i]] = [arr[i], arr[storeIndex]];\n        storeIndex++;\n      }\n    }\n\n    // Swap the pivot element to its sorted position.\n    [arr[pivotIndex], arr[storeIndex]] = [arr[storeIndex], arr[pivotIndex]];\n\n    if (storeIndex === k) {\n      return arr.slice(0, k);\n    } else if (storeIndex < k) {\n      left = storeIndex + 1;\n    } else {\n      right = storeIndex - 1;\n    }\n  }\n}\n\nconst maximum = function (arr: Array<number>, k: number) : Array<number> {\n  return quickSelect(arr, arr.length - k);\n};"}
{"task_id": "HumanEval_typescript/121", "language": "typescript", "completion": "function solution(lst: number[]): number {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0 && lst[i] % 2 !== 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n}"}
{"task_id": "HumanEval_typescript/122", "language": "typescript", "completion": "const add_elements = (arr: Array<number>, k: number): number => {\n  let sum = 0;\n\n  // Iterate over the first 'k' elements of the array\n  for (let i = 0; i < k && i < arr.length; i++) {\n    const num = arr[i];\n\n    // If the number has more than two digits, skip it and continue to the next element\n    if (String(num).length > 2) continue;\n\n    sum += num;\n  }\n\n  return sum;\n};"}
{"task_id": "HumanEval_typescript/123", "language": "typescript", "completion": "type CollatzSequence = Array<number>;\n\nconst get_odd_collatz = (n: number): CollatzSequence => {\n  const collatzMap: Map<number, number[]> = new Map();\n\n  // Build a map to store the collatz sequences for odd numbers up to n\n  let currentNum = 1;\n  while (currentNum <= n) {\n    if (currentNum % 2 !== 0) {\n      const sequence: CollatzSequence = [currentNum];\n      let nextNum = currentNum * 3 + 1;\n      while (nextNum <= n) {\n        sequence.push(nextNum);\n        collatzMap.set(nextNum, sequence);\n        nextNum = (nextNum % 2 === 0) ? Math.floor(nextNum / 2) : (nextNum * 3 + 1);\n      }\n    }\n    currentNum += 2;\n  }\n\n  // Find the required sequence in the map and sort it if necessary\n  const result: CollatzSequence = [];\n  for (let i = 1; i <= n; i += 2) {\n    const seq = collatzMap.get(i);\n    if (seq && seq.includes(n)) {\n      result.push(...seq);\n    }\n  }\n\n  // Sort the result array if necessary\n  if (result.length > 1) {\n    result.sort((a, b) => a - b);\n  }\n\n  return result;\n};"}
{"task_id": "HumanEval_typescript/124", "language": "typescript", "completion": "type Month = 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12;\n\nconst valid_date = (date: string): boolean => {\n  // Check if the date string is not empty\n  if (!date) return false;\n\n  // Split the date string into parts by '-' and ensure it has 3 parts\n  const [monthStr, dayStr, yearStr] = date.split('-').map(part => parseInt(part, 10));\n\n  // Check if month, day, and year are valid numbers\n  if (!Number.isFinite(monthStr) || !Number.isFinite(dayStr) || !Number.isFinite(yearStr)) return false;\n\n  // Check if month is a valid value (1-12)\n  const month = Math.min(Math.max(monthStr, 1), 12);\n\n  // Check if day is a valid value for the given month\n  let maxDay: number;\n  switch (month) {\n    case 2:\n      maxDay = 29;\n      break;\n    case 4:\n    case 6:\n    case 9:\n    case 11:\n      maxDay = 30;\n      break;\n    default:\n      maxDay = 31;\n      break;\n  }\n\n  // Check if day is a valid value (1-maxDay)\n  const day = Math.min(Math.max(dayStr, 1), maxDay);\n\n  // Check if year is a valid value (greater than or equal to the current year minus 100)\n  const currentYear = new Date().getFullYear();\n  const year = Math.min(Math.max(yearStr, currentYear - 100), currentYear);\n\n  // If all checks pass, return true, otherwise return false\n  return month >= 1 && month <= 12 && day >= 1 && day <= maxDay && year >= (currentYear - 100);\n};"}
{"task_id": "HumanEval_typescript/125", "language": "typescript", "completion": "const split_words = function(txt: string): any {\n  const words: string[] = txt.split(/[\\s,]+/); // Split on whitespace or comma\n\n  if (words.length === 1) {\n    const oddAlphabetChars: number[] = [];\n\n    for (let charCode of txt.codePointAt(0).toString().split('')) {\n      const charIndex = charCode.codePointAt(0) - 97; // Map character to its index in the alphabet (assuming ASCII characters only)\n      if (charIndex !== undefined && charIndex > 0 && charIndex % 2 !== 0) {\n        oddAlphabetChars.push(String.fromCodePoint(charCode));\n      }\n    }\n\n    words[0] = oddAlphabetChars; // Return the array of odd alphabet characters as a single element in the result\n  }\n\n  return words;\n};"}
{"task_id": "HumanEval_typescript/126", "language": "typescript", "completion": "function isSorted(lst: number[]): boolean {\n    if (lst.length <= 1) return true;\n\n    for (let i = 1; i < lst.length; i++) {\n        if (lst[i] < lst[i - 1]) return false;\n        if (lst[i] === lst[i - 1] && lst.indexOf(lst[i]) !== lst.lastIndexOf(lst[i])) return false;\n    }\n\n    return true;\n}"}
{"task_id": "HumanEval_typescript/127", "language": "typescript", "completion": "type Interval = [number, number];\n\nfunction intersection(interval1: Interval, interval2: Interval): string {\n  // Check if intervals don't intersect by comparing their endpoints\n  if (interval1[1] < interval2[0] || interval2[1] < interval1[0]) {\n    return \"NO\";\n  }\n\n  // Calculate the intersection start and end points\n  const [start, end] = Math.max(interval1[0], interval2[0]),\n    minEnd = Math.min(interval1[1], interval2[1]);\n\n  // If the intersection starts before it ends, return its length as a string\n  if (start <= minEnd) {\n    const len = minEnd - start + 1;\n    return isPrime(len) ? \"YES\" : \"NO\";\n  }\n\n  // Otherwise, there's no intersection\n  return \"NO\";\n}\n\nfunction isPrime(num: number): boolean {\n  if (num <= 1) return false;\n  if (num === 2) return true;\n  for (let i = 2; i * i <= num; i++) {\n    if (num % i === 0) return false;\n  }\n  return true;\n}"}
{"task_id": "HumanEval_typescript/128", "language": "typescript", "completion": "function prod_signs(arr: number[]): number | undefined {\n  if (arr.length === 0) return undefined; // check if array is empty\n\n  let productSign = 1; // initialize product of signs\n  let sumMagnitude = 0; // initialize sum of magnitudes\n\n  for (let i = 0; i < arr.length; i++) {\n    const currentNumber = arr[i];\n\n    if (currentNumber === 0) continue; // skip zeros\n\n    productSign *= currentNumber > 0 ? 1 : -1;\n    sumMagnitude += Math.abs(currentNumber);\n  }\n\n  return productSign * sumMagnitude;\n}"}
{"task_id": "HumanEval_typescript/129", "language": "typescript", "completion": "type Cell = [number, number];\ntype Path = Array<Cell>;\ntype Grid = Array<Array<number>>;\n\nfunction minPath(grid: Grid, k: number): Path {\n  const directions: Cell[] = [[-1, 0], [1, 0], [0, -1], [0, 1]]; // Up, down, left, right\n  let path: Path = [[...grid[0], 0]]; // Start at the first cell and mark current index as 0\n  const visited: Set<number> = new Set(); // Keep track of visited cells\n  let nextCellIndex: number;\n\n  function dfs(currentCell: Cell, currentPathLength: number): void {\n    if (currentPathLength === k) return; // If we've reached the desired path length, return\n\n    visited.add(currentCell[0] * N + currentCell[1]); // Mark the current cell as visited\n\n    for (const [dx, dy] of directions) {\n      const nextX = currentCell[0] + dx;\n      const nextY = currentCell[1] + dy;\n\n      if (nextX >= 0 && nextX < N && nextY >= 0 && nextY < N && !visited.has(nextX * N + nextY)) { // Check if the neighbor is within grid bounds and unvisited\n        const nextCell = [nextX, nextY];\n        path.push(nextCell);\n        dfs(nextCell, currentPathLength + 1); // Recursively try to find a minimum path from the neighbor cell\n        path.pop(); // Backtrack if we found a longer path\n      }\n    }\n  }\n\n  for (let i = 1; i < N; i++) { // Start DFS from each cell in the grid\n    nextCellIndex = i;\n    visited.clear();\n    dfs([Math.floor(i / N), i % N], 0);\n    if (path.length === k) return path; // If we found a minimum path, return it\n  }\n\n  throw new Error(\"No solution exists for the given grid and k\"); // Return an error since no solution was found\n}"}
{"task_id": "HumanEval_typescript/130", "language": "typescript", "completion": "type Tribonacci = (n: number) => Array<number>;\n\nconst tri: Tribonacci = (n: number): Array<number> => {\n  const sequence: Array<number> = [0, 0, 3]; // Initialize the array with the first three numbers of the sequence\n\n  for (let i = 3; i <= n + 1; ++i) {\n    if (i % 2 === 0) {\n      sequence[i] = sequence[i - 2] + (sequence[i - 1] / 2);\n    } else {\n      const prevIndex = i - 3; // The previous index in the array (wraps around from the end)\n      sequence[i] = sequence[prevIndex] + sequence[prevIndex + 1] + sequence[prevIndex + 2];\n    }\n  }\n\n  return sequence.slice(0, n + 1); // Return only the first n + 1 numbers of the sequence\n};"}
{"task_id": "HumanEval_typescript/131", "language": "typescript", "completion": "function digits(n: number): number {\n    let oddProduct = 1;\n\n    const stringN = n.toString();\n\n    for (let i = 0; i < stringN.length; i++) {\n        const currentDigit = parseInt(stringN[i], 10);\n\n        if (currentDigit % 2 !== 0) {\n            oddProduct *= currentDigit;\n        }\n    }\n\n    return oddProduct;\n}"}
{"task_id": "HumanEval_typescript/132", "language": "typescript", "completion": "function is_nested(string0: string): boolean {\n  let openBrackets = 0;\n  let closeBrackets = 0;\n\n  for (let i = 0; i < string0.length; i++) {\n    if (string0[i] === '[') {\n      openBrackets++;\n    } else if (string0[i] === ']') {\n      closeBrackets++;\n    }\n  }\n\n  // If the number of opening brackets is greater than or equal to the number of closing brackets, then the string does not have nested sequences.\n  if (openBrackets <= closeBrackets) {\n    return false;\n  }\n\n  let remainingOpenBrackets = openBrackets - closeBrackets;\n\n  // Recursively check the substrings obtained by removing one character at a time from the end of the input string.\n  for (let i = string0.length - 1; i >= 0; i--) {\n    if (string0[i] === ']') {\n      closeBrackets++;\n    } else if (string0[i] === '[') {\n      openBrackets++;\n    }\n\n    // If the number of remaining opening brackets is less than or equal to the number of closing brackets, then we have found a valid subsequence with nested brackets.\n    if (remainingOpenBrackets <= closeBrackets - openBrackets) {\n      return true;\n    }\n  }\n\n  // If we have iterated through the entire string without finding any nested sequences, then the input does not contain nested brackets.\n  return false;\n}"}
{"task_id": "HumanEval_typescript/133", "language": "typescript", "completion": "import * as math from 'mathjs';\n\nconst sum_squares = (lst: Array<number>): number => {\n  let result = 0;\n  for (let i = 0; i < lst.length; i++) {\n    const ceiledElement = Math.ceil(lst[i]); // Round each element up to the nearest integer\n    result += math.pow(ceiledElement, 2); // Square and add to the result\n  }\n  return result;\n};"}
{"task_id": "HumanEval_typescript/134", "language": "typescript", "completion": "function check_if_last_char_is_a_letter(txt: string): boolean {\n  const regex = /\\s/; // regular expression to match space characters\n  if (regex.test(txt[txt.length - 1])) return false; // if the last character is a space, it's not a letter\n  const codePointAtLastIndex: number | undefined = txt.codePointAt(txt.length - 1);\n  return (\n    typeof codePointAtLastIndex === \"number\" &&\n    (codePointAtLastIndex >= 0x41 && codePointAtLastIndex <= 0x5A) || // uppercase letters A-Z\n    (codePointAtLastIndex >= 0x61 && codePointAtLastIndex <= 0x7A) // lowercase letters a-z\n  );\n}"}
{"task_id": "HumanEval_typescript/135", "language": "typescript", "completion": "const can_arrange = (arr: number[]): number => {\n  for (let i = arr.length - 1; i >= 0; i--) {\n    if (i === 0 || arr[i] <= arr[i - 1]) {\n      return i;\n    }\n  }\n  return -1;\n};"}
{"task_id": "HumanEval_typescript/136", "language": "typescript", "completion": "const largest_smallest_integers = function (lst: number[]): [number | null, number | null] {\n  let largestNegative: number | null = null;\n  let smallestPositive: number | null = null;\n\n  for (let i = 0; i < lst.length; i++) {\n    const currentNumber = lst[i];\n\n    if (currentNumber > 0) {\n      if (smallestPositive === null || currentNumber < smallestPositive) {\n        smallestPositive = currentNumber;\n      }\n    } else if (currentNumber < 0) {\n      if (largestNegative === null || currentNumber > largestNegative) {\n        largestNegative = currentNumber;\n      }\n    }\n  }\n\n  return [largestNegative, smallestPositive];\n};"}
{"task_id": "HumanEval_typescript/137", "language": "typescript", "completion": "function compare_one(a: any, b: any): string | number | null {\n  // Convert strings representing numbers to floating point numbers\n  const floatA = typeof a === 'string' ? parseFloat(a.replace(\",\", \".\")) : a;\n  const floatB = typeof b === 'string' ? parseFloat(b.replace(\",\", \".\")) : b;\n\n  if (floatA > floatB) {\n    return floatA;\n  } else if (floatA < floatB) {\n    return floatB;\n  } else {\n    return null; // Both numbers are equal\n  }\n}"}
{"task_id": "HumanEval_typescript/138", "language": "typescript", "completion": "const is_equal_to_sum_even = (n: number): boolean => {\n  const candidates = Array.from({ length: n }, (_, i) => i * 2);\n  let result;\n\n  const backtrack = (remaining: number, selected: number[]) => {\n    if (selected.length === 4 && remaining === 0) {\n      return true;\n    }\n\n    for (let i = candidates.length - 1; i >= 0 && remaining > 0; --i) {\n      const candidate = candidates[i];\n\n      if (remaining < candidate) {\n        break;\n      }\n\n      selected.push(candidate);\n      result = backtrack(remaining - candidate, selected);\n\n      if (result) {\n        return true;\n      }\n\n      selected.pop();\n    }\n\n    return false;\n  };\n\n  return backtrack(n, []);\n};"}
{"task_id": "HumanEval_typescript/139", "language": "typescript", "completion": "function specialFactorial(n: number): number {\n  if (n <= 0) {\n    throw new Error('Input must be a positive integer');\n  }\n\n  let result = 1;\n  for (let i = n; i > 1; i--) {\n    result *= i;\n  }\n  return result * factorial(n - 1);\n}\n\nfunction factorial(n: number): number {\n  if (n <= 0) {\n    return 1;\n  }\n  return n * factorial(n - 1);\n}"}
{"task_id": "HumanEval_typescript/140", "language": "typescript", "completion": "function fixSpaces(text: string): string {\n  let result = text.replace(/ /g, '_'); // Replace all spaces with underscores\n\n  // Check if there are more than two consecutive underscores and replace them with a hyphen\n  while (result.includes('___')) {\n    result = result.replace(/__/g, '-');\n  }\n\n  return result;\n}"}
{"task_id": "HumanEval_typescript/141", "language": "typescript", "completion": "const file_name_check = (file_name: string): string => {\n  const regexPattern = /^[a-zA-Z][a-zA-Z0-9_.]*\\.[txt|exe|dll]$/;\n  return regexPattern.test(file_name) ? 'Yes' : 'No';\n};"}
{"task_id": "HumanEval_typescript/142", "language": "typescript", "completion": "const sum_squares = (lst: Array<number>): number => {\n    let total = 0;\n    for (let i = 0; i < lst.length; i++) {\n        total += Math.pow(lst[i], 2);\n    }\n    return total;\n};"}
{"task_id": "HumanEval_typescript/143", "language": "typescript", "completion": "function wordsInSentence(sentence: string): string {\n  const words = sentence.split(' ');\n  const primeWords: string[] = [];\n\n  // Function to check if a number is prime\n  function isPrime(num: number) {\n    if (num < 2) return false;\n    for (let i = 2; i <= Math.sqrt(num); i++) {\n      if (num % i === 0) return false;\n    }\n    return true;\n  }\n\n  for (const word of words) {\n    if (word.length > 0 && isPrime(word.length)) {\n      primeWords.push(word);\n    }\n  }\n\n  // Join the prime words with a space\n  return primeWords.join(' ');\n}"}
{"task_id": "HumanEval_typescript/144", "language": "typescript", "completion": "function gcd(a: number, b: number): number {\n    if (b === 0) return a;\n    return gcd(b, a % b);\n}\n\nconst simplify = function (x: string, n: string): boolean {\n    const regex = /^(\\d+)/;\n    const numX = parseInt(regex.exec(x)[1]);\n    const denomX = parseInt(x.split('/')[1]);\n    const numN = parseInt(regex.exec(n)[1]);\n    const denomN = parseInt(n.split('/')[1]);\n\n    // Multiply the numerators and denominators to get the resulting numerator and denominator.\n    const numResult = numX * numN;\n    const denomResult = denomX * denomN;\n\n    // Simplify the fraction by finding the greatest common divisor (GCD) of the new numerator and denominator, if possible.\n    if (denomResult > 1) {\n        const gcdVal = gcd(numResult, denomResult);\n        return simplify(`${numResult / gcdVal}/${denomResult / gcdVal}`, '1');\n    } else {\n        // Compare the resulting numerator and denominator with 1: if they are equal to 1, return true; otherwise, return false.\n        return numResult === 1 && denomResult === 1;\n    }\n};"}
{"task_id": "HumanEval_typescript/145", "language": "typescript", "completion": "const order_by_points = (nums: number[]): number[] => {\n  const compare = (a: number, b: number): number => {\n    const sumA = numSum(Math.abs(a)); // Make sure to take absolute value to ensure it's positive before calculating the sum of digits\n    const sumB = numSum(Math.abs(b));\n\n    if (sumA !== sumB) return sumA - sumB;\n\n    return a - b;\n  };\n\n  function numSum(num: number): number {\n    let total = 0;\n    const strNum = num.toString();\n    for (const digit of strNum) total += parseInt(digit, 10);\n    return total;\n  }\n\n  // Sort the numbers using custom compare function\n  return nums.slice().sort(compare);\n};"}
{"task_id": "HumanEval_typescript/146", "language": "typescript", "completion": "function specialFilter(nums: number[]): number {\n  let count = 0;\n\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] > 10) {\n      const numStr = nums[i].toString();\n      const firstDigit = parseInt(numStr.charAt(0));\n      const lastDigit = parseInt(numStr.charAt(numStr.length - 1));\n\n      if ((firstDigit === 3 || firstDigit === 5 || firstDigit === 7) && (lastDigit === 3 || lastDigit === 5 || lastDigit === 7)) {\n        count++;\n      }\n    }\n  }\n\n  return count;\n}"}
{"task_id": "HumanEval_typescript/147", "language": "typescript", "completion": "function get_max_triples(n: number): number {\n  const arr = Array(n).fill(0).map((_, i) => i * i - i + 1);\n  let count = 0;\n\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = i + 1; j < arr.length; j++) {\n      for (let k = j + 1; k < arr.length; k++) {\n        const sum = arr[i] + arr[j] + arr[k];\n        if (sum % 3 === 0) {\n          count++;\n          break; // break the inner loops once we find a triple that meets the condition\n        }\n      }\n    }\n  }\n\n  return count;\n}"}
{"task_id": "HumanEval_typescript/148", "language": "typescript", "completion": "const planetsOrderedByProximity = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune'];\n\nif (!planetsOrderedByProximity.includes(planet1) || !planetsOrderedByProximity.includes(planet2)) {\nreturn [];\n}\n\nconst index1 = planetsOrderedByProximity.indexOf(planet1);\nconst index2 = planetsOrderedByProximity.indexOf(planet2);\n\nif (index1 > index2) {\nconst temp = planet1;\nplanet1 = planet2;\nplanet2 = temp;\n}\n\nlet result: Array<string> = [];\nfor (let i = index1 + 1; i < index2; i++) {\nresult.push(planetsOrderedByProximity[i]);\n}\nreturn result;\n};\n\nThis TypeScript function `bf` takes two planet names as strings and returns an array of planet names between the orbits of those planets, sorted by proximity to the sun. If either input is not a valid planet name, it will return an empty array. The function first checks if both inputs are valid planet names and if not, returns an empty array. Then it finds the indices of the input planets in the ordered array of planets (closest to the Sun first). If the index of the second planet is smaller than the first, it swaps them. After that, it iterates from the index of the first planet plus one to the index of the second planet and pushes each found planet into the result array. Finally, it returns the sorted array of planets between the orbits of the input planets."}
{"task_id": "HumanEval_typescript/149", "language": "typescript", "completion": "function sortedList(lst: Array<string>): Array<string> {\n  // Filter out strings with odd lengths\n  const filteredLst = lst.filter((str) => str.length % 2 === 0);\n\n  // Sort the array by length of each word (ascending),\n  // and if two words have the same length, sort them alphabetically\n  filteredLst.sort((a, b) => {\n    if (a.length < b.length) return -1;\n    if (a.length > b.length) return 1;\n\n    // If lengths are equal, compare the words lexicographically (alphabetically)\n    return a.localeCompare(b);\n  });\n\n  return filteredLst;\n}"}
{"task_id": "HumanEval_typescript/150", "language": "typescript", "completion": "function isPrime(number: number): boolean {\n    if (number < 2) return false;\n\n    for (let i = 2; i <= Math.sqrt(number); i++) {\n        if (number % i === 0) return false;\n    }\n\n    return true;\n}\n\nfunction xOrY(n: number, x: number, y: number): number {\n    const isPrimeNumber = isPrime(n);\n\n    if (isPrimeNumber) {\n        return x;\n    } else {\n        return y;\n    }\n}"}
{"task_id": "HumanEval_typescript/151", "language": "typescript", "completion": "function doubleTheDifference(lst: number[]): number {\n  let sumOfSquares = 0;\n\n  for (let i = 0; i < lst.length; i++) {\n    const num = lst[i];\n\n    // Check if the number is odd, non-negative, and an integer\n    if (num % 2 !== 1 || num < 0 || !Number.isInteger(num)) continue;\n\n    sumOfSquares += Math.pow(num, 2);\n  }\n\n  return sumOfSquares * 2;\n}"}
{"task_id": "HumanEval_typescript/152", "language": "typescript", "completion": "function compare(game: number[], guess: number[]): number[] {\n  const result: number[] = [];\n  for (let i = 0; i < game.length; i++) {\n    const difference = Math.abs(game[i] - guess[i]);\n    result.push(difference);\n  }\n  return result;\n}"}
{"task_id": "HumanEval_typescript/153", "language": "typescript", "completion": "const Strongest_Extension = (className: string, extensions: string[]): string => {\n  const extensionStrengths = extensions.map(ext => ext.length > 1 ? ext.toLowerCase().split('').reduce((upper, lower) => upper - (lower.toUpperCase() === lower ? 1 : 0), 0) : -Infinity);\n  const strongestExtensions = extensionStrengths.filter(strength => strength !== -Infinity).sort((a, b) => a > b ? 1 : -1);\n\n  return className + (strongestExtensions.length > 0 ? '.' + extensions[extensions.findIndex(extension => strongestExtensions.includes(extensionStrengths[strongestExtensions.length - 1]))] : '');\n};"}
{"task_id": "HumanEval_typescript/154", "language": "typescript", "completion": "const cycpattern_check = (a: string, b: string): boolean => {\n  // Check if b is already a substring of a\n  const indexOfB = a.indexOf(b);\n  if (indexOfB !== -1) return true;\n\n  // Iterate over all possible rotations of b and check if any is a substring of a\n  for (let i = 0; i < b.length; i++) {\n    const rotation = b.slice(i) + b.substring(0, i);\n    const indexOfRotation = a.indexOf(rotation);\n    if (indexOfRotation !== -1) return true;\n  }\n\n  // If no matches found, return false\n  return false;\n};"}
{"task_id": "HumanEval_typescript/155", "language": "typescript", "completion": "const even_odd_count = function (num: number): [number, number] {\n  let evenCount = 0;\n  let oddCount = 0;\n\n  const absNum = Math.abs(num);\n\n  // Iterate through the digits of the absolute value of num\n  while (absNum > 0) {\n    const remainder = absNum % 10;\n\n    // Increment corresponding counter based on digit's parity\n    if (remainder === 0 || remainder === 2 || remainder === 4 || remainder === 6 || remainder === 8) {\n      evenCount++;\n    } else {\n      oddCount++;\n    }\n\n    // Remove the least significant digit from absNum\n    absNum = Math.floor(absNum / 10);\n  }\n\n  return [evenCount, oddCount];\n};"}
{"task_id": "HumanEval_typescript/156", "language": "typescript", "completion": "const int_to_mini_roman = (number0: number): string => {\n  const romanNumerals = ['I', 'IV', 'V', 'IX', 'X', 'XL', 'L', 'XC', 'C', 'CD', 'D', 'CM', 'M'];\n  const numbers = [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000];\n  let result = '';\n\n  for (let i = numbers.length - 1; i >= 0; i--) {\n    const currentNumber = numbers[i];\n\n    if (number0 - currentNumber >= 0) {\n      number0 -= currentNumber;\n      result += romanNumerals[i] * Math.floor(number0 / currentNumber);\n      number0 %= currentNumber;\n    }\n  }\n\n  return result;\n};"}
{"task_id": "HumanEval_typescript/157", "language": "typescript", "completion": "const right_angle_triangle = function (a: number, b: number, c: number): boolean {\n  const hypotenuseSquare = a * a + b * b;\n  return hypotenuseSquare === c * c || hypotenuseSquare === c * c - (2 * c * c); // account for potential floating point errors\n};"}
{"task_id": "HumanEval_typescript/158", "language": "typescript", "completion": "function find_max(words: string[]): string {\n  let maxCount = 0;\n  let result: string | null = null;\n\n  // Iterate through each word and calculate its unique character count\n  for (const word of words) {\n    const charCountMap: { [char: string]: number } = {};\n    let uniqueCharCount = 0;\n\n    // Count the unique characters in the current word\n    for (let i = 0; i < word.length; ++i) {\n      if (!charCountMap[word[i]]) {\n        charCountMap[word[i]] = 1;\n        uniqueCharCount++;\n      }\n    }\n\n    // If the current word has more unique characters than the maximum so far, update the result\n    if (uniqueCharCount > maxCount) {\n      maxCount = uniqueCharCount;\n      result = word;\n    }\n  }\n\n  return result as string; // TypeScript assertion to ensure that 'result' is a string\n}"}
{"task_id": "HumanEval_typescript/159", "language": "typescript", "completion": "const eat = (number0: number, need: number, remaining: number): [number, number] => {\n  let totalEaten = number0 + remaining;\n\n  if (totalEaten >= need) {\n    return [totalEaten, need - totalEaten];\n  } else {\n    return [totalEaten, 0];\n  }\n};"}
{"task_id": "HumanEval_typescript/160", "language": "typescript", "completion": "function do_algebra(operator: string[], operand: number[]): number {\n  if (operand.length === 1) return operand[0]; // Base case for a single operand\n\n  const lastOperator = operator.pop(); // Remove the last operator from the list\n  let sum = do_algebra(operator, operand.slice(1)); // Recursively calculate the rest of the expression\n\n  switch (lastOperator) {\n    case '+':\n      return sum + operand[0];\n    case '-':\n      return sum - operand[0];\n    case '*':\n      return sum * operand[0];\n    case '//': // Floor division\n      return Math.floor(sum / operand[0]);\n    case '**':\n      return sum ** operand[0];\n  }\n}"}
{"task_id": "HumanEval_typescript/161", "language": "typescript", "completion": "function solve(s: string): string {\n  let result = '';\n  for (let i = 0; i < s.length; i++) {\n    const charCode = s[i].charCodeAt(0);\n    if ((charCode >= 97 && charCode <= 122) || // lowercase letters\n        (charCode >= 65 && charCode <= 90)) { // uppercase letters\n      result += String.fromCharCode((charCode < 97 ? 65 : 97) + (charCode > 122 ? 32 : 0) ^ (charCode < 97 ? 32 : 0));\n    } else {\n      result += s[i];\n    }\n  }\n\n  // If the string contains no letters, return the reversed string\n  if (!/[a-zA-Z]/.test(s)) {\n    return s.split('').reverse().join('');\n  }\n\n  return result;\n}"}
{"task_id": "HumanEval_typescript/162", "language": "typescript", "completion": "\"devDependencies\": {\n  \"crypto\": \"^1.0.1\"\n}"}
{"task_id": "HumanEval_typescript/163", "language": "typescript", "completion": "function generate_integers(a: number, b: number): number[] {\n  const result: number[] = [];\n\n  // Find the smallest and largest even numbers in the given range\n  let minEven = Math.min(...evenNumbersBetween(a, b));\n  let maxEven = Math.max(...evenNumbersBetween(a, b));\n\n  // Generate an array of all even numbers between minEven and maxEven (inclusive)\n  for (let i = Math.floor(minEven); i <= maxEven; i += 2) {\n    result.push(i);\n  }\n\n  return result;\n}\n\nfunction evenNumbersBetween(start: number, end: number): number[] {\n  const result: number[] = [];\n\n  // Generate an array of all numbers between start and end (inclusive)\n  for (let i = start; i <= end; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    }\n  }\n\n  return result;\n}"}
