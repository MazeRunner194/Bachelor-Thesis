{"task_id": "java/0", "language": "java", "completion": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\n\nclass BelowZero {\n    /**\n     * \n     * Sie erhalten eine Liste von Einzahlungs- und Abhebungsvorg\u00e4ngen auf einem Bankkonto, das mit einem Nullsaldo beginnt. Ihre Aufgabe besteht darin, festzustellen, ob zu irgendeinem Zeitpunkt das Guthaben des Kontos unter Null f\u00e4llt, und an diesem Punkt sollte die Funktion True zur\u00fcckgeben. Andernfalls sollte sie False zur\u00fcckgeben.\n     * >>> below_zero([1, 2, 3])\n     * False\n     * >>> below_zero([1, 2, -4, 5])\n     * True\n     *\n     */\n    public static Boolean belowZero(List<Object> operations) {"}
{"task_id": "java/1", "language": "java", "completion": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\n\nclass SumProduct {\n    /**\n     * \n     * F\u00fcr eine gegebene Liste von ganzen Zahlen soll ein Tupel zur\u00fcckgegeben werden, das aus der Summe und dem Produkt aller Zahlen in der Liste besteht.\n     * Eine leere Summe soll gleich 0 und ein leeres Produkt gleich 1 sein.\n     * >>> sum_product([])\n     * (0, 1)\n     * >>> sum_product([1, 2, 3, 4])\n     * (10, 24)\n     *\n     */\n    public static List<Integer> sumProduct(List<Object> numbers) {"}
{"task_id": "java/2", "language": "java", "completion": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\n\nclass StringXor {\n    /**\n     * \n     * Die Eingabe sind zwei Zeichenketten a und b, die nur aus 1en und 0en bestehen.\n     * F\u00fchren Sie eine bin\u00e4re XOR-Operation auf diesen Eingaben aus und geben Sie das Ergebnis ebenfalls als Zeichenkette zur\u00fcck.\n     * >>> string_xor('010', '110')\n     * '100'\n     *\n     */\n    public static String stringXor(String a, String b) {\n        StringBuilder xor = new StringBuilder();\n\n        if (a.length() > b.length()) {\n            for (int i=b.length(); i<a.length(); i++) {\n                xor.append(\"0\");\n            }\n        } else if (a.length() < b.length()) {\n            for (int i=a.length(); i<b.length(); i++) {\n                xor.append(\"0\");\n            }\n        }\n\n        for (int i = 0; i < a.length(); i++) {\n            int x = Integer.parseInt(String.valueOf(a.charAt(i)));\n            int y = Integer.parseInt(String.valueOf(b.charAt(i)));\n            if ((x ^ y) == 1) xor.append(\"1\");\n            else xor.append(\"0\");\n        }\n\n        return xor.toString();\n    }\n\n    public static void main(String[] args) {\n        System.out.println(stringXor(\"010\", \"110\"));\n        System.out.println(stringXor(\"1010\", \"0\"));\n        System.out.println(stringXor(\"1100110\", \"1011110\"));\n    }\n}"}
{"task_id": "java/3", "language": "java", "completion": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\n\nclass Longest {\n    /**\n     * \n     * Aus einer Liste von Zeichenketten soll die l\u00e4ngste zur\u00fcckgegeben werden. Im Falle von mehreren Zeichenketten mit gleicher L\u00e4nge soll die erste zur\u00fcckgegeben werden. Falls die Eingabeliste leer ist, soll null zur\u00fcckgegeben werden.\n     * >>> longest([])\n\n     * >>> longest(['a', 'b', 'c'])\n     * 'a'\n     * >>> longest(['a', 'bb', 'ccc'])\n     * 'ccc'\n     *\n     */\n    public static String longest(List<Object> strings) {\n        if (strings.size() == 0) {\n            return null;\n        }\n        \n        int maxLength = -1;\n        String longestString = \"\";\n        \n        for (int i = 0; i < strings.size(); i++) {\n            String currentString = strings.get(i);\n            \n            if (currentString.length() > maxLength) {\n                maxLength = currentString.length();\n                longestString = currentString;\n            }\n        }\n        \n        return longestString;\n    }\n}"}
{"task_id": "java/4", "language": "java", "completion": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\n\nclass GreatestCommonDivisor {\n    /**\n     * \n     * Gib den gr\u00f6\u00dften gemeinsamen Teiler von zwei ganzen Zahlen a und b zur\u00fcck.\n     * >>> greatest_common_divisor(3, 5)\n     * 1\n     * >>> greatest_common_divisor(25, 15)\n     * 5\n     *\n     */\n    public static int greatestCommonDivisor(int a, int b) {\n        if (b == 0) return a;\n        else return greatestCommonDivisor(b, a % b);\n    }\n}"}
{"task_id": "java/5", "language": "java", "completion": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\n\nclass SortNumbers {\n    /**\n     * \n     * Die Eingabe ist ein durch Leerzeichen getrennter String von Ziffern von 'null' bis 'neun'.\n     *     G\u00fcltige Optionen sind 'null', 'eins', 'zwei', 'drei', 'vier', 'f\u00fcnf', 'sechs', 'sieben', 'acht' und 'neun'.\n     *     Gib den String mit den Zahlen sortiert von klein nach gro\u00df zur\u00fcck.\n     * >>> sort_numbers('three one five')\n     * 'one three five'\n     *\n     */\n    public static String sortNumbers(String numbers) {"}
{"task_id": "java/6", "language": "java", "completion": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\n\nclass RescaleToUnit {\n    /**\n     * \n     * Gegeben sei eine Liste von Zahlen (mit mindestens zwei Elementen). Wenden Sie eine lineare Transformation auf diese Liste an, so dass die kleinste Zahl zu 0 und die gr\u00f6\u00dfte zu 1 wird.\n     * >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n     * [0.0, 0.25, 0.5, 0.75, 1.0]\n     *\n     */\n    public static List<Double> rescaleToUnit(List<Double> numbers) {\n        double min = Collections.min(numbers);\n        double max = Collections.max(numbers);\n        return new ArrayList<Double>(\n            Arrays.asList(\n                Arrays.stream(numbers.toArray())\n                      .mapToDouble(d -> (d - min)/(max - min))\n                      .boxed()\n                      .collect(Collectors.toList())\n            )\n        );\n    }\n\n    public static void main(String[] args) {\n        List<Double> numbers = Arrays.asList(1.0, 2.0, 3.0, 4.0, 5.0);\n        System.out.println(rescaleToUnit(numbers));\n    }\n}"}
{"task_id": "java/7", "language": "java", "completion": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\n\nclass FlipCase {\n    /**\n     * \n     * F\u00fcr einen gegebenen String, tausche Kleinbuchstaben in Gro\u00dfbuchstaben und Gro\u00dfbuchstaben in Kleinbuchstaben um.\n     * >>> flip_case('Hello')\n     * 'hELLO'\n     *\n     */\n    public static String flipCase(String string) {\n        char[] alphabet = \"abcdefghijklmnopqrstuvwxyz\".toCharArray();\n        for (int i = 0; i < alphabet.length; i++) {\n            char current = alphabet[i];\n            char upper = Character.toUpperCase(current);\n            char lower = Character.toLowerCase(current);\n            \n            // Replace all occurrences of the uppercase character in the string with the lowercase character and vice versa.\n            string = string.replace(upper, lower);\n            string = string.replace(lower, upper);\n        }\n        \n        return string;\n    }\n}"}
{"task_id": "java/8", "language": "java", "completion": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\n\nclass GetPositive {\n    /**\n     * \n     * Gib nur positive Zahlen in der Liste zur\u00fcck.\n     * >>> get_positive([-1, 2, -4, 5, 6])\n     * [2, 5, 6]\n     * >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n     * [5, 3, 2, 3, 9, 123, 1]\n     *\n     */\n    public static List<Object> getPositive(List<Object> l) {"}
{"task_id": "java/9", "language": "java", "completion": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\n\nclass IsPrime {\n    /**\n     * \n     * Gib \"true\" zur\u00fcck, wenn eine gegebene Zahl eine Primzahl ist, andernfalls gib \"false\" zur\u00fcck.\n     * >>> is_prime(6)\n     * False\n     * >>> is_prime(101)\n     * True\n     * >>> is_prime(11)\n     * True\n     * >>> is_prime(13441)\n     * True\n     * >>> is_prime(61)\n     * True\n     * >>> is_prime(4)\n     * False\n     * >>> is_prime(1)\n     * False\n     *\n     */\n    public static Boolean isPrime(int n) {\n        \n        if (n <= 1) {\n            return false;\n        } else if (n == 2) {\n            return true;\n        } else if (n % 2 == 0) {\n            return false;\n        }\n        \n        int boundary = Math.round((float)(Math.sqrt(n)));\n\n        for (int i=3;i<=boundary;i+=2){\n            if (n%i==0) {\n                return false;\n            }\n        }\n        return true;\n    }\n}"}
{"task_id": "java/10", "language": "java", "completion": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\n\nclass Unique {\n    /**\n     * \n     * Gib sortierte eindeutige Elemente in einer Liste zur\u00fcck.\n     * >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n     * [0, 2, 3, 5, 9, 123]\n     *\n     */\n    public static List<Integer> unique(List<Integer> l) {\n        // TODO: Implement here\n        List<Integer> u = new ArrayList<Integer>();\n        for (int i=0; i <l.size(); i++) {\n            if (!u.contains(l.get(i)))\n                u.add(l.get(i));\n\n        }\n        return u;\n    }\n}"}
{"task_id": "java/11", "language": "java", "completion": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\n\nclass PrimeFib {\n    /**\n     * * \n     * prime_fib gibt die n-te Zahl zur\u00fcck, die sowohl eine Fibonacci-Zahl als auch eine Primzahl ist.\n     * >>> prime_fib(1)\n     * 2\n     * >>> prime_fib(2)\n     * 3\n     * >>> prime_fib(3)\n     * 5\n     * >>> prime_fib(4)\n     * 13\n     * >>> prime_fib(5)\n     * 89\n     *\n     */\n    public static int primeFib(int n) {\n        return 0;\n    }\n}"}
{"task_id": "java/12", "language": "java", "completion": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\n\nclass TriplesSumToZero {\n    /**\n     * triples_sum_to_zero nimmt eine Liste von ganzen Zahlen als Eingabe.\n     * Es gibt True zur\u00fcck, wenn es drei verschiedene Elemente in der Liste gibt, die zu Null addieren, andernfalls gibt es False zur\u00fcck.\n     * >>> triples_sum_to_zero([1, 3, 5, 0])\n     * False\n     * >>> triples_sum_to_zero([1, 3, -2, 1])\n     * True\n     * >>> triples_sum_to_zero([1, 2, 3, 7])\n     * False\n     * >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n     * True\n     * >>> triples_sum_to_zero([1])\n     * False\n     *\n     */\n    public static Boolean triplesSumToZero(List<Integer> l) {\n        for (int i=0; i < l.size(); ++i){\n            for (int j = 0; j < l.size(); ++j){\n                for (int k = 0; k < l.size(); ++k){\n                    if (l.get(i)+l.get(j)+l.get(k) == 0 && i != j && j != k && i != k){\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n}"}
{"task_id": "java/13", "language": "java", "completion": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\n\nclass PairsSumToZero {\n    /**\n     * pairs_sum_to_zero nimmt eine Liste von ganzen Zahlen als Eingabe.\n     * Es gibt True zur\u00fcck, wenn es zwei unterschiedliche Elemente in der Liste gibt, die sich zu Null addieren, andernfalls gibt es False zur\u00fcck.\n     * >>> pairs_sum_to_zero([1, 3, 5, 0])\n     * False\n     * >>> pairs_sum_to_zero([1, 3, -2, 1])\n     * False\n     * >>> pairs_sum_to_zero([1, 2, 3, 7])\n     * False\n     * >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n     * True\n     * >>> pairs_sum_to_zero([1])\n     * False\n     *\n     */\n    public static Boolean pairsSumToZero(List<Integer> l) {\n        for (int i=0;i<l.size();i++){\n            for (int j=0;j<l.size();j++){\n                if (i != j){\n                    int value = l.get(i)+l.get(j);\n                    if (value == 0){\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n\n    }\n}"}
{"task_id": "java/14", "language": "java", "completion": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\n\nclass Fib4 {\n    /**\n     * \n     * Die Fib4-Zahlenfolge ist eine Folge \u00e4hnlich der Fibonacci-Folge, die wie folgt definiert ist:\n     *     fib4(0) -> 0\n     *     fib4(1) -> 0\n     *     fib4(2) -> 2\n     *     fib4(3) -> 0\n     *     fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n     *     Bitte schreiben Sie eine Funktion, um das n-te Element der Fib4-Zahlenfolge effizient zu berechnen. Verwenden Sie keine Rekursion.\n     * >>> fib4(5)\n     * 4\n     * >>> fib4(6)\n     * 8\n     * >>> fib4(7)\n     * 14\n     *\n     */\n    public static int fib4(int n) {\n        if (n == 0)\n            return 0;\n        if (n == 1 || n == 2 || n == 3)\n            return 0;\n        if (n == 4)\n            return 2;\n        int a = 0;\n        int b = 0;\n        int c = 2;\n        for (int i=5; i<=n; ++i) {\n            int d = a+b+c;\n            a=b;\n            b=c;\n            c=d;\n        }\n        return c;\n    }\n    \n    public static void main(String[] args){\n        System.out.println(fib4(Integer.parseInt(args[0])));\n    }\n}"}
{"task_id": "java/15", "language": "java", "completion": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\n\nclass Median {\n    /**\n     * \n     * Gib den Median der Elemente in der Liste l zur\u00fcck.\n     * >>> median([3, 1, 2, 4, 5])\n     * 3\n     * >>> median([-10, 4, 6, 1000, 10, 20])\n     * 15.0\n     *\n     */\n    public static Number median(List<Integer> l) {"}
{"task_id": "java/16", "language": "java", "completion": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\n\nclass IsPalindrome {\n    /**\n     * \u00dcberpr\u00fcft, ob der gegebene String ein Palindrom ist.\n     * >>> is_palindrome('')\n     * True\n     * >>> is_palindrome('aba')\n     * True\n     * >>> is_palindrome('aaaaa')\n     * True\n     * >>> is_palindrome('zbcd')\n     * False\n     */\n    public static Boolean isPalindrome(String text) {"}
{"task_id": "java/17", "language": "java", "completion": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\n\nclass RemoveVowels {\n    /**\n     * * \n     * remove_vowels ist eine Funktion, die einen String entgegennimmt und einen String ohne Vokale zur\u00fcckgibt.\n     * >>> remove_vowels('')\n     * ''\n     * >>> remove_vowels(\"abcdef\\nghijklm\")\n     * 'bcdf\\nghjklm'\n     * >>> remove_vowels('abcdef')\n     * 'bcdf'\n     * >>> remove_vowels('aaaaa')\n     * ''\n     * >>> remove_vowels('aaBAA')\n     * 'B'\n     * >>> remove_vowels('zbcd')\n     * 'zbcd'\n     */\n    public static String removeVowels(String text) {"}
{"task_id": "java/18", "language": "java", "completion": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\n\nclass BelowThreshold {\n    /**\n     * \n     * Gib True zur\u00fcck, wenn alle Zahlen in der Liste l unterhalb des Schwellenwerts t liegen.\n     * >>> below_threshold([1, 2, 4, 10], 100)\n     * True\n     * >>> below_threshold([1, 20, 4, 10], 5)\n     * False\n     *\n     */\n    public static Boolean belowThreshold(List<Integer> l, int t) {\n        for (int x: l) {\n            if (x >= t)\n                return false;\n        }\n        \n        return true;\n    }\n\n    public static void main(String[] args) {\n        // write some code to test your function\n        List<Integer> list = Arrays.asList(1, 2, 4, 10);\n        System.out.println(belowThreshold(list, 100));\n    }\n}"}
{"task_id": "java/19", "language": "java", "completion": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\n\nclass Add {\n    /**\n     * \n     * Addiere zwei Zahlen x und y.\n     * >>> add(2, 3)\n     * 5\n     * >>> add(5, 7)\n     * 12\n     *\n     */\n    public static int add(int x, int y) {\n        return x + y;\n    }\n}"}
{"task_id": "java/20", "language": "java", "completion": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\n\nclass SameChars {\n    /**\n     * * \n     * \u00dcberpr\u00fcfen Sie, ob zwei W\u00f6rter dieselben Zeichen enthalten.\n     * >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n     * True\n     * >>> same_chars('abcd', 'dddddddabc')\n     * True\n     * >>> same_chars('dddddddabc', 'abcd')\n     * True\n     * >>> same_chars('eabcd', 'dddddddabc')\n     * False\n     * >>> same_chars('abcd', 'dddddddabce')\n     * False\n     * >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n     * False\n     *\n     */\n    public static Boolean sameChars(String s0, String s1) {\n        // your code here"}
{"task_id": "java/21", "language": "java", "completion": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\n\nclass Fib {\n    /**\n     * \n     * Gib die n-te Fibonacci-Zahl zur\u00fcck.\n     * >>> fib(10)\n     * 55\n     * >>> fib(1)\n     * 1\n     * >>> fib(8)\n     * 21\n     *\n     */\n    public static int fib(int n) {\n        if (n == 0)\n            return 0;\n\n        // recursive implementation, because it is more clear than the iterative one below:\n        /*if (n == 1 || n == 2) {\n            return 1;\n        } else {\n            return fib(n - 1) + fib(n - 2);\n        */}*/\n\n\n        int a = 0, b = 1, temp = 0;\n\n        for (int i = 3; i <= n; i++) {\n            temp = a;\n            a = b;\n            b += temp;\n        }\n\n        return b;\n    }\n}"}
{"task_id": "java/22", "language": "java", "completion": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\n\nclass Common {\n    /**\n     * \n     * Gib sortierte eindeutige gemeinsame Elemente f\u00fcr zwei Listen zur\u00fcck.\n     * >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n     * [1, 5, 653]\n     * >>> common([5, 3, 2, 8], [3, 2])\n     * [2, 3]\n\n     */\n    public static List<Object> common(List<Integer> l1, List<Object> l2) {"}
{"task_id": "java/23", "language": "java", "completion": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\n\nclass LargestPrimeFactor {\n    /**\n     * \n     * Gib den gr\u00f6\u00dften Primfaktor von n zur\u00fcck. Gehe davon aus, dass n > 1 und keine Primzahl ist.\n     * >>> largest_prime_factor(13195)\n     * 29\n     * >>> largest_prime_factor(2048)\n     * 2\n     *\n     */\n    public static int largestPrimeFactor(int n) {\n        if (n % 2 == 0) return 2;\n\n        for (int i = 3; i <= Math.sqrt(n); i++)\n            if (n % i == 0 && isPrime(i))\n                return i;\n        \n        return n;\n    }\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        System.out.println(largestPrimeFactor(in.nextInt()));\n    }\n\n    private static boolean isPrime(int number) {\n        if (number <= 1)\n            return false;\n        for (int i = 2; i < Math.sqrt(number); i++)\n            if (number % i == 0)\n                return false;\n        return true;\n    }\n}"}
{"task_id": "java/24", "language": "java", "completion": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\n\nclass SumToN {\n    /**\n     * \n     * sum_to_n ist eine Funktion, die Zahlen von 1 bis n summiert.\n     * >>> sum_to_n(30)\n     * 465\n     * >>> sum_to_n(100)\n     * 5050\n     * >>> sum_to_n(5)\n     * 15\n     * >>> sum_to_n(10)\n     * 55\n     * >>> sum_to_n(1)\n     * 1\n     *\n     */\n    public static int sumToN(int n) {\n        return (n * (n+1)) / 2;\n\n    }\n}"}
{"task_id": "java/25", "language": "java", "completion": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\n\nclass Derivative {\n    /**\n     * \n     * xs repr\u00e4sentieren die Koeffizienten eines Polynoms.\n     *     xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     *     Gib die Ableitung dieses Polynoms in derselben Form zur\u00fcck.\n     * >>> derivative([3, 1, 2, 4, 5])\n     * [1, 4, 12, 20]\n     * >>> derivative([1, 2, 3])\n     * [2, 6]\n     *\n     */\n    public static List<Integer> derivative(List<Integer> xs) {"}
{"task_id": "java/26", "language": "java", "completion": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\n\nclass FibFib {\n    /**\n     * \n     * Die FibFib-Zahlenfolge ist eine Folge \u00e4hnlich der Fibonacci-Folge, die wie folgt definiert ist:\n     *     fibfib(0) == 0\n     *     fibfib(1) == 0\n     *     fibfib(2) == 1\n     *     fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n     *     Bitte schreiben Sie eine Funktion, um das n-te Element der FibFib-Zahlenfolge effizient zu berechnen.\n     * >>> fibfib(1)\n     * 0\n     * >>> fibfib(5)\n     * 4\n     * >>> fibfib(8)\n     * 24\n     *\n     */\n    public static int fibfib(int n) {"}
{"task_id": "java/27", "language": "java", "completion": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\n\nclass VowelsCount {\n    /**\n     * \n     * Schreiben Sie eine Funktion vowels_count, die einen String, der ein Wort repr\u00e4sentiert, als Eingabe erh\u00e4lt und die Anzahl der Vokale im String zur\u00fcckgibt. Vokale sind in diesem Fall 'a', 'e', 'i', 'o', 'u'. Hierbei ist 'y' auch ein Vokal, aber nur wenn es am Ende des gegebenen Wortes steht.\n     * \n     * Beispiel:\n     * >>> vowels_count(\"abcde\")\n     * 2\n     * >>> vowels_count(\"ACEDY\")\n     * 3\n     *\n     */\n    public static int vowelsCount(String s) {\n        if (s == null || s.isEmpty()) return 0;\n\n        final StringVOWELS = \"aeiouy\";\n        char[] c = s.toLowerCase().toCharArray();\n        int vowelCount = 0;\n        for (char ch : c) {\n            if (VOWELS.contains(String.valueOf(ch))) {\n                vowelCount++;\n            }\n        }\n        return vowelCount;\n    }\n\n\n    public static void main(String[] args) {\n        String s1 = \"abcde\";\n        int result1 = vowelsCount(s1);\n        System.out.println(\"Result for: '\" + s1 + \"' is: \" + result1);\n        \n        String s2 = \"ACEDY\";\n        int result2 = vowelsCount(s2);\n        System.out.println(\"Result for: '\" + s2 + \"' is: \" + result2);\n    }\n}"}
{"task_id": "java/28", "language": "java", "completion": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\n\nclass Search {\n    /**\n     * Sie erhalten eine nicht-leere Liste von positiven Ganzzahlen. Geben Sie die gr\u00f6\u00dfte Ganzzahl zur\u00fcck, die gr\u00f6\u00dfer als Null ist und eine H\u00e4ufigkeit hat, die gr\u00f6\u00dfer oder gleich dem Wert der Ganzzahl selbst ist. Die H\u00e4ufigkeit einer Ganzzahl ist die Anzahl der Male, die sie in der Liste vorkommt. Wenn kein solcher Wert existiert, geben Sie -1 zur\u00fcck. Beispiele:\n     * \n     *     search([4, 1, 2, 2, 3, 1]) == 2\n     *     search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n     *     search([5, 5, 4, 4, 4]) == -1\n     *\n     */\n    public static int search(List<Integer> lst) {"}
{"task_id": "java/29", "language": "java", "completion": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\n\nclass TriangleArea {\n    /**\n     * * \n     * Gegeben sind die L\u00e4ngen der drei Seiten eines Dreiecks. Gib die Fl\u00e4che des Dreiecks auf 2 Dezimalstellen gerundet zur\u00fcck, wenn die drei Seiten ein g\u00fcltiges Dreieck bilden. Andernfalls gib -1 zur\u00fcck. Drei Seiten bilden ein g\u00fcltiges Dreieck, wenn die Summe von zwei Seiten gr\u00f6\u00dfer ist als die dritte Seite. Beispiel:\n     * \n     * triangle_area(3, 4, 5) == 6.00\n     * triangle_area(1, 2, 10) == -1\n     *\n     */\n    public static Number triangleArea(int a, int b, int c) {\n        double p = (a + b + c) / 2;\n\n        if (p > a && p > b && p > c) {\n            return Math.sqrt(p * (p - a) * (p - b) * (p - c));\n        } else {\n            return -1;\n        }\n    }\n}"}
{"task_id": "java/30", "language": "java", "completion": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\n\nclass WillItFly {\n    /**\n     * * \n     * Schreiben Sie eine Funktion, die True zur\u00fcckgibt, wenn das Objekt q fliegen wird, und False sonst. Das Objekt q wird fliegen, wenn es ausbalanciert ist (es ist eine palindromische Liste) und die Summe seiner Elemente kleiner oder gleich dem maximal m\u00f6glichen Gewicht w ist.\n     * \n     *     Beispiel:\n     *     will_it_fly([1, 2], 5) \u279e False \n     *     # 1+2 ist kleiner als das maximal m\u00f6gliche Gewicht, aber es ist unausgeglichen.\n     * \n     *     will_it_fly([3, 2, 3], 1) \u279e False\n     *     # es ist ausbalanciert, aber 3+2+3 ist mehr als das maximal m\u00f6gliche Gewicht.\n     * \n     *     will_it_fly([3, 2, 3], 9) \u279e True\n     *     # 3+2+3 ist kleiner als das maximal m\u00f6gliche Gewicht, und es ist ausbalanciert.\n     * \n     *     will_it_fly([3], 5) \u279e True\n     *     # 3 ist kleiner als das maximal m\u00f6gliche Gewicht, und es ist ausbalanciert.\n     * \n     * @param q\n     * @param w\n     */\n    public static Boolean willItFly(List<Integer> q, int w) {\n        if (isPalindrome(q) && isSmallerThanMaxWeight(q,w))\n            return true;\n        else \n            return false;\n            \n    }\n\n    private static Boolean isSmallerThanMaxWeight(List<Integer> q, int w){\n        int sum = 0;\n        for(int i=0; i < q.size();i++){\n            if (q.get(i) > w)\n                return false;\n\n            sum += q.get(i);\n        }\n\n        return (sum <= w);\n    }\n\n    private static Boolean isPalindrome(List<Integer> q){\n        int middle = q.size()/2;\n        for(int i=0; i < middle; i++){\n            if (!q.get(i).equals(q.get(q.size()-1-i)))\n                return false;\n        }\n\n        return true;\n    }\n}"}
{"task_id": "java/31", "language": "java", "completion": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\n\nclass IsMultiplyPrime {\n    /**\n     * \n     * Schreiben Sie eine Funktion, die true zur\u00fcckgibt, wenn die gegebene Zahl das Produkt von 3 Primzahlen ist, und false sonst. Dabei ist bekannt, dass (a) kleiner als 100 ist. Beispiel:\n     * \n     * is_multiply_prime(30) == True\n     * 30 = 2 * 3 * 5\n     *\n     */\n    public static Boolean isMultiplyPrime(int a) {\n        for (int i=2; i<a; i++){\n            if (isPrime(i)){\n                int remaining = a/i;\n\n                // check whether remaining number is multiply prime or not\n                for (int j=2; j<remaining; j++){\n                    if (isPrime(j) && remaining%j == 0){\n                        for (int k=2; k<(remaining/j); k++){\n                            if (isPrime(k) && (remaining/(j*k))==1){\n                                return true;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        return false;\n    }\n\n    public static boolean isPrime(int n) {\n        for(int i=2;i<=Math.sqrt(n);i++){\n            if(n%i==0){\n                return false;\n            }\n        }\n        return true;\n    }\n}"}
{"task_id": "java/32", "language": "java", "completion": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\n\nclass DecimalToBinary {\n    /**\n     * \n     * Sie erhalten eine Zahl in Dezimalform und Ihre Aufgabe besteht darin, sie in das Bin\u00e4rformat umzuwandeln. Die Funktion sollte einen String zur\u00fcckgeben, wobei jedes Zeichen eine Bin\u00e4rzahl darstellt. Jedes Zeichen im String wird '0' oder '1' sein.\n     * \n     * Es wird ein zus\u00e4tzliches Paar von Zeichen 'db' am Anfang und am Ende des Strings geben. Die zus\u00e4tzlichen Zeichen dienen zur Formatierungshilfe.\n     * \n     * Beispiele:\n     * \n     * decimal_to_binary(15)   # returns \"db1111db\"\n     * decimal_to_binary(32)   # returns \"db100000db\"\n     *\n     */\n    public static String decimalToBinary(int decimal) {\n        return \"\";\n    }\n}"}
{"task_id": "java/33", "language": "java", "completion": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\n\nclass Isappy {\n    /**\n     * \n     * Du erh\u00e4ltst einen String s.\n     * Deine Aufgabe ist es zu \u00fcberpr\u00fcfen, ob der String gl\u00fccklich ist oder nicht.\n     * Ein String ist gl\u00fccklich, wenn seine L\u00e4nge mindestens 3 betr\u00e4gt und jede Gruppe von 3 aufeinanderfolgenden Buchstaben unterschiedlich ist.\n     * Zum Beispiel:\n     * \n     * is_happy(a) => False\n     * is_happy(aa) => False\n     * is_happy(abcd) => True\n     * is_happy(aabb) => False\n     * is_happy(adb) => True\n     * is_happy(xyy) => False\n     *\n     */\n    public static Boolean isHappy(String s) {"}
{"task_id": "java/34", "language": "java", "completion": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\n\nclass NumericalLetterGrade {\n    /**\n     * \n     * Es ist die letzte Woche des Semesters und der Lehrer muss die Noten an die Sch\u00fcler verteilen. Der Lehrer hat seinen eigenen Algorithmus zur Bewertung entwickelt. Das einzige Problem ist, dass er den Code, den er zur Bewertung verwendet hat, verloren hat. Er hat Ihnen eine Liste von GPAs f\u00fcr einige Sch\u00fcler gegeben und Sie m\u00fcssen eine Funktion schreiben, die eine Liste von Buchstabennoten gem\u00e4\u00df der folgenden Tabelle ausgeben kann:\n     * \n     *              GPA       |    Buchstaben Note\n     *               4.0                A+\n     *             > 3.7                A \n     *             > 3.3                A- \n     *             > 3.0                B+\n     *             > 2.7                B \n     *             > 2.3                B-\n     *             > 2.0                C+\n     *             > 1.7                C\n     *             > 1.3                C-\n     *             > 1.0                D+ \n     *             > 0.7                D \n     *             > 0.0                D-\n     *               0.0                E\n     *     \n     * \n     *     Beispiel:\n     * \n     * grade_equation([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n     *\n     */\n    public static List<String> numericalLetterGrade(List<Number> grades) {\n        // Write your code here\n\n        return null;\n    }\n}"}
{"task_id": "java/35", "language": "java", "completion": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\n\nclass PrimeLength {\n    /**\n     * \n     * Schreiben Sie eine Funktion, die einen String entgegennimmt und True zur\u00fcckgibt, wenn die L\u00e4nge des Strings eine Primzahl ist, andernfalls False.\n     *     Beispiele\n     * \n     * prime_length('Hello') == True\n     * prime_length('abcdcba') == True\n     * prime_length('kittens') == True\n     * prime_length('orange') == False\n     *\n     */\n    public static Boolean primeLength(String string) {\n        int length = string.length();\n        for (int i=2; i<=Math.sqrt(length); i++) {\n            if (length % i == 0) {\n                return false;\n            } \n        }\n        return true;\n    }\n}"}
{"task_id": "java/36", "language": "java", "completion": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\n\nclass Solve {\n    /**\n     * \n     * Gegeben eine positive Ganzzahl N, gib die Gesamtsumme ihrer Ziffern in bin\u00e4rer Form zur\u00fcck.\n     * \n     *     Beispiel\n     *         F\u00fcr N = 1000 ist die Summe der Ziffern 1, die Ausgabe sollte \"1\" sein.\n     *         F\u00fcr N = 150 ist die Summe der Ziffern 6, die Ausgabe sollte \"110\" sein.\n     *         F\u00fcr N = 147 ist die Summe der Ziffern 12, die Ausgabe sollte \"1100\" sein.\n     *     \n     *     Variablen:\n     *         @N Ganzzahl\n     *              Einschr\u00e4nkungen: 0 \u2264 N \u2264 10000.\n     *     Ausgabe:\n     *          eine Zeichenkette mit der bin\u00e4ren Zahl.\n     * \n     *\n     */\n    public static String solve(int n) {\n\n        if (n < 2) return \"\" + n;\n        \n        return solve(n/2) + (n % 2);\n    }\n}"}
{"task_id": "java/37", "language": "java", "completion": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\n\nclass GetRow {\n    /**\n     * * \n     * Sie erhalten eine zweidimensionale Datenstruktur als verschachtelte Listen, die einer Matrix \u00e4hnelt, jedoch k\u00f6nnen im Gegensatz zu Matrizen unterschiedlich viele Spalten in jeder Zeile vorhanden sein. Gegeben sei eine Liste \"lst\" und eine ganze Zahl \"x\". Finden Sie die Zahlen \"x\" in der Liste und geben Sie eine Liste von Tupeln zur\u00fcck, [(x1, y1), (x2, y2) ...], wobei jedes Tupel eine Koordinate (Zeile, Spalte) darstellt, beginnend bei 0. Sortieren Sie die Koordinaten zun\u00e4chst nach Zeilen in aufsteigender Reihenfolge. Sortieren Sie auch die Koordinaten der Zeile nach Spalten in absteigender Reihenfolge.\n     * \n     * Beispiele:\n     * \n     * get_row([\n     *   [1,2,3,4,5,6],\n     *   [1,2,3,4,1,6],\n     *   [1,2,3,4,5,1]\n     * ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n     * get_row([], 1) == []\n     * get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n     * \n     * @param lst die zweidimensionale Liste\n     * @param x das Element, dessen Koordinaten gesucht werden sollen\n     * @return eine Liste von Tupeln [(x1, y1), (x2, y2) ...]\n     */\n    public static List<Object> getRow(List<Object> lst, int x) {"}
{"task_id": "java/38", "language": "java", "completion": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\n\nclass NextSmallest {\n    /**\n     * * \n     * Sie erhalten eine Liste von ganzen Zahlen.\n     * Schreiben Sie eine Funktion next_smallest(), die das zweitkleinste Element der Liste zur\u00fcckgibt.\n     * Geben Sie null zur\u00fcck, wenn es kein solches Element gibt.\n     * next_smallest([1, 2, 3, 4, 5]) == 2\n     * next_smallest([5, 1, 4, 3, 2]) == 2\n     * next_smallest([]) == None\n     * next_smallest([1, 1]) == None\n     *\n     */\n    public static Integer nextSmallest(List<Object> lst) {"}
{"task_id": "java/39", "language": "java", "completion": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\n\nclass IsBored {\n    /**\n     * * \n     * Du bekommst einen String von W\u00f6rtern und deine Aufgabe ist es, die Anzahl der Langeweilen zu z\u00e4hlen. Eine Langeweile ist ein Satz, der mit dem Wort \"Ich\" beginnt. S\u00e4tze werden durch '.', '?' oder '!' begrenzt.\n     * \n     * Zum Beispiel:\n     * >>> is_bored(\"Hello world\")\n     * 0\n     * >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n     * 1\n     *\n     */\n    public static int isBored(String s) {\n        String[] words = s.split(\"\\\\W+\"); // split by non-word characters\n        for (String word : words) {\n            if (word.equals(\"ich\")) {\n                return 1;\n            }\n        }\n        return 0;\n    }\n}"}
{"task_id": "java/40", "language": "java", "completion": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\n\nclass Skjkasdkd {\n    /**\n     * \n     * Sie erhalten eine Liste von ganzen Zahlen.\n     *     Sie m\u00fcssen den gr\u00f6\u00dften Primzahlwert finden und die Summe seiner Ziffern zur\u00fcckgeben.\n     * \n     *     Beispiele:\n     * \n     * For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n     * For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n     * For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n     * For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n     * For lst = [0,81,12,3,1,21] the output should be 3\n     * For lst = [0,8,1,2,1,7] the output should be 7\n     *\n     */\n    public static int skjkasdkd(List<Integer> lst) {\n        List<String> result = new ArrayList<String>();\n        \n        for (int i=0; i < lst.size(); i++) {\n            String temp = String.valueOf(lst.get(i));\n            \n            for (int j=0; j <temp.length(); j++){\n                if (Character.isDigit(temp.charAt(j)))\n                    result.add(String.valueOf(temp.charAt(j)));\n            }\n            \n        }\n        \n        Integer sum = 0;\n        for (int i = 0; i< result.size();i++) {\n            sum += Integer.parseInt(result.get(i));\n        }\n        \n        return sum;\n    }\n}"}
{"task_id": "java/41", "language": "java", "completion": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\n\nclass CheckDictCase {\n    /**\n     * * \n     * Gegeben ein W\u00f6rterbuch, gibt True zur\u00fcck, wenn alle Schl\u00fcssel Strings in Kleinbuchstaben oder alle Schl\u00fcssel Strings in Gro\u00dfbuchstaben sind, sonst gibt es False zur\u00fcck. Die Funktion sollte False zur\u00fcckgeben, wenn das gegebene W\u00f6rterbuch leer ist. Beispiele:\n     * \n     * check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) should return True.\n     * check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n     * check_dict_case({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return False.\n     * check_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n     * check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n     *\n     */\n    public static Boolean checkDictCase(Object dict) {\n        if (dict.isEmpty()) {\n            return false;\n        } else {\n\n        }\n        \n\n    }\n}"}
{"task_id": "java/42", "language": "java", "completion": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\n\nclass ClosestInteger {\n    /**\n     * * \n     * Erstellen Sie eine Funktion, die einen Wert (String) annimmt, der eine Zahl darstellt, und gibt die n\u00e4chstgelegene Ganzzahl zur\u00fcck. Wenn die Zahl gleich weit von zwei Ganzzahlen entfernt ist, runden Sie sie weg von Null.\n     * \n     *     Beispiele\n     * >>> closest_integer(\"10\")\n     * 10\n     * >>> closest_integer(\"15.3\")\n     * 15\n\n     * Note:\n     * Rounding away from zero means that if the given number is equidistant\n     * from two integers, the one you should return is the one that is the\n     * farthest from zero. For example closest_integer(\"14.5\") should\n     * return 15 and closest_integer(\"-14.5\") should return -15.\n     *\n     */\n    public static int closestInteger(String value) {\n        double number = Double.parseDouble(value);\n        int below = Math.round(number);\n        int above = (int)(Math.ceil(number));\n        System.out.println(\"Number: \" + number);\n        \n        if (Math.abs(number - below) < 0.5) {\n            return below;\n        } else {\n            return above;\n        }\n    }\n}"}
{"task_id": "java/43", "language": "java", "completion": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\n\nclass MakeAPile {\n    /**\n     * * \n     * Gegeben eine positive ganze Zahl n, m\u00fcssen Sie einen Haufen von n Ebenen von Steinen machen.\n     *     Die erste Ebene hat n Steine.\n     *     Die Anzahl der Steine in der n\u00e4chsten Ebene ist:\n     *         - die n\u00e4chste ungerade Zahl, wenn n ungerade ist.\n     *         - die n\u00e4chste gerade Zahl, wenn n gerade ist.\n     *     Geben Sie die Anzahl der Steine in jeder Ebene in einer Liste zur\u00fcck, wobei das Element an Index\n     *     i die Anzahl der Steine in der Ebene (i+1) darstellt.\n     * \n     *     Beispiele:\n     * >>> make_a_pile(3)\n     * [3, 5, 7]\n     *\n     */\n    public static List<Integer> makeAPile(int n) {\n        List<Integer> pile = new ArrayList<>();\n        if (n % 2 == 0) {\n            int next = n + 1;\n            while (next >= n) {\n                pile.add(n);\n                n += 2;\n            }\n        } else {\n            int next = n + 2;\n            while (next >= n) {\n                pile.add(n);\n                n += 2;\n            }\n        }\n\n        return pile;\n    }\n}"}
{"task_id": "java/44", "language": "java", "completion": "import java.util.List;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.stream.Collectors;\n\npublic class WordsString {\n    /**\n     * Sie erhalten einen String von W\u00f6rtern, die durch Kommas oder Leerzeichen getrennt sind. Ihre Aufgabe ist es, den String in W\u00f6rter aufzuteilen und ein Array der W\u00f6rter zur\u00fcckzugeben.\n     * \n     * Zum Beispiel:\n     * \n     * words_string(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n     * words_string(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n     *\n     */\n    public static List<Object> wordsString(String s) {"}
{"task_id": "java/45", "language": "java", "completion": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\n\nclass ChooseNum {\n    /**\n     * \n     * Diese Funktion nimmt zwei positive Zahlen x und y entgegen und gibt die gr\u00f6\u00dfte gerade Zahl zur\u00fcck, die im Bereich [x, y] enthalten ist. Wenn es keine solche Zahl gibt, sollte die Funktion -1 zur\u00fcckgeben.\n     * \n     * Zum Beispiel:\n     * \n     * choose_num(12, 15) = 14\n     * choose_num(13, 12) = -1\n     *\n     */\n    public static int chooseNum(int x, int y) {\n        if (x < 0 || y < 0){\n            throw new IllegalArgumentException(\"Argument must be greater than or equal to zero\");\n        }\n        \n        for (int i = x; i <= y; i++) {\n            if (i % 2 == 0){\n                return i;\n            }\n        }\n        return -1;\n    }\n}"}
{"task_id": "java/46", "language": "java", "completion": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\n\nclass RoundedAvg {\n    /**\n     * \n     * Sie erhalten zwei positive Ganzzahlen n und m. Ihre Aufgabe besteht darin, den Durchschnitt der Ganzzahlen von n bis m (einschlie\u00dflich n und m) zu berechnen. Runden Sie die Antwort auf die n\u00e4chste Ganzzahl und konvertieren Sie diese in bin\u00e4r. Wenn n gr\u00f6\u00dfer als m ist, geben Sie -1 zur\u00fcck. Beispiel:\n     * \n     * rounded_avg(1, 5) => \"0b11\"\n     * rounded_avg(7, 5) => -1\n     * rounded_avg(10, 20) => \"0b1111\"\n     * rounded_avg(20, 33) => \"0b11010\"\n     *\n     */\n    public static Object roundedAvg(int n, int m) {\n        double avg = (n + m) / 2;"}
{"task_id": "java/47", "language": "java", "completion": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\n\nclass F {\n    /**\n     * \n     * Implementieren Sie die Funktion f, die n als Parameter annimmt und eine Liste der Gr\u00f6\u00dfe n zur\u00fcckgibt, wobei der Wert des Element an der Stelle i das Fakult\u00e4t von i ist, wenn i gerade ist, oder die Summe der Zahlen von 1 bis i, wenn i ungerade ist. i beginnt bei 1. Die Fakult\u00e4t von i ist das Produkt der Zahlen von 1 bis i (1 * 2 * ... * i). Beispiel:\n     * \n     * f(5) == [1, 2, 6, 24, 15]\n     *\n     */\n    public static List<Integer> f(int n) {\n        // Hinweis: die Implementierung ist leider zu lang. Wollen Sie eine L\u00f6sung haben?\n        \n        if (n <= 0)\n            return new ArrayList<Integer>();\n        \n        List<Integer> values = new ArrayList<Integer>();\n        \n        for (int i = 1; i <= n; i++) {\n            \n            int result = (i % 2 == 0) ? factorial(i) : sumOfNumbers(i);\n            \n            values.add(result);\n        }\n        \n        return values;\n    }\n    \n    private static int factorial(int number) {\n    \n        if (number < 0 || number > 170)\n            throw new IllegalArgumentException(\"Invalid argument\");\n        \n        if (number == 0 || number == 1)\n            return 1;\n        \n        int result = 1;\n        \n        for (int i = 2; i <= number; i++) {\n            \n            result *= i;\n        }\n        \n        return result;\n    }\n    \n    private static int sumOfNumbers(int number) {\n    \n        if (number < 0 || number > 170)\n            throw new IllegalArgumentException(\"Invalid argument\");\n        \n        int result = 0;\n        \n        for (int i = 1; i <= number; i++) {\n            \n            result += i;\n        }\n        \n        return result;\n    }\n}"}
{"task_id": "java/48", "language": "java", "completion": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\n\nclass EvenOddPalindrome {\n    /**\n     * * \n     * Gegeben eine positive ganze Zahl n, gibt eine Tupel zur\u00fcck, das die Anzahl der geraden und ungeraden ganzen Palindrome enth\u00e4lt, die im Bereich (1, n) einschlie\u00dflich liegen.\n     * \n     *     Beispiel 1:\n     * \n     *         Eingabe: 3\n     *         Ausgabe: (1, 2)\n     *         Erkl\u00e4rung:\n     *         Ganze Palindrome sind 1, 2, 3. Eines davon ist gerade und zwei davon sind ungerade.\n     * \n     *     Beispiel 2:\n     * \n     *         Eingabe: 12\n     *         Ausgabe: (4, 6)\n     *         Erkl\u00e4rung:\n     *         Ganze Palindrome sind 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. Vier davon sind gerade und sechs davon sind ungerade.\n     * \n     *     Hinweis:\n     *         1. 1 <= n <= 10^3\n     *         2. Das zur\u00fcckgegebene Tupel enth\u00e4lt die Anzahl der geraden und ungeraden ganzen Palindrome.\n     * \n     */\n    public static List<Integer> evenOddPalindrome(int n) {\n        List<Integer> result = new ArrayList<>();\n        for (int i = 1; i <= n; i++) {\n            String str = String.valueOf(i);\n            \n            //check if number is palindrome\n            boolean isPalindrome = true;\n            int len = str.length();\n            for (int j = 0; j < len/2; j++) {\n                if (str.charAt(j) != str.charAt(len-1-j)) {\n                    isPalindrome = false;\n                    break;\n                }\n            }\n            \n            //count even and odd numbers\n            int num = Integer.parseInt(str);\n            if (isPalindrome && num % 2 == 0) {\n                result.add(0, 1);\n            } else if (isPalindrome && num % 2 != 0) {\n                result.add(1, 1);\n            }\n        }\n        \n        return result;\n    }\n}"}
{"task_id": "java/49", "language": "java", "completion": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\n\nclass MoveOneBall {\n    /**\n     * \n     * Wir haben ein Array 'arr' mit N ganzen Zahlen arr[1], arr[2], ..., arr[N]. Die Zahlen im Array werden zuf\u00e4llig angeordnet sein. Deine Aufgabe besteht darin zu bestimmen, ob es m\u00f6glich ist, ein Array in nicht abnehmender Reihenfolge zu sortieren, indem du die folgende Operation auf das gegebene Array anwendest:\n     * Du darfst beliebig oft eine Rechtsschiebeoperation durchf\u00fchren.\n     * Eine Rechtsschiebeoperation bedeutet, dass alle Elemente des Arrays um eine Position in Richtung rechts verschoben werden. Das letzte Element des Arrays wird an die Startposition im Array verschoben, d.h. an den Index 0.\n     * \n     * Wenn es m\u00f6glich ist, das sortierte Array durch Ausf\u00fchren der oben genannten Operation zu erhalten, gib True zur\u00fcck, sonst gib False zur\u00fcck.\n     * Wenn das gegebene Array leer ist, gib True zur\u00fcck.\n     * \n     * Hinweis: Die gegebene Liste hat garantiert eindeutige Elemente.\n     * \n     * Zum Beispiel:\n     * \n     * move_one_ball([3, 4, 5, 1, 2])==>True\n     * Erkl\u00e4rung: Durch Ausf\u00fchren von 2 Rechtsschiebeoperationen kann die nicht abnehmende Reihenfolge f\u00fcr das gegebene Array erreicht werden.\n     * move_one_ball([3, 5, 4, 1, 2])==>False\n     * Erkl\u00e4rung: Es ist nicht m\u00f6glich, die nicht abnehmende Reihenfolge f\u00fcr das gegebene Array durch Ausf\u00fchren beliebiger Anzahl von Rechtsschiebeoperationen zu erhalten.\n     * \n     *             \n     * @param arr \n     * @return true if it's possible to move one ball from an array to another without changing the relative order of elements, false otherwise\n     */\n    public static Boolean moveOneBall(List<Integer> arr) {\n        // TODO: Write your code here\n        // This is a sample implementation. Feel free to replace it with your own solution.\n\tCollections.sort(arr);\n\tfor (int i = 1; i < arr.size(); ++i) {\n\t    if (arr.get(i - 1) > arr.get(i))\n\t\treturn false;\n\t}\n\t\n\treturn true;\n    }\n}"}
{"task_id": "java/50", "language": "java", "completion": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\n\nclass Exchange {\n    /**\n     * \n     * In diesem Problem implementieren Sie eine Funktion, die zwei Listen von Zahlen entgegennimmt und bestimmt, ob es m\u00f6glich ist, einen Austausch von Elementen zwischen ihnen durchzuf\u00fchren, um lst1 zu einer Liste nur mit geraden Zahlen zu machen. Es gibt keine Begrenzung f\u00fcr die Anzahl der ausgetauschten Elemente zwischen lst1 und lst2. Wenn es m\u00f6glich ist, Elemente zwischen lst1 und lst2 auszutauschen, um alle Elemente von lst1 gerade zu machen, geben Sie \"YES\" zur\u00fcck. Andernfalls geben Sie \"NO\" zur\u00fcck. Zum Beispiel: exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\" exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\". Es wird angenommen, dass die Eingabelisten nicht leer sein werden.\n     * \n     *\n     */\n    public static String exchange(List<Integer> lst1, List<Integer> lst2) {\n        int[] tab = new int[lst1.size()];\n        for (int i = 0; i < lst1.size(); i++) {\n            tab[i] = lst1.get(i);\n        }"}
{"task_id": "java/51", "language": "java", "completion": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\n\nclass ReverseDelete {\n    /**\n     * \n     * Aufgabe\n     *     Wir haben zwei Zeichenketten s und c. Du musst alle Zeichen in s l\u00f6schen, die einem Zeichen in c entsprechen.\n     *     Dann musst du \u00fcberpr\u00fcfen, ob die resultierende Zeichenkette ein Palindrom ist.\n     *     Eine Zeichenkette ist ein Palindrom, wenn sie r\u00fcckw\u00e4rts gelesen genauso aussieht wie vorw\u00e4rts.\n     *     Du solltest ein Tupel zur\u00fcckgeben, das die resultierende Zeichenkette und True/False f\u00fcr die \u00dcberpr\u00fcfung enth\u00e4lt.\n     *     Beispiel\n     *     F\u00fcr s = \"abcde\", c = \"ae\" sollte das Ergebnis ('bcd',False) sein.\n     *     F\u00fcr s = \"abcdef\", c = \"b\" sollte das Ergebnis ('acdef',False) sein.\n     *     F\u00fcr s = \"abcdedcba\", c = \"ab\" sollte das Ergebnis ('cdedc',True) sein.\n     * \n     *\n     */\n    public static List<Object> reverseDelete(String s, String c) {\n        return new ArrayList<Object>();\n    }\n}"}
{"task_id": "java/52", "language": "java", "completion": "import java.util.*;\n\npublic class MaxFill {\n    /**\n     * * \n     * Sie erhalten ein rechteckiges Gitter von Brunnen. Jede Zeile repr\u00e4sentiert einen einzelnen Brunnen, und jede 1 in einer Zeile repr\u00e4sentiert eine einzelne Einheit Wasser. Jeder Brunnen hat einen entsprechenden Eimer, der verwendet werden kann, um Wasser daraus zu extrahieren, und alle Eimer haben die gleiche Kapazit\u00e4t. Ihre Aufgabe ist es, die Eimer zu verwenden, um die Brunnen zu leeren. Geben Sie die Anzahl der Male aus, die Sie die Eimer senken m\u00fcssen.\n     * \n     * Beispiel 1:\n     *     Eingabe:\n     *         grid: [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n     *         Eimerkapazit\u00e4t: 1\n     *     Ausgabe: 6\n     * \n     * Beispiel 2:\n     *     Eingabe:\n     *         grid: [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n     *         Eimerkapazit\u00e4t: 2\n     *     Ausgabe: 5\n     * \n     * Beispiel 3:\n     *     Eingabe:\n     *         grid: [[0,0,0], [0,0,0]]\n     *         Eimerkapazit\u00e4t: 5\n     *     Ausgabe: 0\n     * \n     * Einschr\u00e4nkungen:\n     *     * alle Brunnen haben die gleiche L\u00e4nge\n     *     * 1 <= grid.length <= 10^2\n     *     * 1 <= grid[:,1].length <= 10^2\n     *     * grid[i][j] -> 0 | 1\n     *     * 1 <= Kapazit\u00e4t <= 10\n     * \n     *\n     */\n    public static int maxFill(List<List<Integer>> grid, int capacity) {\n        // Initialize count to zero.\n        var count = 0;\n\n        for (var row : grid) {\n            var filledCells = 0;\n\n            for (var cell : row) {\n                if (cell == 1) {\n                    ++filledCells;\n\n                    // If the number of filled cells in the current row is greater than or equal to capacity, \n                    // then we need to empty the eimmer.\n                    if (capacity <= filledCells) {\n                        count += capacity;\n                        filledCells -= capacity;\n                    } else {\n                        count += filledCells;\n                        filledCells = 0;\n                    }\n                }\n            }\n        }\n\n        return count;\n    }\n}"}
{"task_id": "java/53", "language": "java", "completion": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\n\nclass SelectWords {\n    /**\n     * \n     * Gegeben eine Zeichenkette s und eine nat\u00fcrliche Zahl n, wurde Ihnen die Aufgabe zugewiesen, eine Funktion zu implementieren, die eine Liste aller W\u00f6rter aus der Zeichenkette s zur\u00fcckgibt, die genau n Konsonanten enthalten, in der Reihenfolge, in der diese W\u00f6rter in der Zeichenkette s erscheinen. Wenn die Zeichenkette s leer ist, sollte die Funktion eine leere Liste zur\u00fcckgeben. Hinweis: Sie k\u00f6nnen davon ausgehen, dass die Eingabezeichenkette nur Buchstaben und Leerzeichen enth\u00e4lt. Beispiele:\n     * \n     * select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n     * select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n     * select_words(\"simple white space\", 2) ==> []\n     * select_words(\"Hello world\", 4) ==> [\"world\"]\n     * select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\n     *\n     */\n    public static List<String> selectWords(String s, int n) {"}
{"task_id": "java/54", "language": "java", "completion": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\n\nclass Maximum {\n    /**\n     * * \n     * Gegeben sei ein Array arr von ganzen Zahlen und eine positive ganze Zahl k. Gib eine sortierte Liste der L\u00e4nge k zur\u00fcck, die die k gr\u00f6\u00dften Zahlen in arr enth\u00e4lt.\n     * \n     *     Beispiel 1:\n     * \n     *         Eingabe: arr = [-3, -4, 5], k = 3\n     *         Ausgabe: [-4, -3, 5]\n     * \n     *     Beispiel 2:\n     * \n     *         Eingabe: arr = [4, -4, 4], k = 2\n     *         Ausgabe: [4, 4]\n     * \n     *     Beispiel 3:\n     * \n     *         Eingabe: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n     *         Ausgabe: [2]\n     * \n     *     Hinweis:\n     *         1. Die L\u00e4nge des Arrays wird im Bereich von [1, 1000] liegen.\n     *         2. Die Elemente im Array werden im Bereich von [-1000, 1000] liegen.\n     *         3. 0 <= k <= len(arr)\n     * \n     *\n     */\n    public static List<Object> maximum(List<Integer> arr, int k) {\n        Collections.sort(arr);\n\n        // reverse list\n        Collections.reverse(arr); \n\n        // create output array\n        Object[] maxArr = new Object[k];\n        \n        for (int i=0; i < k; i++) {\n            maxArr[i] = arr.get(i);\n        }\n\n        return Arrays.asList(maxArr);\n    }\n}"}
{"task_id": "java/55", "language": "java", "completion": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\n\nclass AddElements {\n    /**\n     * * \n     * Gegeben sei ein nicht-leeres Array von ganzen Zahlen arr und eine ganze Zahl k. Gib die Summe der Elemente mit h\u00f6chstens zwei Ziffern aus den ersten k Elementen von arr zur\u00fcck.\n     * \n     *     Beispiel:\n     * \n     *         Eingabe: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n     *         Ausgabe: 24 # Summe von 21 + 3\n     * \n     *     Einschr\u00e4nkungen:\n     *         1. 1 <= len(arr) <= 100\n     *         2. 1 <= k <= len(arr)\n     * \n     *\n     */\n    public static int addElements(List<Integer> arr, int k) {\n        // Implementieren Sie Ihren Code hier\n        int sum = 0;\n\n        for (int i = 0; i < k; i++) {\n            String s = Integer.toString(arr.get(i));\n\n            if (s.length() <= 2) {\n                sum += arr.get(i);\n            } else if (s.startsWith(\"9\")) {\n                sum += 9 * Math.pow(10, s.length() - 2);\n            } else {\n                sum += 9 * Math.pow(10, s.length() - 2) + Integer.parseInt(s.substring(1));\n            }\n        }\n\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        // Testkases\n        System.out.println(addElements(Arrays.asList(111, 21, 3, 4000, 5, 6, 7, 8, 9), 4) == 24);\n        System.out.println(addElements(Arrays.asList(999), 1) == 19);\n    }\n}"}
{"task_id": "java/56", "language": "java", "completion": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\n\nclass Intersection {\n    /**\n     * \n     * Sie erhalten zwei Intervalle,\n     *     wobei jedes Intervall ein Paar von ganzen Zahlen ist. Zum Beispiel, Intervall = (start, end) = (1, 2).\n     *     Die gegebenen Intervalle sind geschlossen, was bedeutet, dass das Intervall (start, end)\n     *     sowohl start als auch end einschlie\u00dft.\n     *     F\u00fcr jedes gegebene Intervall wird angenommen, dass sein Start kleiner oder gleich seinem Ende ist.\n     *     Ihre Aufgabe ist es zu bestimmen, ob die L\u00e4nge des Schnitts dieser beiden\n     *     Intervalle eine Primzahl ist.\n     *     Zum Beispiel ist der Schnitt der Intervalle (1, 3), (2, 4) (2, 3),\n     *     dessen L\u00e4nge 1 ist, was keine Primzahl ist.\n     *     Wenn die L\u00e4nge des Schnitts eine Primzahl ist, geben Sie \"YES\" zur\u00fcck,\n     *     andernfalls geben Sie \"NO\" zur\u00fcck.\n     *     Wenn sich die beiden Intervalle nicht \u00fcberschneiden, geben Sie \"NO\" zur\u00fcck.\n     * \n     * \n     *     [Eingabe/Ausgabe] Beispiele:\n     * \n     * intersection((1, 2), (2, 3)) ==> \"NO\"\n     * intersection((-1, 1), (0, 4)) ==> \"NO\"\n     * intersection((-3, -1), (-5, 5)) ==> \"YES\"\n     *\n     */\n    public static String intersection(List<Integer> interval1, List<Integer> interval2) {\n\n        int a = interval1.get(1);\n        int b = interval1.get(0);\n        int c = interval2.get(1);\n        int d = interval2.get(0);\n        \n        if((c >=b && c <=a ) || (d>=b && d<=a)){\n            return \"YES\";\n        }\n\n        return \"NO\";\n    }\n}"}
{"task_id": "java/57", "language": "java", "completion": "import java.util.*;\n\npublic class Main {\n\n    public static void main(String[] args) throws Exception {\n        Scanner sc = new Scanner(System.in);\n        int n;\n        while (sc.hasNext()) {\n            n = Integer.parseInt(sc.nextLine());\n            List<Number> result = tri(n);\n            for (int i = 0; i < result.size(); i++) {\n                System.out.print(result.get(i));\n                if (i < result.size() - 1) {\n                    System.out.print(\" \");\n                } else {\n                    System.out.println();\n                }\n            }\n        }\n    }\n\n    /**\n     * \n     * Jeder kennt die Fibonacci-Folge, die in den letzten Jahrhunderten von Mathematikern tiefgehend untersucht wurde. Was die meisten Menschen jedoch nicht wissen, ist die Tribonacci-Folge. Die Tribonacci-Folge wird durch die Rekursion definiert: tri(1) = 3 tri(n) = 1 + n / 2, wenn n gerade ist. tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), wenn n ungerade ist. Zum Beispiel: tri(2) = 1 + (2 / 2) = 2 tri(4) = 3 tri(3) = tri(2) + tri(1) + tri(4) = 2 + 3 + 3 = 8 Sie erhalten eine nicht-negative ganze Zahl n und m\u00fcssen eine Liste der ersten n + 1 Zahlen der Tribonacci-Folge zur\u00fcckgeben. Beispiele: tri(3) = [1, 3, 2, 8]\n     * \n     * @param n\n     * @return\n     */\n    public static List<Number> tri(int n) {\n        if (n <= 0) {\n            return new ArrayList<>();\n        } else if (n == 1) {\n            return Arrays.asList(3);\n        }\n\n        List<Number> result = new ArrayList<>();\n        result.add(3);\n\n        int k = 2;\n        while (k < n) {\n            Number last = result.get(result.size() - 1);\n            if (last instanceof Integer && ((Integer) last).intValue() % 2 == 0) {\n                result.add(1 + ((Integer) last).intValue() / 2);\n            } else {\n                int n_1 = result.get(result.size() - 2).intValue();\n                int n_2 = result.get(result.size() - 3).intValue();\n                result.add(n_1 + n_2 + last.intValue());\n            }\n            k++;\n        }\n\n        return result;\n    }\n}"}
{"task_id": "java/58", "language": "java", "completion": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\n\nclass Digits {\n    /**\n     * \n     * Gegeben eine positive ganze Zahl n, gib das Produkt der ungeraden Ziffern zur\u00fcck.\n     *     Gib 0 zur\u00fcck, wenn alle Ziffern gerade sind.\n     *     Zum Beispiel:\n     * \n     * digits(1)  == 1\n     * digits(4)  == 0\n     * digits(235) == 15\n     *\n     */\n    public static int digits(int n) {\n        int result = 1;\n        \n        while (n > 0){\n            if (isOdd(n))\n                result *= n % 10;\n            n /= 10;\n        }\n        return result;\n    }\n    \n    public static boolean isOdd(int n) {\n        return (n % 2 != 0);\n    }\n}"}
{"task_id": "java/59", "language": "java", "completion": "import java.util.Stack;\n\npublic class IsNested {\n\n    /**\n     * * \n     * Erstellen Sie eine Funktion, die einen String als Eingabe erh\u00e4lt, der nur eckige Klammern enth\u00e4lt. Die Funktion sollte True zur\u00fcckgeben, wenn und nur wenn es eine g\u00fcltige Teilfolge von Klammern gibt, bei der mindestens eine Klammer in der Teilfolge verschachtelt ist.\n     * is_nested('[[]]') \u279e True\n     * is_nested('[]]]]]]][[[[[]') \u279e False\n     * is_nested('[][]')\ufffd\ufffd False\n     * is_nested('[]') \u2192 False\n     * is_nested('[[][]]') \u2192 True\n     * is_nested('[[]][[') \u2192 True\n     *\n     */\n    public static Boolean isNested(String string) {\n        Stack<Character> stack = new Stack<>();\n\n        for (int i = 0; i < string.length(); i++) {\n            char c = string.charAt(i);\n\n            switch (c) {\n                case '[':\n                    stack.push(']');\n                    break;\n                case '(':\n                    stack.push(')');\n                    break;\n                case '{':\n                    stack.push('}');\n                    break;\n\n                default:\n                    if (stack.isEmpty() || !stack.pop().equals(string.charAt(i))) {\n                        return false;\n                    }\n            }\n        }\n\n        return stack.isEmpty();\n    }\n\n    public static void main(String[] args) {\n        System.out.println(isNested(\"[[][]]\"));\n        System.out.println(isNested(\"[[{}]]\"));\n    }\n}"}
{"task_id": "java/60", "language": "java", "completion": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\n\nclass SumSquares {\n    /**\n     * \n     * Sie erhalten eine Liste von Zahlen.\n     * Sie m\u00fcssen die Summe der quadrierten Zahlen in der gegebenen Liste zur\u00fcckgeben,\n     * runden Sie jedes Element in der Liste zuerst auf die n\u00e4chste Ganzzahl (Ceiling).\n     * Beispiele:\n     * F\u00fcr lst = [1,2,3] sollte die Ausgabe 14 sein\n     * F\u00fcr lst = [1,4,9] sollte die Ausgabe 98 sein\n     * F\u00fcr lst = [1,3,5,7] sollte die Ausgabe 84 sein\n     * F\u00fcr lst = [1.4,4.2,0] sollte die Ausgabe 29 sein\n     * F\u00fcr lst = [-2.4,1,1] sollte die Ausgabe 6 sein\n     * \n     * \n\n     *\n     */\n    public static int sumSquares(List<Number> lst) {\n        int summe = 0;\n        for (int i = 0; i < lst.size(); i++) {\n            double temp = Math.ceil(lst.get(i));\n            int tempInt = (int)temp;\n            summe += tempInt * tempInt;\n        }\n\n        return summe;\n    }\n}"}
{"task_id": "java/61", "language": "java", "completion": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\n\nclass CheckIfLastCharIsALetter {\n    /**\n     * * \n     * Erstellen Sie eine Funktion, die True zur\u00fcckgibt, wenn das letzte Zeichen eines gegebenen Strings ein alphabetisches Zeichen ist und nicht Teil eines Wortes ist, und False sonst.\n     * Hinweis: \"Wort\" ist eine Gruppe von Zeichen, die durch Leerzeichen getrennt sind.\n     * \n     * Beispiele:\n     * \n     * check_if_last_char_is_a_letter(\"apple pie\") \u279e False\n     * check_if_last_char_is_a_letter(\"apple pi e\") SarstFalse\n     * check_if_last_char_is_a_letter(\"apple pi e \") SarstFalse\n     * check_if_last_char_is_a_letter(\"\") SarstFalse \n     *\n     */\n    public static Boolean checkIfLastCharIsALetter(String txt) {\n        txt = txt.trim();\n        int lastIndex = txt.length() - 1;\n        if (Character.isLetter(txt.charAt(lastIndex)) && !Character.isLetter(txt.charAt(lastIndex-1))) return true;\n        else return false;\n    }\n}"}
{"task_id": "java/62", "language": "java", "completion": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\n\nclass CanArrange {\n    /**\n     * \n     * Erstellen Sie eine Funktion, die den gr\u00f6\u00dften Index eines Elements zur\u00fcckgibt, das nicht gr\u00f6\u00dfer oder gleich dem unmittelbar vorhergehenden Element ist. Wenn kein solches Element vorhanden ist, geben Sie -1 zur\u00fcck. Das gegebene Array enth\u00e4lt keine doppelten Werte.\n     * \n     * Beispiele:\n     * \n     * can_arrange([1,2,4,3,5]) = 3\n     * can_arrange([1,2,3]) = -1\n     *\n     */\n    public static int canArrange(List<Object> arr) {\n        Integer[] list = new Integer[arr.size()];\n        for (int i=0; i<list.length; i++) {\n            list[i] = (Integer) arr.get(i);\n        }\n\n        int index = -1;\n        for (int i = 0; i < list.length-1; i++) {\n            if (list[i] <= list[i+1]) {\n                continue;\n            } else {\n                index = i;\n            }\n        }\n\n        return index;\n    }\n}"}
{"task_id": "java/63", "language": "java", "completion": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\n\nclass LargestSmallestIntegers {\n    /**\n     * * \n     * Estellt eine Funktion, die ein Tupel (a, b) zur\u00fcckgibt, wobei 'a' die gr\u00f6\u00dfte negative Ganzzahl und 'b' die kleinste positive Ganzzahl in einer Liste ist. Wenn es keine negativen oder positiven Ganzzahlen gibt, geben Sie sie als None zur\u00fcck.\n     * \n     * Beispiele:\n     * \n     * largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n     * largest_smallest_integers([]) == (None, None)\n     * largest_smallest_integers([0]) == (None, None)\n     *\n     */\n    public static List<Integer> largestSmallestIntegers(List<Object> lst) {"}
{"task_id": "java/64", "language": "java", "completion": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\n\nclass SpecialFactorial {\n    /**\n     * \n     * Das brasilianische Fakult\u00e4t ist definiert als:\n     *     brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n     *     wobei n > 0\n     * \n     *     Zum Beispiel:\n     * >>> special_factorial(4)\n     * 288\n\n     * The function will receive an integer as input and should return the special\n     * factorial of this integer.\n     *\n     */\n    public static long specialFactorial(int n) {\n        if (n == 1 || n == 0) {\n            return 1;\n        } else {\n            return n * specialFactorial(n - 1);\n        }\n    }\n}"}
{"task_id": "java/65", "language": "java", "completion": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\n\nclass WordsInSentence {\n    /**\n     * * \n     * Du erh\u00e4ltst einen String, der einen Satz repr\u00e4sentiert. Der Satz enth\u00e4lt einige W\u00f6rter, die durch ein Leerzeichen getrennt sind. Du musst einen String zur\u00fcckgeben, der die W\u00f6rter aus dem urspr\u00fcnglichen Satz enth\u00e4lt, deren L\u00e4ngen Primzahlen sind. Die Reihenfolge der W\u00f6rter im neuen String sollte dieselbe wie im Original sein.\n     * \n     *     Beispiel 1:\n     *         Eingabe: sentence = \"This is a test\"\n     *         Ausgabe: \"is\"\n     * \n     *     Beispiel 2:\n     *         Eingabe: sentence = \"lets go for swimming\"\n     *         Ausgabe: \"go for\"\n     * \n     *     Einschr\u00e4nkungen:\n     *         * 1 <= len(sentence) <= 100\n     *         * Der Satz enth\u00e4lt nur Buchstaben.\n     * \n     *\n     */\n    public static String wordsInSentence(String sentence) {"}
{"task_id": "java/66", "language": "java", "completion": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\n\nclass Simplify {\n    /**\n     * \n     * Deine Aufgabe ist es, eine Funktion zu implementieren, die den Ausdruck x * n vereinfacht. Die Funktion gibt True zur\u00fcck, wenn x * n zu einer ganzen Zahl ausgewertet wird, andernfalls False. Sowohl x als auch n sind Zeichenketten, die eine Bruchzahl darstellen und das folgende Format haben: <Z\u00e4hler>/<Nenner>, wobei sowohl Z\u00e4hler als auch Nenner positive ganze Zahlen sind.\n     * \n     * Du kannst davon ausgehen, dass x und n g\u00fcltige Bruchzahlen sind und keinen Nenner von Null haben.\n     * simplify(\"1/5\", \"5/1\") = True\n     * simplify(\"1/6\", \"2/1\") = False\n     * simplify(\"7/10\", \"10/2\") = False\n     * @param x string\n     * @param n string\n     * @return boolean\n     */\n    public static Boolean simplify(String x, String n) {\n        return true;\n    }\n}"}
{"task_id": "java/67", "language": "java", "completion": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\n\nclass OrderByPoints {\n    /**\n     * * \n     * Schreiben Sie eine Funktion, die die gegebene Liste von Ganzzahlen\n     *     in aufsteigender Reihenfolge nach der Summe ihrer Ziffern sortiert.\n     *     Hinweis: Wenn es mehrere Elemente mit \u00e4hnlicher Summe ihrer Ziffern gibt,\n     *     ordnen Sie sie basierend auf ihrem Index in der Originalliste.\n     * \n     *     Zum Beispiel:\n     * >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n     * >>> order_by_points([]) == []\n     *\n     */\n    public static List<Object> orderByPoints(List<Object> nums) {\n        if (nums.size() < 2) return nums;\n\n        int index = nums.indexOf(Collections.max(nums)); // find the biggest element\n        Object maxElement = nums.get(index);\n\n        nums.remove(index); // remove the biggest element from the list\n        List<Object> smallerElements = new ArrayList<>(orderByPoints(nums)); // recursive call with the remaining elements\n        smallerElements.add(maxElement); // add the biggest element at the end of the sorted list\n\n        return smallerElements;\n    }\n}"}
{"task_id": "java/68", "language": "java", "completion": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\n\nclass Specialfilter {\n    /**\n     * \n     * Schreiben Sie eine Funktion, die ein Array von Zahlen als Eingabe erh\u00e4lt und die Anzahl der Elemente im Array zur\u00fcckgibt, die gr\u00f6\u00dfer als 10 sind und bei denen sowohl die erste als auch die letzte Ziffer der Zahl ungerade sind (1, 3, 5, 7, 9). Zum Beispiel:\n     * \n     * specialFilter([15, -73, 14, -15]) => 1 \n     * specialFilter([33, -2, -3, 45, 21, 109]) => 2\n     *\n     */\n    public static int specialfilter(List<Object> nums) {\n        //Ich habe versucht die Schleife so zu schreiben dass es mit \"for each\" an der Stelle des while-Schleifen statements l\u00e4uft.\n        /*int count = 0;\n        for (Integer num : nums) {\n            if(num > 10 && (String.valueOf(num)).charAt(0) % 2 != 0 && (String.valueOf(num)).charAt((String.valueOf(num)).length()) % 2 != 0)\n                count += 1;\n        }\n        return count;*/\n        \n        int counter = 0;\n        for(int i = 0; i < nums.size(); i++) {\n            if((nums.get(i)) instanceof Integer && ((Integer) nums.get(i)) > 10 && (String.valueOf(nums.get(i))).charAt(0) % 2 != 0 && (String.valueOf(nums.get(i))).charAt(((String.valueOf(nums.get(i))).length()) - 1) % 2 != 0)\n                counter += 1;\n        }\n        return counter;\n    }\n}"}
{"task_id": "java/69", "language": "java", "completion": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\n\nclass GetMaxTriples {\n    /**\n     * * \n     * Sie erhalten eine positive ganze Zahl n. Sie m\u00fcssen ein Integer-Array a der L\u00e4nge n erstellen.\n     *         F\u00fcr jedes i (1 \u2264 i \u2264 n) gilt: a[i] = i * i - i + 1.\n     *         Geben Sie die Anzahl der Tripel (a[i], a[j], a[k]) von a zur\u00fcck, bei denen i < j < k gilt und a[i] + a[j] + a[k] ein Vielfaches von 3 ist.\n     * \n     *     Beispiel:\n     *         Eingabe: n = 5\n     *         Ausgabe: 1\n     *         Erkl\u00e4rung:\n     *         a = [1, 3, 7, 13, 21]\n     *         Das einzige g\u00fcltige Tripel ist (1, 7, 13).\n     * \n     *\n     */\n    public static int getMaxTriples(int n) {"}
{"task_id": "java/70", "language": "java", "completion": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\n\nclass Bf {\n    /**\n     * * \n     * Es gibt acht Planeten in unserem Sonnensystem: Der Sonne am n\u00e4chsten ist Merkur, dann folgen Venus, die Erde, Mars, Jupiter, Saturn, Uranus und Neptun. Schreiben Sie eine Funktion, die zwei Planetennamen als Zeichenketten planet1 und planet2 annimmt. Die Funktion sollte ein Tupel zur\u00fcckgeben, das alle Planeten enth\u00e4lt, deren Umlaufbahnen zwischen der Umlaufbahn von Planet1 und der Umlaufbahn von Planet2 liegen und nach N\u00e4he zur Sonne sortiert sind. Die Funktion sollte ein leeres Tupel zur\u00fcckgeben, wenn planet1 oder planet2 keine korrekten Planetennamen sind. Beispiele:\n     * \n     * bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n     * bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n     * bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n     *\n     */\n    public static List<Object> bf(String planet1, String planet2) {\n        // Your code goes here\n        return new ArrayList<Object>();\n    }\n}"}
{"task_id": "java/71", "language": "java", "completion": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\n\nclass XOrY {\n    /**\n     * \n     * Ein einfaches Programm, das den Wert von x zur\u00fcckgeben sollte, wenn n eine Primzahl ist, und den Wert von y zur\u00fcckgeben sollte, wenn nicht.\n     * \n     * Beispiele:\n     * \n     * for x_or_y(7, 34, 12) == 34\n     * for x_or_y(15, 8, 5) == 5\n     * \n     *\n     */\n    public static int xOrY(int n, int x, int y) {\n        // Wir k\u00f6nnen diese Aufgabe in zwei Teile einteilen:\n        // 1. Testen, ob n eine Primzahl ist.\n        // 2. Gibt es einen Wert zwischen x und y?\n        return 0;\n    }\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n\n        int t = in.nextInt();\n        for (int i=0; i<t; i++) {\n            int n = in.nextInt();\n            int x = in.nextInt();\n            int y = in.nextInt();\n\n            System.out.println(xOrY(n, x, y));\n        }\n    }\n}"}
{"task_id": "java/72", "language": "java", "completion": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\n\nclass DoubleTheDifference {\n    /**\n     * * \n     * Gegeben eine Liste von Zahlen, gib die Summe der Quadrate der Zahlen in der Liste zur\u00fcck, die ungerade sind. Ignoriere Zahlen, die negativ oder keine ganzen Zahlen sind.\n     * \n     *     double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n     *     double_the_difference([-1, -2, 0]) == 0\n     *     double_the_difference([9, -2]) == 81\n     *     double_the_difference([0]) == 0  \n     *     \n     *     Wenn die Eingangsliste leer ist, gib 0 zur\u00fcck.\n     * \n     *\n     */\n    public static int doubleTheDifference(List<Object> lst) {\n        return 0;\n        \n    }\n}"}
{"task_id": "java/73", "language": "java", "completion": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\n\nclass StrongestExtension {\n    /**\n     * \n     * Sie erhalten den Namen einer Klasse (einen String) und eine Liste von Erweiterungen. Die Erweiterungen sollen verwendet werden, um zus\u00e4tzliche Klassen zur Klasse zu laden. Die St\u00e4rke der Erweiterung wird wie folgt definiert: Sei CAP die Anzahl der Gro\u00dfbuchstaben im Namen der Erweiterung und SM die Anzahl der Kleinbuchstaben im Namen der Erweiterung. Die St\u00e4rke wird durch den Bruch CAP - SM gegeben. Sie sollten die st\u00e4rkste Erweiterung finden und einen String in diesem Format zur\u00fcckgeben: ClassName.StrongestExtensionName. Wenn es zwei oder mehr Erweiterungen mit der gleichen St\u00e4rke gibt, sollten Sie die w\u00e4hlen, die zuerst in der Liste steht. Zum Beispiel, wenn Sie \"Slices\" als Klasse und eine Liste von Erweiterungen erhalten: ['SErviNGSliCes', 'Cheese', 'StUfFed'], sollten Sie 'Slices.SErviNGSliCes' zur\u00fcckgeben, da 'SErviNGSliCes' die st\u00e4rkste Erweiterung ist (ihre St\u00e4rke ist -1). Beispiel:\n     * \n     * for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n     *\n     */\n    public static String strongestExtension(String className, List<String> extensions) {\n        int starkesteErweiterung = -1;\n        String starksteErweiterungName = \"\";\n        \n        for (String extension : extensions) {\n            if (extension.length() == 0)\n                continue;\n            \n            int currentErweiterungStarke = getErweiterungStarke(extension);\n            System.out.println(\"currentErweiterungStarke = \" + currentErweiterungStarke);\n            \n            if (starkesteErweiterung == -1 ||\n                currentErweiterungStarke > starkesteErweiterung) {\n                \n                starkesteErweiterung = currentErweiterungStarke;\n                starksteErweiterungName = extension;\n            }\n        }\n        \n        if (starkesteErweiterungName.equals(\"\"))\n            return className;\n        else\n            return String.format(\"%s.%s\", className, starkesteErweiterungName);\n    }\n    \n    public static int getErweiterungStarke(String erweiterung) {\n        int groesse = 0;\n        \n        for (char c : erweiterung.toCharArray()) {\n            if (Character.isUpperCase(c))\n                ++groesse;\n        }\n        \n        return groesse - erweiterung.length() + groesse;\n    }\n}"}
{"task_id": "java/74", "language": "java", "completion": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\n\nclass CycpatternCheck {\n    /**\n     * \n     * Du bekommst 2 W\u00f6rter. Du musst True zur\u00fcckgeben, wenn das zweite Wort oder eine seiner Rotationen ein Teilstring im ersten Wort ist.\n     * cycpattern_check(\"abcd\",\"abd\") => False\n     * cycpattern_check(\"hello\",\"ell\") => True\n     * cycpattern_check(\"whassup\",\"psus\") => False\n     * cycpattern_check(\"abab\",\"baa\") => True\n     * cycpattern_check(\"efef\",\"eeff\") => False\n     * cycpattern_check(\"himenss\",\"simen\") => True\n\n     *\n     */\n    public static Boolean cycpatternCheck(String a, String b) {\n        // Write your code here\n\n        if (a.equals(b)) {\n            return true;\n        }\n        \n        for (int i = 0; i < a.length(); ++i) {\n            boolean found = false;\n            \n            for (int j = 0; j < b.length(); ++j) {\n                if (a.charAt((i+j) % a.length()) != b.charAt(j)) {\n                    break;\n                } else if (j == b.length() - 1) {\n                    found = true;\n                    break;\n                }\n            }\n            \n            if (found) {\n                return true;\n            }\n        }\n        \n        return false;\n    }\n}"}
{"task_id": "java/75", "language": "java", "completion": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\n\nclass IntToMiniRoman {\n    /**\n     * * \n     * Gegeben eine positive Ganzzahl, erhalte ihre r\u00f6mische Numeral-\u00c4quivalenz als Zeichenkette und gib sie in Kleinbuchstaben zur\u00fcck.\n     * Einschr\u00e4nkungen: 1 <= num <= 1000\n     * \n     * Beispiele:\n     * >>> int_to_mini_roman(19) == 'xix'\n     * >>> int_to_mini_roman(152) == 'clii'\n     * >>> int_to_mini_roman(426) == 'cdxxvi'\n     *\n     */\n    public static String intToMiniRoman(int number) {\n        // Write your code here"}
{"task_id": "java/76", "language": "java", "completion": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\n\nclass RightAngleTriangle {\n    /**\n     * * \n     * Gegeben sind die L\u00e4ngen der drei Seiten eines Dreiecks. Gib True zur\u00fcck, wenn die drei Seiten ein rechtwinkliges Dreieck bilden, ansonsten False. Ein rechtwinkliges Dreieck ist ein Dreieck, bei dem ein Winkel ein rechter Winkel oder 90 Grad ist. Beispiel:\n     * \n     * right_angle_triangle(3, 4, 5) == True\n     * right_angle_triangle(1, 2, 3) == False\n     *\n     */\n    public static Boolean rightAngleTriangle(int a, int b, int c) {\n        if (a + b > c && a + c > b && b + c > a){\n            return true;\n        } else {\n            return false;\n        }        \n    }\n}"}
{"task_id": "java/77", "language": "java", "completion": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\n\nclass Solve {\n    /**\n     * \n     * Du erh\u00e4ltst einen String s.\n     *     Wenn s[i] ein Buchstabe ist, kehre seine Gro\u00df- und Kleinschreibung um, oder umgekehrt,\n     *     ansonsten belasse es so wie es ist.\n     *     Wenn der String keine Buchstaben enth\u00e4lt, kehre den String um.\n     *     Die Funktion sollte den resultierenden String zur\u00fcckgeben.\n     *     Beispiele\n     * \n     * solve(\"1234\") = \"4321\"\n     * solve(\"ab\") = \"AB\"\n     * solve(\"#a@C\") = \"#A@c\"\n     *\n     */\n    public static String solve(String s) {\n        char[] chars = s.toCharArray();\n\n        for (int i = 0; i < chars.length; i++) {\n            if ((chars[i] >= 'a' && chars[i] <= 'z') ||\n                (chars[i] >= 'A' && chars[i] <= 'Z')) {\n                if (Character.isUpperCase(chars[i]))\n                    chars[i] = Character.toLowerCase(chars[i]);\n                else\n                    chars[i] = Character.toUpperCase(chars[i]);\n            }\n        }\n\n        return new String(chars);\n    }\n}"}
{"task_id": "java/78", "language": "java", "completion": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\nimport java.security.*;\n\n\nclass StringToMd5 {\n    /**\n     * * \n     * Gegeben eine Zeichenkette 'text', gibt seine md5-Hash-\u00c4quivalent-Zeichenkette zur\u00fcck.\n     *     Wenn 'text' eine leere Zeichenkette ist, gib null zur\u00fcck.\n     * >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n     *\n     */\n    public static String stringToMd5(String text) {"}
{"task_id": "java/79", "language": "java", "completion": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\n\nclass GenerateIntegers {\n    /**\n     * * \n     * Gegeben sind zwei positive ganze Zahlen a und b. Gib die geraden Ziffern zwischen a und b in aufsteigender Reihenfolge zur\u00fcck.\n     * \n     * Zum Beispiel:\n     * \n     * generate_integers(2, 8) => [2, 4, 6, 8]\n     * generate_integers(8, 2) => [2, 4, 6, 8]\n     * generate_integers(10, 14) => []\n     *\n     */\n    public static List<Integer> generateIntegers(int a, int b) {"}
