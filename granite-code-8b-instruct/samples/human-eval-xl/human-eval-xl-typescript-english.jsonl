{"task_id": "typescript/0", "language": "typescript", "completion": "/**\n * You're an expert TypeScript programmer\n * You're given a list of deposit and withdrawal operations on a bank account that starts with\n * zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n * at that point function should return True. Otherwise it should return False.\n * >>> below_zero([1, 2, 3])\n * False\n * >>> below_zero([1, 2, -4, 5])\n * True\n * \n */\nconst below_zero = function (operations: Array<number>) : boolean  {\n\n    let balance = 0;\n    for(let i = 0; i < operations.length; i++){\n        const value = operations[i];\n        if(value >= 0){\n            balance += value;\n        } else {\n            balance += value;\n            if(balance < 0)\n                return true;\n        }\n    }\n\n    return false;\n}"}
{"task_id": "typescript/1", "language": "typescript", "completion": "/**\n * You're an expert TypeScript programmer\n * For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n * Empty sum should be equal to 0 and empty product should be equal to 1.\n * >>> sum_product([])\n * (0, 1)\n * >>> sum_product([1, 2, 3, 4])\n * (10, 24)\n */\nconst sum_product = function (numbers: Array<number>) : Array<number>  {\n    let [sum, product] = [0, 1];\n\n    for (let number of numbers) {\n        sum += number;\n        product *= number;\n    }\n\n    return [sum, product];\n};"}
{"task_id": "typescript/2", "language": "typescript", "completion": "/**\n * You're an expert TypeScript programmer\n * Input are two strings a and b consisting only of 1s and 0s.\n * Perform binary XOR on these inputs and return result also as a string.\n * >>> string_xor('010', '110')\n * '100'\n */\nconst string_xor = function (a: string, b: string): string {\n  const aBinary = parseInt(a, 2)\n  const bBinary = parseInt(b, 2)\n  return (aBinary ^ bBinary).toString(2)\n}"}
{"task_id": "typescript/3", "language": "typescript", "completion": "/**\n * You're an expert TypeScript programmer\n * Out of list of strings, return the longest one. Return the first one in case of multiple\n * strings of the same length. Return None in case the input list is empty.\n * >>> longest([])\n * \n * >>> longest(['a', 'b', 'c'])\n * 'a'\n * >>> longest(['a', 'bb', 'ccc'])\n * 'ccc'\n * \n */\nconst longest = function (strings: Array<string>) : any  {\n  if(strings.length == 0){\n    return null;\n  }\n\n  let longest = strings[0];\n  for(let i = 1; i < strings.length; ++i) {\n    if(strings[i].length > longest.length) {\n      longest = strings[i];\n    }\n  }\n  return longest;\n}"}
{"task_id": "typescript/4", "language": "typescript", "completion": "/**\n * You're an expert TypeScript programmer\n * Return a greatest common divisor of two integers a and b\n * >>> greatest_common_divisor(3, 5)\n * 1\n * >>> greatest_common_divisor(25, 15)\n * 5\n * \n */\nconst greatest_common_divisor = function (a: number, b: number) : number  {\n  return a % b === 0 ? b : greatest_common_divisor(b, a % b);\n}"}
{"task_id": "typescript/5", "language": "typescript", "completion": "/**\n * You're an expert TypeScript programmer\n * Input is a space-delimited string of numberals from 'zero' to 'nine'.\n * Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n * Return the string with numbers sorted from smallest to largest\n * >>> sort_numbers('three one five')\n * 'one three five'\n */\nconst sort_numbers = function (numbers: string) : string  {\n  const numberMap: {[key:string]: number} = {\n    zero: 0,\n    one: 1,\n    two: 2,\n    three: 3,\n    four: 4,\n    five: 5,\n    six: 6,\n    seven: 7,\n    eight: 8,\n    nine: 9\n  }\n\n  const numArray = numbers.split(\" \")\n  \n  // Convert the array of words to an array of numbers\n  const numberArray = numArray.map((numString) => { return numberMap[numString] });\n  \n  // Sort the array of numbers\n  numberArray.sort();\n\n  console.log(numberArray);\n\n  return \"Success!\"\n}"}
{"task_id": "typescript/6", "language": "typescript", "completion": "/**\n * You're an expert TypeScript programmer\n * Given list of numbers (of at least two elements), apply a linear transform to that list,\n * such that the smallest number will become 0 and the largest will become 1\n * >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n * [0.0, 0.25, 0.5, 0.75, 1.0]\n * \n */\nconst rescale_to_unit = function (numbers: Array<number>) : Array<number>  {\n  let min: number = numbers[0];\n  let max: number = numbers[0];\n  for(let i = 1; i < numbers.length; i++) {\n    if(min > numbers[i]) {\n      min = numbers[i];\n    } else if (max < numbers[i]) {\n      max = numbers[i];\n    } \n  }\n\n  let result: Array<number> = new Array();\n  for(let i = 0; i < numbers.length; i++) {\n    result.push((numbers[i] - min)/(max - min));\n  } \n\n  return result\n}"}
{"task_id": "typescript/7", "language": "typescript", "completion": "/**\n * You're an expert TypeScript programmer\n * For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n * >>> flip_case('Hello')\n * 'hELLO'\n */\nconst flip_case = function (string0: string) : string  {\n  const string1 = string0.split('');\n\n  for (let i=0; i < string1.length; i++) {\n    if (/[a-z]/.test(string1[i])){\n      string1[i] = string1[i].toUpperCase();\n    } else {\n      string1[i] = string1[i].toLowerCase();\n    };\n  };\n  return string1.join('');\n};"}
{"task_id": "typescript/8", "language": "typescript", "completion": "/**\n * You're an expert TypeScript programmer\n * Return only positive numbers in the list.\n * >>> get_positive([-1, 2, -4, 5, 6])\n * [2, 5, 6]\n * >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n * [5, 3, 2, 3, 9, 123, 1]\n * \n */\nconst get_positive = function (l: Array<number>) : Array<number>  {\n    const positiveList = []\n\n    for (let i = 0; i < l.length; i++) {\n        if (l[i] > 0) {\n            positiveList.push(l[i])\n        }\n    }\n    return positiveList\n}"}
{"task_id": "typescript/9", "language": "typescript", "completion": "/**\n * You're an expert TypeScript programmer\n * Return true if a given number is prime, and false otherwise.\n * >>> is_prime(6)\n * False\n * >>> is_prime(101)\n * True\n * >>> is_prime(11)\n * True\n * >>> is_prime(13441)\n * True\n * >>> is_prime(61)\n * True\n * >>> is_prime(4)\n * False\n * >>> is_prime(1)\n * False\n */\nconst is_prime = function (n: number): boolean {\n  for (let i = 2; i < n; i++) {\n    if (n % i === 0) return false\n  }\n\n  return true\n}"}
{"task_id": "typescript/10", "language": "typescript", "completion": "/**\n * You're an expert TypeScript programmer\n * Return sorted unique elements in a list\n * >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n * [0, 2, 3, 5, 9, 123]\n * \n */\nconst unique = function (l: Array<number>) : Array<number>  {\n    // Sort the array first\n    l.sort((a, b) => a - b);\n\n    const out:Array<number> = [];\n    for(let i=0; i < l.length; i++) {\n        if(i == 0 || l[i] != l[i-1]) {\n            out.push(l[i]);\n        }\n    }\n    return out;\n}"}
{"task_id": "typescript/11", "language": "typescript", "completion": "import * as math from 'mathjs'\n\n/**\n * You're an expert TypeScript programmer\n * \n * prime_fib returns n-th number that is a Fibonacci number and it's also prime.\n * >>> prime_fib(1)\n * 2\n * >>> prime_fib(2)\n * 3\n * >>> prime_fib(3)\n * 5\n * >>> prime_fib(4)\n * 13\n * >>> prime_fib(5)\n * 89\n * \n */\nconst prime_fib = function (n: number) : number  {\n  // Implement me!"}
{"task_id": "typescript/12", "language": "typescript", "completion": "/**\n * You're an expert TypeScript programmer\n * \n * triples_sum_to_zero takes a list of integers as an input.\n * it returns True if there are three distinct elements in the list that\n * sum to zero, and False otherwise.\n * \n * >>> triples_sum_to_zero([1, 3, 5, 0])\n * False\n * >>> triples_sum_to_zero([1, 3, -2, 1])\n * True\n * >>> triples_sum_to_zero([1, 2, 3, 7])\n * False\n * >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n * True\n * >>> triples_sum_to_zero([1])\n * False\n * \n */\nconst triples_sum_to_zero = function (l: Array<number>) : boolean  {\n    var hashMap = {};\n\n    for (let i of l) {\n        if (i in hashMap){\n            return true;\n        }\n\n        hashMap[0 - i] = true;\n    }\n\n    return false;\n}"}
{"task_id": "typescript/13", "language": "typescript", "completion": "/**\n * You're an expert TypeScript programmer\n * \n * pairs_sum_to_zero takes a list of integers as an input.\n * it returns True if there are two distinct elements in the list that\n * sum to zero, and False otherwise.\n * >>> pairs_sum_to_zero([1, 3, 5, 0])\n * False\n * >>> pairs_sum_to_zero([1, 3, -2, 1])\n * False\n * >>> pairs_sum_to_zero([1, 2, 3, 7])\n * False\n * >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n * True\n * >>> pairs_sum_to_zero([1])\n * False\n * \n */\nconst pairs_sum_to_zero = function (l: Array<number>) : boolean  {\n    let s: Set<number> = new Set();\n    for(let i of l) {\n        if (s.has(-i)) return true;\n        else s.add(i);\n    }\n    return false;\n}"}
{"task_id": "typescript/14", "language": "typescript", "completion": "/**\n * You're an expert TypeScript programmer\n * The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n * fib4(0) -> 0\n * fib4(1) -> 0\n * fib4(2) -> 2\n * fib4(3) -> 0\n * fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n * Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n * >>> fib4(5)\n * 4\n * >>> fib4(6)\n * 8\n * >>> fib4(7)\n * 14\n * \n */\nconst fib4 = function (n: number): number  {\n  if (n < 3)\n    return 0;\n\n  let a : number = 0, b : number = 2, c : number = 2, d : number = 0, tmp : number;\n\n  while (--n > 2) {\n    tmp = b + c + d;\n    a = b;\n    b = c;\n    c = d;\n    d = tmp;\n  }\n\n  return d;\n}"}
{"task_id": "typescript/15", "language": "typescript", "completion": "/**\n * You're an expert TypeScript programmer\n * Return median of elements in the list l.\n * >>> median([3, 1, 2, 4, 5])\n * 3\n * >>> median([-10, 4, 6, 1000, 10, 20])\n * 15.0\n * \n */\nconst median = function (l: Array<number>) : number  {\n    if ( l.length % 2 )\n        return l[Math.floor(l.length/2)]\n\n    let sorted = l.sort()\n    \n    return (sorted[l.length/2] + sorted[l.length/2 -1])/2\n}"}
{"task_id": "typescript/16", "language": "typescript", "completion": "/**\n * You're an expert TypeScript programmer\n * \n * Checks if given string is a palindrome\n * >>> is_palindrome('')\n * True\n * >>> is_palindrome('aba')\n * True\n * >>> is_palindrome('aaaaa')\n * True\n * >>> is_palindrome('zbcd')\n * False\n * \n */\nconst is_palindrome = function (text: string) : boolean  {\n    return text.split('').reverse().join('') == text;\n}"}
{"task_id": "typescript/17", "language": "typescript", "completion": "/**\n * You're an expert TypeScript programmer\n * \n * remove_vowels is a function that takes string and returns string without vowels.\n * >>> remove_vowels('')\n * ''\n * >>> remove_vowels(\"abcdef\\nghijklm\")\n * 'bcdf\\nghjklm'\n * >>> remove_vowels('abcdef')\n * 'bcdf'\n * >>> remove_vowels('aaaaa')\n * ''\n * >>> remove_vowels('aaBAA')\n * 'B'\n * >>> remove_vowels('zbcd')\n * 'zbcd'\n * \n */\nconst remove_vowels = function (text: string) : string  {\n    // Your code here\n}"}
{"task_id": "typescript/18", "language": "typescript", "completion": "/**\n * You're an expert TypeScript programmer\n * Return True if all numbers in the list l are below threshold t.\n * >>> below_threshold([1, 2, 4, 10], 100)\n * True\n * >>> below_threshold([1, 20, 4, 10], 5)\n * False\n * \n */\nconst below_threshold = function (l: Array<number>, t: number) : boolean  {\n  return l.every(n => n < t);\n};"}
{"task_id": "typescript/19", "language": "typescript", "completion": "/**\n * You're an expert TypeScript programmer\n * Add two numbers x and y\n * >>> add(2, 3)\n * 5\n * >>> add(5, 7)\n * 12\n * \n */\nconst add = function (x: number, y: number): number {\n    return x + y;\n};"}
{"task_id": "typescript/20", "language": "typescript", "completion": "/**\n * You're an expert TypeScript programmer\n * \n * Check if two words have the same characters.\n * >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n * True\n * >>> same_chars('abcd', 'dddddddabc')\n * True\n * >>> same_chars('dddddddabc', 'abcd')\n * True\n * >>> same_chars('eabcd', 'dddddddabc')\n * False\n * >>> same_chars('abcd', 'dddddddabce')\n * False\n * >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n * False\n * \n */\nconst same_chars = function (s0: string, s1: string) : boolean  {\n    // remove all whitespaces and convert to lowercase\n    var s0lower : string = s0.replace(/\\s+/g, '').toLowerCase();\n    var s1lower : string = s1.replace(/\\s+/g, '').toLowerCase();\n\n    // if the length isn't equal, return false\n    if (s0lower.length != s1lower.length) {\n        return false;\n    }\n    \n    // create a dictionary to keep track of characters\n    let char_dict : Map<string, number> = new Map();\n\n    for (let i = 0; i < s0lower.length; i++) {\n        var c = s0lower[i];\n        if (char_dict.has(c)) {\n            // increment the count of this character in the dictionary\n            char_dict.set(c, char_dict.get(c) + 1);\n        } else {\n            // add the character to the dictionary with a value of 1\n            char_dict.set(c, 1);\n        }\n    }\n\n    for (let i = 0; i < s1lower.length; i++) {\n        var c = s1lower[i];\n        \n        if (!char_dict.has(c)) {\n            return false; // character not found in dictionary\n        } else {\n            char_dict.set(c, char_dict.get(c) - 1);\n\n            if (char_dict.get(c) < 0) {\n                return false; // too many of this character\n            }\n        }\n    }\n\n    // all characters counted\n    return true;\n}"}
{"task_id": "typescript/21", "language": "typescript", "completion": "/**\n * You're an expert TypeScript programmer\n * Return n-th Fibonacci number.\n * >>> fib(10)\n * 55\n * >>> fib(1)\n * 1\n * >>> fib(8)\n * 21\n * \n */\nconst fib = function (n: number): number {\n  // edge cases\n  if (n <= 1) return n;\n\n  // recursive approach\n  return fib(n - 1) + fib(n - 2);\n};"}
{"task_id": "typescript/22", "language": "typescript", "completion": "/**\n * You're an expert TypeScript programmer\n * Return sorted unique common elements for two lists.\n * >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n * [1, 5, 653]\n * >>> common([5, 3, 2, 8], [3, 2])\n * [2, 3]\n * \n */\nconst common = function (l1: Array<number>, l2: Array<number>) : Array<number>  {\n  const map : {[key: string]: number} = {}\n\n  for(let i=0; i<l1.length;i++){\n    let num = String(l1[i])\n    if(!map[num]){\n      map[num] = 0\n    }\n    map[num]++\n  }\n  const result : Array<number> = []\n  for(let j=0;j<l2.length;j++){\n    let num = String(l2[j])\n    if(map[num]){\n      map[num]--\n      if(map[num] === 0){\n        delete map[num]\n      }\n\n      result.push(Number(num))\n    }\n  }\n\n  return result.sort((a,b) => a-b)\n}"}
{"task_id": "typescript/23", "language": "typescript", "completion": "/**\n * You're an expert TypeScript programmer\n * Return the largest prime factor of n. Assume n > 1 and is not a prime.\n * >>> largest_prime_factor(13195)\n * 29\n * >>> largest_prime_factor(2048)\n * 2\n * \n */\nconst largest_prime_factor = function (n: number) : number  {\n    for (let i = 2; i < n; i++) {\n        if (n % i === 0 && isPrime(i)) {\n            return largest_prime_factor(n / i);\n        }\n    }\n\n    return n;\n}\n\nconst isPrime = function(num: number) : boolean {\n    for (let i = 2; i <= num/2; i++) {\n        if (num % i === 0)\n            return false;\n    }\n    return true;\n}"}
{"task_id": "typescript/24", "language": "typescript", "completion": "/**\n * You're an expert TypeScript programmer\n * sum_to_n is a function that sums numbers from 1 to n.\n * >>> sum_to_n(30)\n * 465\n * >>> sum_to_n(100)\n * 5050\n * >>> sum_to_n(5)\n * 15\n * >>> sum_to_n(10)\n * 55\n * >>> sum_to_n(1)\n * 1\n * \n */\nconst sum_to_n = function (n: number) : number  {\n\n    // Base case\n    if (n === 1) return n;\n    \n    // Recursive case\n    return n + sum_to_n(n-1);\n    \n}"}
{"task_id": "typescript/25", "language": "typescript", "completion": "/**\n * You're an expert TypeScript programmer\n * xs represent coefficients of a polynomial.\n * xs[0] + xs[1] * x + xs[2] * x^2 + ....\n * Return derivative of this polynomial in the same form.\n * >>> derivative([3, 1, 2, 4, 5])\n * [1, 4, 12, 20]\n * >>> derivative([1, 2, 3])\n * [2, 6]\n */\nconst derivative = function (xs: Array<number>) : Array<number> {\n  let result: number[] = []\n  for (let i = 0; i < xs.length - 1; i++) {\n    result.push(xs[i + 1] * (i + 1))\n  }\n  return result\n}"}
{"task_id": "typescript/26", "language": "typescript", "completion": "/**\n * You're an expert TypeScript programmer\n * The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n * fibfib(0) == 0\n * fibfib(1) == 0\n * fibfib(2) == 1\n * fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n * Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n * >>> fibfib(1)\n * 0\n * >>> fibfib(5)\n * 4\n * >>> fibfib(8)\n * 24\n * \n */\nconst fibfib = function (n: number) : number  {\n\n  const arr = [0, 0, 1]\n  for(let i=3;i<=n;i++){\n      let val = arr[i-1]+arr[i-2]+arr[i-3];\n      if(val > Number.MAX_SAFE_INTEGER){\n          return -1;\n      }\n      arr.push(val)\n  }\n\n  return n>=0?arr[n]:-1;\n};"}
{"task_id": "typescript/27", "language": "typescript", "completion": "/**\n * You're an expert TypeScript programmer\n * Write a function vowels_count which takes a string representing\n * a word as input and returns the number of vowels in the string.\n * Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n * vowel, but only when it is at the end of the given word.\n * \n * Example:\n * >>> vowels_count(\"abcde\")\n * 2\n * >>> vowels_count(\"ACEDY\")\n * 3\n * \n */\nconst vowels_count = function (s: string) : number {\n  let count = 0;\n\n  for(let i=0, len=s.length; i < len; ++i){\n    const letter = s[i];\n\n    if(letter === \"a\" || letter === \"e\" || letter === \"i\" || letter === \"o\" || letter === \"u\"){\n      count++;\n    }\n\n    if(letter === \"y\" && i === (len-1)){\n      count++;\n    }\n  }\n\n  return count;\n}"}
{"task_id": "typescript/28", "language": "typescript", "completion": "/**\n * You're an expert TypeScript programmer\n * \n * You are given a non-empty list of positive integers. Return the greatest integer that is greater than \n * zero, and has a frequency greater than or equal to the value of the integer itself. \n * The frequency of an integer is the number of times it appears in the list.\n * If no such a value exist, return -1.\n * Examples:\n * search([4, 1, 2, 2, 3, 1]) == 2\n * search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n * search([5, 5, 4, 4, 4]) == -1\n * \n */\nconst search = function (lst: Array<number>) : number  {\n    let frequencyTable : {[key:number]:number} = {};\n\n    for(let i of lst){\n        if(frequencyTable[i] !== undefined)\n            frequencyTable[i]++;\n        else\n            frequencyTable[i] = 1;\n    }\n\n    let maxFrequency : number = -1;\n    let result : number = -1;\n    \n    for (var key in frequencyTable) {\n        if (frequencyTable.hasOwnProperty(key)) {\n            if(frequencyTable[key] >= +key && +key > result){\n                result = +key;\n                maxFrequency =  frequencyTable[key];\n            }else{\n                if(frequencyTable[key] == maxFrequency && +key > result)\n                    result = +key;\n            }\n        }\n    }\n    \n    return result;\n};"}
{"task_id": "typescript/29", "language": "typescript", "completion": "/**\n * You're an expert TypeScript programmer\n * \n * Given the lengths of the three sides of a triangle. Return the area of\n * the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n * Otherwise return -1\n * Three sides make a valid triangle when the sum of any two sides is greater \n * than the third side.\n * Example:\n * triangle_area(3, 4, 5) == 6.00\n * triangle_area(1, 2, 10) == -1\n * \n */\nconst triangle_area = function (a: number, b: number, c: number) : number  {\n    if ((a + b > c) && (b + c > a) && (c + a > b)) {\n        const s = (a + b + c)/2;\n        \n        return Math.sqrt(s * (s - a) * (s - b) * (s - c)).toFixed(2);\n    } else {\n        return -1;\n    }\n}"}
{"task_id": "typescript/30", "language": "typescript", "completion": "/**\n * You're an expert TypeScript programmer\n * \n * Write a function that returns True if the object q will fly, and False otherwise.\n * The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n * \n * Example:\n * will_it_fly([1, 2], 5) \u279e False \n * # 1+2 is less than the maximum possible weight, but it's unbalanced.\n * \n * will_it_fly([3, 2, 3], 1) \u279e False\n * # it's balanced, but 3+2+3 is more than the maximum possible weight.\n * \n * will_it_fly([3, 2, 3], 9) Sarah Harrington\n * # 3+2+3 is less than the maximum possible weight, and it's balanced.\n * \n * will_it_fly([3], 5) Sarah Harrington\n * # 3 is less than the maximum possible weight, and it's balanced.\n * \n */\nconst will_it_fly = function (q: Array<number>, w: number) : boolean  {\n    if(q.length === 0)\n        return true;\n    else if(q.length === 1 && q[0] <= w)\n        return true;\n    else if(q.length === 2 && q[0] + q[1] <= w)\n        return true;\n    else{\n        let x = 0;\n        for(let i = 0; i < Math.floor((q.length+1)/2);i++){\n            x += q[i];\n        }\n\n        if(x <= w && q.reverse().slice(0,Math.ceil((q.length-1)/2)).every((value,index) => value === q[index])){\n            return true;\n        }\n        else{\n            return false;\n        }\n    }\n}"}
{"task_id": "typescript/31", "language": "typescript", "completion": "/**\n * You're an expert TypeScript programmer\n * Write a function that returns true if the given number is the multiplication of 3 prime numbers\n * and false otherwise.\n * Knowing that (a) is less then 100. \n * Example:\n * is_multiply_prime(30) == True\n * 30 = 2 * 3 * 5\n * \n */\nconst is_multiply_prime = function (a: number) : boolean  {\n    let i = 2;\n    while(i < a) {\n        if(a % i === 0 && isPrime(i)) {\n            console.log(`${i} it's prime`);\n            a = a / i;\n            i -= 1;\n            break;\n        }\n        i += 1;\n    }\n    \n    return a <= 1\n};\nconst isPrime = (num) => {\n    for(let i = 2; i < num; i++) {\n       if(num % i === 0) {\n           return false;\n       } \n    }\n    return num > 1;\n}"}
{"task_id": "typescript/32", "language": "typescript", "completion": "/**\n * You're an expert TypeScript programmer\n * You will be given a number in decimal form and your task is to convert it to\n * binary format. The function should return a string, with each character representing a binary\n * number. Each character in the string will be '0' or '1'.\n * \n * There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n * The extra characters are there to help with the format.\n * \n * Examples:\n * decimal_to_binary(15)   # returns \"db1111db\"\n * decimal_to_binary(32)   # returns \"db100000db\"\n * \n */\nconst decimal_to_binary = function (decimal: number) : string  {\n  const binaryString : string = decimal.toString(2);\n\n  // add the extra characters to the start and end of the binaryString\n  return `db${binaryString}db`;\n};"}
{"task_id": "typescript/33", "language": "typescript", "completion": "/**\n * You're an expert TypeScript programmer\n * You are given a string s.\n * Your task is to check if the string is happy or not.\n * A string is happy if its length is at least 3 and every 3 consecutive letters are distinct\n * For example:\n * is_happy(a) => False\n * is_happy(aa) => False\n * is_happy(abcd) => True\n * is_happy(aabb) => False\n * is_happy(adb) => True\n * is_happy(xyy) => False\n * \n */\nconst is_happy = function (s: string) : boolean  {\n  for (let i=0;i<s.length-2;i++){\n    if (s[i] !== s[i+1] &&\n        s[i] !== s[i+2] &&\n        s[i+1] !== s[i+2]) {\n      continue; // next iteration\n    } else {\n      return false;\n    }\n  }\n  return true;\n};"}
{"task_id": "typescript/34", "language": "typescript", "completion": "/**\n * You're an expert TypeScript programmer\n * It is the last week of the semester and the teacher has to give the grades\n * to students. The teacher has been making her own algorithm for grading.\n * The only problem is, she has lost the code she used for grading.\n * She has given you a list of GPAs for some students and you have to write \n * a function that can output a list of letter grades using the following table:\n * GPA       |    Letter grade\n * 4.0                A+\n * > 3.7                A \n * > 3.3                A- \n * > 3.0                B+\n * > 2.7                B \n * > 2.3                B-\n * > 2.0                C+\n * > 1.7                C\n * > 1.3                C-\n * > 1.0                D+ \n * > 0.7                D \n * > 0.0                D-\n * 0.0                E\n * \n * \n * Example:\n * grade_equation([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n * \n */\nconst numerical_letter_grade = function (grades: Array<number>) : Array<string>  {\n\n    let letter_grades = [];\n    for(let i=0;i < grades.length;i++){\n        if(grades[i] >=4){\n            letter_grades.push('A+');\n        }else if (grades[i] >3.7 && grades[i]< 4) {\n            letter_grades.push('A');\n\n        }else if(grades[i] >3.3 && grades[i] <3.7){\n            letter_grades.push('A-')\n        } else if (grades[i]>3.0 && grades[i]< 3.3) {\n            letter_grades.push('B+');\n\n        }else if(grades[i] >2.7 && grades[i] < 3.0){\n            letter_grades.push('B')\n        } else if (grades[i]>2.3 && grades[i]< 2.7) {\n            letter_grades.push('B-');\n\n        }else if(grades[i] >2.0 && grades[i] < 2.3){\n            letter_grades.push('C+');\n\n        } else if (grades[i]>1.7 && grades[i]< 2.0) {\n            letter_grades.push('C');\n\n        }else if(grades[i] >1.3 && grades[i] < 1.7){\n            letter_grades.push('C-');\n\n        } else if (grades[i]>1.0 && grades[i]< 1.3) {\n            letter_grades.push('D+');\n\n        }else if(grades[i] >0.7 && grades[i] < 1.0){\n            letter_grades.push('D');\n        } else if (grades[i]>0 && grades[i]< 0.7) {\n            letter_grades.push('D-');\n\n        }else{\n            letter_grades.push('E')\n        }\n    }\n\n    return letter_grades;\n}"}
{"task_id": "typescript/35", "language": "typescript", "completion": "/**\n * You're an expert TypeScript programmer\n * Write a function that takes a string and returns True if the string\n * length is a prime number or False otherwise\n * Examples\n * prime_length('Hello') == True\n * prime_length('abcdcba') == True\n * prime_length('kittens') == True\n * prime_length('orange') == False\n * \n */\nconst prime_length = function (string0: string) : boolean  {\n    const strLenght : number = string0.length;\n\n    if (strLenght === 1 || strLenght === 2)\n        return true;\n    \n    let isPrime : boolean = false;\n\n    for (let i : number = 2; i < strLenght; i++) {\n\n        if ((strLenght % i ) === 0) {\n\n            isPrime = false;\n            break;\n            \n        } else {\n            \n            isPrime = true;\n        }\n    }\n    return isPrime;\n}"}
{"task_id": "typescript/36", "language": "typescript", "completion": "/**\n * You're an expert TypeScript programmer\n * Given a positive integer N, return the total sum of its digits in binary.\n * \n * Example\n * For N = 1000, the sum of digits will be 1 the output should be \"1\".\n * For N = 150, the sum of digits will be 6 the output should be \"110\".\n * For N = 147, the sum of digits will be 12 the output should be \"1100\".\n * \n * Variables:\n * @N integer\n * Constraints: 0 \u2264 N \u2264 10000.\n * Output:\n * a string of binary number\n * \n */\nconst solve = function (N: number) : string  {\n  let sum = 0;\n  while(N > 0){\n    const digit = N % 10;\n    sum += digit;\n    console.log(`digit: ${digit}, sum:${sum}`);\n    N = Math.floor(N / 10);\n  }\n  return sum.toString(2);\n};"}
{"task_id": "typescript/37", "language": "typescript", "completion": "/**\n * You're an expert TypeScript programmer\n * \n * You are given a 2 dimensional data, as a nested lists,\n * which is similar to matrix, however, unlike matrices,\n * each row may contain a different number of columns.\n * Given lst, and integer x, find integers x in the list,\n * and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n * each tuple is a coordinate - (row, columns), starting with 0.\n * Sort coordinates initially by rows in ascending order.\n * Also, sort coordinates of the row by columns in descending order.\n * \n * Examples:\n * get_row([\n * [1,2,3,4,5,6],\n * [1,2,3,4,1,6],\n * [1,2,3,4,5,1]\n * ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n * get_row([], 1) == []\n * get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n * \n */\nconst get_row = function (lst: Array<Array<number>>, x: number) : Array<Array<number>>  {\n    let retArr: Array<Array<number>> = [];\n    for(let i = 0; i < lst.length; ++i){\n        for(let j = 0; j < lst[i].length; ++j){\n            if(lst[i][j] == x)\n                retArr.push([i, j]);\n        }\n    }\n\n    // Sort by row, then by column in descending order\n    return retArr.sort((a,b) => (a[0]>b[0])?1:((a[0]<b[0])?-1:(a[1]>b[1]?-1:(a[1]<b[1]?1:0))));\n}"}
{"task_id": "typescript/38", "language": "typescript", "completion": "/**\n * You're an expert TypeScript programmer\n * \n * You are given a list of integers.\n * Write a function next_smallest() that returns the 2nd smallest element of the list.\n * Return None if there is no such element.\n * \n * next_smallest([1, 2, 3, 4, 5]) == 2\n * next_smallest([5, 1, 4, 3, 2]) == 2\n * next_smallest([]) == None\n * next_smallest([1, 1]) == None\n * \n */\nconst next_smallest = function (lst: Array<number>) : any  {\n    let min = Math.min(...lst);\n    lst.splice(lst.indexOf(min), 1);\n    if (!lst.length)\n        return undefined;\n    return Math.min(...lst);\n};"}
{"task_id": "typescript/39", "language": "typescript", "completion": "/**\n * You're an expert TypeScript programmer\n * \n * You'll be given a string of words, and your task is to count the number\n * of boredoms. A boredom is a sentence that starts with the word \"I\".\n * Sentences are delimited by '.', '?' or '!'.\n * \n * For example:\n * >>> is_bored(\"Hello world\")\n * 0\n * >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n * 1\n * \n */\nconst is_bored = function (S: string) : number  {\n    // split into sentences\n    const re = /[.?!]\\s+/;\n    const sentences = S.split(re);\n\n    // count sentences that start with \"I\"\n    return sentences\n        .filter((sentence) => sentence.trim().startsWith(\"I\"))\n        .length;\n}"}
{"task_id": "typescript/40", "language": "typescript", "completion": "/**\n * You're an expert TypeScript programmer\n * You are given a list of integers.\n * You need to find the largest prime value and return the sum of its digits.\n * \n * Examples:\n * For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n * For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n * For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n * For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n * For lst = [0,81,12,3,1,21] the output should be 3\n * For lst = [0,8,1,2,1,7] the output should be 7\n * \n */\nconst skjkasdkd = function (lst: Array<number>) : number  {\n    // Your code here!\n    let largestPrimeValue = -1;\n    for(let i=0;i<lst.length;i++){\n        if(isPrime(lst[i])){\n            console.log(\"prime value\", lst[i]);\n            if(lst[i]>largestPrimeValue){\n                largestPrimeValue = lst[i];\n            }\n        }\n    }\n    let sumOfDigits : number = 0;\n    for(let i=0;i<String(largestPrimeValue).length;i++){\n        sumOfDigits += Number(String(largestPrimeValue)[i]);\n    }\n\n    return sumOfDigits;\n}\n\nconst isPrime = (num:number):boolean => {\n    if (num <= 1) return false;\n    for (let i = 2, s = Math.sqrt(num); i <= s; i++)\n        if (num % i === 0)\n            return false;\n    return true;\n}"}
{"task_id": "typescript/41", "language": "typescript", "completion": "/**\n * You're an expert TypeScript programmer\n * \n * Given a dictionary, return True if all keys are strings in lower \n * case or all keys are strings in upper case, else return False.\n * The function should return False is the given dictionary is empty.\n * Examples:\n * check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) should return True.\n * check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n * check_dict_case({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return False.\n * check_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n * check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n * \n */\nconst check_dict_case = function (dict: Map<any, string>) : boolean  {\n  // Get the keys from the map and convert to an array.\n  const keyArray = Array.from(dict.keys());\n\n  // If there are no keys in the dictionary return false.\n  if (keyArray.length == 0)\n    return false;\n\n  let firstCase = true;\n  for (const key of keyArray) {\n\n    // Check to see if the key is a string and if so convert it to lowercase.\n    const checkString = String(key).toLowerCase();\n\n    // If the current case does not match then set it as the opposite\n    // of the first case found.\n    if (checkString !== String(key).toLowerCase() &&\n        checkString !== String(key).toUpperCase()) {\n      firstCase = !firstCase;\n    }\n  }\n\n  return firstCase;\n}"}
{"task_id": "typescript/42", "language": "typescript", "completion": "import * as math from 'mathjs'\n\n/**\n * You're an expert TypeScript programmer\n * \n * Create a function that takes a value (string) representing a number\n * and returns the closest integer to it. If the number is equidistant\n * from two integers, round it away from zero.\n * \n * Examples\n * >>> closest_integer(\"10\")\n * 10\n * >>> closest_integer(\"15.3\")\n * 15\n * \n * Note:\n * Rounding away from zero means that if the given number is equidistant\n * from two integers, the one you should return is the one that is the\n * farthest from zero. For example closest_integer(\"14.5\") should\n * return 15 and closest_integer(\"-14.5\") should return -15.\n * \n */\nconst closest_integer = function (value: string) : number  {\n  // your code here"}
{"task_id": "typescript/43", "language": "typescript", "completion": "/**\n * You're an expert TypeScript programmer\n * \n * Given a positive integer n, you have to make a pile of n levels of stones.\n * The first level has n stones.\n * The number of stones in the next level is:\n * - the next odd number if n is odd.\n * - the next even number if n is even.\n * Return the number of stones in each level in a list, where element at index\n * i represents the number of stones in the level (i+1).\n * \n * Examples:\n * >>> make_a_pile(3)\n * [3, 5, 7]\n * \n */\nconst make_a_pile = function (n: number) : Array<number>  {\n  const result = []\n  \n  for (let i = 0; i < n; i++) {\n    if (i % 2 === 0) {\n      result.push(i + 1);\n      result.push(i + 3);\n    } else {\n      result.push(i + 2);\n      result.push(i + 4);      \n    }\n  }\n  \n  return result;\n}"}
{"task_id": "typescript/44", "language": "typescript", "completion": "/**\n * You're an expert TypeScript programmer\n * \n * You will be given a string of words separated by commas or spaces. Your task is\n * to split the string into words and return an array of the words.\n * \n * For example:\n * words_string(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n * words_string(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n */\nconst words_string = function (s: string) : Array<string>  {\n    return s.split(/[, ]/).map(x => x.trim());\n}"}
{"task_id": "typescript/45", "language": "typescript", "completion": "/**\n * You're an expert TypeScript programmer\n * This function takes two positive numbers x and y and returns the\n * biggest even integer number that is in the range [x, y] inclusive. If \n * there's no such number, then the function should return -1.\n * \n * For example:\n * choose_num(12, 15) = 14\n * choose_num(13, 12) = -1\n * \n */\nconst choose_num = function (x: number, y: number) : number  {\n    for (let i=y;i>=x;i--) {\n        if (i % 2 === 0) {\n            return i\n        }\n    }\n    return -1\n};"}
{"task_id": "typescript/46", "language": "typescript", "completion": "/**\n * You're an expert TypeScript programmer\n * You are given two positive integers n and m, and your task is to compute the\n * average of the integers from n through m (including n and m). \n * Round the answer to the nearest integer and convert that to binary.\n * If n is greater than m, return -1.\n * Example:\n * rounded_avg(1, 5) => \"0b11\"\n * rounded_avg(7, 5) => -1\n * rounded_avg(10, 20) => \"0b1111\"\n * rounded_avg(20, 33) => \"0b11010\"\n * \n */\nconst rounded_avg = function (n: number, m: number) : any {\n    let sum = 0;\n\n    if (m < n){\n        return -1;\n    } else {\n        for (let i = n; i <= m; i++) {\n            sum += i\n        }\n\n        return \"0b\" + Math.round(sum/(m-n+1)).toString(2);\n    }\n}\n\n\nconsole.log(rounded_avg(1,5)); //0b11\nconsole.log(rounded_avg(7, 5)); // -1\nconsole.log(rounded_avg(10, 20)); // 0b1111\nconsole.log(rounded_avg(20, 33)); // 0b11010"}
{"task_id": "typescript/47", "language": "typescript", "completion": "/**\n * You're an expert TypeScript programmer\n * Implement the function f that takes n as a parameter,\n * and returns a list of size n, such that the value of the element at index i is the factorial of i if i is even\n * or the sum of numbers from 1 to i otherwise.\n * i starts from 1.\n * the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n * Example:\n * f(5) == [1, 2, 6, 24, 15]\n * \n */\nconst f = function (n: number) : Array<number> {\n    let result = [];\n    for (let index = 0; index < n; index++) {\n        if (index % 2 === 0) {\n            result.push(factorial(index));\n        } else {\n            result.push(sum(index + 1));\n        }\n    }\n\n    return result;\n}\n\nfunction factorial(n: number): number {\n    let result = 1;\n    \n    for (let i = n; i > 0; i--) {\n        result *= i;\n    }\n\n    return result;\n}\n\nfunction sum(n: number): number {\n    let result = 0;\n    \n    for (let i = 1; i <= n; i++) {\n        result += i;\n    }\n\n    return result;\n}"}
{"task_id": "typescript/48", "language": "typescript", "completion": "/**\n * You're an expert TypeScript programmer\n * \n * Given a positive integer n, return a tuple that has the number of even and odd\n * integer palindromes that fall within the range(1, n), inclusive.\n * \n * Example 1:\n * \n * Input: 3\n * Output: (1, 2)\n * Explanation:\n * Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n * \n * Example 2:\n * \n * Input: 12\n * Output: (4, 6)\n * Explanation:\n * Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n * \n * Note:\n * 1. 1 <= n <= 10^3\n * 2. returned tuple has the number of even and odd integer palindromes respectively.\n * \n */\nconst even_odd_palindrome = function (n: number) : Array<number> {\n  //\n  let count_even_odd = [0, 0];\n\n  for (let num = 1; num <= n; num++) {\n    if (isEven(num)) {\n      count_even_odd[0] += isPalindrome(num);\n    } else {\n      count_even_odd[1] += isPalindrome(num);\n    }\n  }\n\n  return count_even_odd;\n};\n\nconst isPalindrome = function (x: number) : boolean {\n  let n = x, reversed = 0;\n  \n  while (n > 0) {\n    const remainder = n % 10;\n\n    reversed = (reversed * 10) + remainder;\n\n    n = Math.floor(n / 10);\n  }\n\n  return x === reversed;\n}\n\nconst isEven = function (x: number) : boolean {\n  return x % 2 === 0;\n};"}
{"task_id": "typescript/49", "language": "typescript", "completion": "/**\n * You're an expert TypeScript programmer\n * We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n * numbers in the array will be randomly ordered. Your task is to determine if\n * it is possible to get an array sorted in non-decreasing order by performing \n * the following operation on the given array:\n * You are allowed to perform right shift operation any number of times.\n * \n * One right shift operation means shifting all elements of the array by one\n * position in the right direction. The last element of the array will be moved to\n * the starting position in the array i.e. 0th index. \n * \n * If it is possible to obtain the sorted array by performing the above operation\n * then return True else return False.\n * If the given array is empty then return True.\n * \n * Note: The given list is guaranteed to have unique elements.\n * \n * For Example:\n * \n * move_one_ball([3, 4, 5, 1, 2])==>True\n * Explanation: By performin 2 right shift operations, non-decreasing order can\n * be achieved for the given array.\n * move_one_ball([3, 5, 4, 1, 2])==>False\n * Explanation:It is not possible to get non-decreasing order for the given\n * array by performing any number of right shift operations.\n */\nconst move_one_ball = function (arr: Array<number>) : boolean  {\n    if(arr.length ==0) return true;\n\n    let leftMostElement = arr[0];\n    for(let i=1;i<arr.length;i++)\n        {\n            if(leftMostElement>arr[i])\n                return false;\n            else\n                leftMostElement = arr[i];\n        }\n    return true;\n}"}
{"task_id": "typescript/50", "language": "typescript", "completion": "/**\n * You're an expert TypeScript programmer\n * In this problem, you will implement a function that takes two lists of numbers,\n * and determines whether it is possible to perform an exchange of elements\n * between them to make lst1 a list of only even numbers.\n * There is no limit on the number of exchanged elements between lst1 and lst2.\n * If it is possible to exchange elements between the lst1 and lst2 to make\n * all the elements of lst1 to be even, return \"YES\".\n * Otherwise, return \"NO\".\n * For example:\n * exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n * exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n * It is assumed that the input lists will be non-empty.\n */\nconst exchange = function (lst1: Array<number>, lst2: Array<number>) : string {\n    const odd = [];\n    for(let i = 0; i < lst1.length; i++) {\n        if (lst1[i] % 2 !== 0) {\n            odd.push(lst1[i]);\n        }\n    }\n\n    let index = 0;\n    while (odd.length > 0 && index < lst2.length) {\n        for (let i = 0; i < odd.length; i++) {\n            if (lst2[index] % 2 === 0 && odd[i] > lst2[index]) {\n                const tmp = lst2[index];\n                lst2[index] = odd[i];\n                odd[i] = tmp;\n            }\n        }\n\n        index++;\n    }\n\n    for(let i = 0; i < lst1.length; i++) {\n        if (lst1[i] % 2 !== 0) {\n            return \"NO\";\n        }\n    }\n\n    return \"YES\";\n};"}
{"task_id": "typescript/51", "language": "typescript", "completion": "/**\n * You're an expert TypeScript programmer\n * Task\n * We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\n * then check if the result string is palindrome.\n * A string is called palindrome if it reads the same backward as forward.\n * You should return a tuple containing the result string and True/False for the check.\n * Example\n * For s = \"abcde\", c = \"ae\", the result should be ('bcd',False)\n * For s = \"abcdef\", c = \"b\"  the result should be ('acdef',False)\n * For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',True)\n * \n */\nconst reverse_delete = function (s: string, c: string) : Array<any>  {\n  let resultString : String = \"\";\n  let isPalindrome : boolean = true;\n\n  for(let i = s.length -1 ;i>=0 ; i--)\n  {\n    if(!c.includes(s[i])){\n      resultString+=s[i];\n    }\n    if (resultString.length > 0 && s[i] != resultString[resultString.length-1]){\n      isPalindrome = false;\n    } \n  }\n\n  return [resultString,isPalindrome];\n}\n\n\n// Test cases\nconsole.log(reverse_delete(\"abcde\",\"ae\")); // ['bcd',false]\nconsole.log(reverse_delete(\"abcdef\",\"b\"));  // ['acdef',false]\nconsole.log(reverse_delete(\"abcdedcba\",\"ab\")); // ['cdedc',true]"}
{"task_id": "typescript/52", "language": "typescript", "completion": "import * as math from 'mathjs'\n\n/**\n * You're an expert TypeScript programmer\n * \n * You are given a rectangular grid of wells. Each row represents a single well,\n * and each 1 in a row represents a single unit of water.\n * Each well has a corresponding bucket that can be used to extract water from it, \n * and all buckets have the same capacity.\n * Your task is to use the buckets to empty the wells.\n * Output the number of times you need to lower the buckets.\n * \n * Example 1:\n * Input: \n * grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n * bucket_capacity : 1\n * Output: 6\n * \n * Example 2:\n * Input: \n * grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n * bucket_capacity : 2\n * Output: 5\n * \n * Example 3:\n * Input: \n * grid : [[0,0,0], [0,0,0]]\n * bucket_capacity : 5\n * Output: 0\n * \n * Constraints:\n * * all wells have the same length\n * * 1 <= grid.length <= 10^2\n * * 1 <= grid[:,1].length <= 10^2\n * * grid[i][j] -> 0 | 1\n * * 1 <= capacity <= 10\n */\n\n const max_fill = function (grid: Array<Array<number>>, capacity: number) : number {\n    \n    let fills = 0\n    // iterate through the columns of the matrix, starting from the rightmost column\n    for(let j=grid[0].length-1;j>=0;j--) {\n        console.log(`filling at col ${j}...`)\n        // find the first well in the row that has water (represented by 1)\n        let i_start = grid.findIndex(row => row[j] === 1)\n\n        if(i_start === -1) {\n            continue;\n        }\n        console.log(`first well found at [${i_start}, ${j}]`)\n        \n        // move the bucket from that well to the rightmost well, with enough water to fill it\n        for(let i=i_start;i>=0 && grid[i][j] === 1;i--) {\n            if (grid[i].reduce((acc, el) => acc + el, 0) <= capacity) {\n                // empty the bucket and add it to the total number of fills\n                grid[i].fill(0)\n                fills += 1\n            }\n        }\n    }\n\n    return fills\n}"}
{"task_id": "typescript/53", "language": "typescript", "completion": "/**\n * You're an expert TypeScript programmer\n * Given a string s and a natural number n, you have been tasked to implement \n * a function that returns a list of all words from string s that contain exactly \n * n consonants, in order these words appear in the string s.\n * If the string s is empty then the function should return an empty list.\n * Note: you may assume the input string contains only letters and spaces.\n * Examples:\n * select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n * select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n * select_words(\"simple white space\", 2) ==> []\n * select_words(\"Hello world\", 4) ==> [\"world\"]\n * select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\n * \n */\nconst isConsonant = (c: string): boolean => {\n    return 'bcdfghjklmnpqrstvwxyz'.indexOf(c) !== -1;\n}\n\nconst removeNonLettersAndSpaces = (s: string): string => {\n    return s.replace(/[^a-zA-Z ]/g, ''); \n}\n\nconst select_words = function (s: string, n: number) : Array<string>  {\n    let words = [];\n    const wordList = removeNonLettersAndSpaces(s).split(' ');\n    \n    for (let i=0; i < wordList.length; i++) {\n        let cCount = 0;\n\n        for (let j=0; j < wordList[i].length; j++) {\n            if (!isConsonant(wordList[i][j]))\n                cCount++; \n        }\n\n        if (cCount === n) {\n            words.push(wordList[i]);\n        }\n    }\n\n    return words;\n}"}
{"task_id": "typescript/54", "language": "typescript", "completion": "/**\n * You're an expert TypeScript programmer\n * \n * Given an array arr of integers and a positive integer k, return a sorted list \n * of length k with the maximum k numbers in arr.\n * \n * Example 1:\n * \n * Input: arr = [-3, -4, 5], k = 3\n * Output: [-4, -3, 5]\n * \n * Example 2:\n * \n * Input: arr = [4, -4, 4], k = 2\n * Output: [4, 4]\n * \n * Example 3:\n * \n * Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n * Output: [2]\n * \n * Note:\n * 1. The length of the array will be in the range of [1, 1000].\n * 2. The elements in the array will be in the range of [-1000, 1000].\n * 3. 0 <= k <= len(arr)\n * \n */\nconst maximum = function (arr: Array<number>, k: number) : Array<number>  {\n  const maxHeap = new Heap((a, b) => b - a);\n\n  for (let index = 0; index < arr.length && maxHeap.size() < k; index++) {\n    if (!maxHeap.includes(arr[index])) {\n      maxHeap.push(arr[index]);\n    }\n  }\n\n  return Array.from(maxHeap);\n};"}
{"task_id": "typescript/55", "language": "typescript", "completion": "/**\n * You're an expert TypeScript programmer\n * \n * Given a non-empty array of integers arr and an integer k, return\n * the sum of the elements with at most two digits from the first k elements of arr.\n * \n * Example:\n * \n * Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n * Output: 24 # sum of 21 + 3\n * \n * Constraints:\n * 1. 1 <= len(arr) <= 100\n * 2. 1 <= k <= len(arr)\n * \n */\nconst add_elements = function (arr: Array<number>, k: number) : number  {\n  let sum = 0;\n  for (let i=0;i<k;i++) {\n    if (String(arr[i]).length <= 2) sum += arr[i];\n  }\n  return sum;\n};"}
{"task_id": "typescript/56", "language": "typescript", "completion": "/**\n * You're an expert TypeScript programmer\n * You are given two intervals,\n * where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n * The given intervals are closed which means that the interval (start, end)\n * includes both start and end.\n * For each given interval, it is assumed that its start is less or equal its end.\n * Your task is to determine whether the length of intersection of these two \n * intervals is a prime number.\n * Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n * which its length is 1, which not a prime number.\n * If the length of the intersection is a prime number, return \"YES\",\n * otherwise, return \"NO\".\n * If the two intervals don't intersect, return \"NO\".\n * \n * \n * [input/output] samples:\n * intersection((1, 2), (2, 3)) ==> \"NO\"\n * intersection((-1, 1), (0, 4)) ==> \"NO\"\n * intersection((-3, -1), (-5, 5)) ==> \"YES\"\n * \n */\nconst intersection = function (interval1: Array<number>, interval2: Array<number>) : string {\n\n    const left = Math.max(interval1[0], interval2[0]);\n    const right = Math.min(interval1[1], interval2[1]);\n    if (left > right) return \"NO\";\n    \n    let isPrime = true;\n    for (let i = 2, s = Math.sqrt(right); i <= s; i++) {\n        if (right % i === 0) isPrime = false;\n    }\n\n    return isPrime ? \"YES\" : \"NO\";\n};"}
{"task_id": "typescript/57", "language": "typescript", "completion": "/**\n * You're an expert TypeScript programmer\n * Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n * the last couple centuries. However, what people don't know is Tribonacci sequence.\n * Tribonacci sequence is defined by the recurrence:\n * tri(1) = 3\n * tri(n) = 1 + n / 2, if n is even.\n * tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n * For example:\n * tri(2) = 1 + (2 / 2) = 2\n * tri(4) = 3\n * tri(3) = tri(2) + tri(1) + tri(4)\n * = 2 + 3 + 3 = 8 \n * You are given a non-negative integer number n, you have to a return a list of the \n * first n + 1 numbers of the Tribonacci sequence.\n * Examples:\n * tri(3) = [1, 3, 2, 8]\n */\nconst tri = function (n: number): Array<number> {\n  if (n === 0) return []\n  const result: number[] = new Array(n + 1).fill(0);\n\n  result[0] = 1;\n  result[1] = 3;\n  result[2] = 2;\n\n  for (let i = 3; i <= n; i++) {\n    if (i % 2 === 1) {\n      // Odd number\n      result[i] =\n        result[i - 1] + result[i - 2] + result[i + 1];\n    } else {\n      // Even number\n      result[i] = Math.floor(i / 2) + 1;\n    }\n  }\n\n  return result\n};"}
{"task_id": "typescript/58", "language": "typescript", "completion": "/**\n * You're an expert TypeScript programmer\n * Given a positive integer n, return the product of the odd digits.\n * Return 0 if all digits are even.\n * For example:\n * digits(1)  == 1\n * digits(4)  == 0\n * digits(235) == 15\n */\nconst digits = function (n: number) : number {\n  let product = 1;\n\n  while (n > 0) {\n    const digit = n % 10;\n\n    if (digit % 2 !== 0) {\n      product *= digit;\n    }\n\n    n = Math.floor(n / 10);\n  }\n\n  return product;\n};"}
{"task_id": "typescript/59", "language": "typescript", "completion": "/**\n * You're an expert TypeScript programmer\n * \n * Create a function that takes a string as input which contains only square brackets.\n * The function should return True if and only if there is a valid subsequence of brackets \n * where at least one bracket in the subsequence is nested.\n * \n * is_nested('[[]]')\ufffd\ufffd True\n * is_nested('[]]]]]]][[[[[]')\ufffd\ufffd False\n * is_nested('[][]')\ufffd\ufffd False\n * is_nested('[]')\ufffd\ufffd False\n * is_nested('[[][]]')\ufffd\ufffd True\n * is_nested('[[]][[')\ufffd\ufffd True\n * \n */\nconst is_nested = function (string0: string) : boolean  {\n    let leftBrackets = 0;\n    for (let i = 0; i < string0.length; i++) {\n        const element = string0[i];\n        if(element === \"[\") {\n            leftBrackets += 1;\n        } else if(element === \"]\"){\n            if(leftBrackets === 0) return false;\n            leftBrackets -= 1;\n        }\n    }\n\n    return leftBrackets > 0;\n}"}
{"task_id": "typescript/60", "language": "typescript", "completion": "import * as math from 'mathjs'\n\n/**\n * You're an expert TypeScript programmer\n * You are given a list of numbers.\n * You need to return the sum of squared numbers in the given list,\n * round each element in the list to the upper int(Ceiling) first.\n * Examples:\n * For lst = [1,2,3] the output should be 14\n * For lst = [1,4,9] the output should be 98\n * For lst = [1,3,5,7] the output should be 84\n * For lst = [1.4,4.2,0] the output should be 29\n * For lst = [-2.4,1,1] the output should be 6\n * \n * \n * \n */\nconst sum_squares = function (lst: Array<number>) : number  {\n  let roundedList: Array<number> = [];\n\n  for (let i = 0; i < lst.length; i++) {\n    roundedList.push(Math.ceil(lst[i]));\n  }\n\n  let squaredList: Array<number> = roundedList.map(function(x) { return x * x});\n\n  let sum = 0;\n\n  for (let i = 0; i < squaredList.length; i++) {\n    sum += squaredList[i];\n  }\n\n  return sum;\n}"}
{"task_id": "typescript/61", "language": "typescript", "completion": "/**\n * You're an expert TypeScript programmer\n * \n * Create a function that returns True if the last character\n * of a given string is an alphabetical character and is not\n * a part of a word, and False otherwise.\n * Note: \"word\" is a group of characters separated by space.\n * \n * Examples:\n * check_if_last_char_is_a_letter(\"apple pie\") \u279e False\n * check_if_last_char_is_a_letter(\"apple pi e\") \u279e True\n * check_if_last_char_is_a_letter(\"apple pi e \") \u279e False\n * check_if_last_char_is_a_letter(\"\") \u279e False \n * \n */\nconst check_if_last_char_is_a_letter = function (txt: string) : boolean  {\n\n  if( txt.length === 0 )\n    return false;\n  let i = txt.length - 1;\n  \n  while(i >= 0){\n  \n    if( txt[i] === ' ' && txt[i+1] !== ' ')\n      return false;\n    else if(!txt[i].match(/[a-z]/i))\n      return false;\n    \n    i--;\n  }\n\n  return true;\n}"}
{"task_id": "typescript/62", "language": "typescript", "completion": "/**\n * You're an expert TypeScript programmer\n * Create a function which returns the largest index of an element which\n * is not greater than or equal to the element immediately preceding it. If\n * no such element exists then return -1. The given array will not contain\n * duplicate values.\n * \n * Examples:\n * can_arrange([1,2,4,3,5]) = 3\n * can_arrange([1,2,3]) = -1\n * \n */\nconst can_arrange = function (arr: Array<number>) : number  {\n    for(let i=arr.length-1;i>=0;i--) {\n        if (arr[i]<= arr[i-1])\n            return i;\n    }\n    return -1;\n}"}
{"task_id": "typescript/63", "language": "typescript", "completion": "/**\n * You're an expert TypeScript programmer\n * \n * Create a function that returns a tuple (a, b), where 'a' is\n * the largest of negative integers, and 'b' is the smallest\n * of positive integers in a list.\n * If there is no negative or positive integers, return them as None.\n * \n * Examples:\n * largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n * largest_smallest_integers([]) == (None, None)\n * largest_smallest_integers([0]) == (None, None)\n * \n */\nconst largest_smallest_integers = function (lst: Array<number>) : Array<any>  {\n  let maxNegative = null;\n  let minPositive = null;\n\n  for(let i = 0; i < lst.length; i++) {\n    if(lst[i] > 0 && (minPositive === null || lst[i] < minPositive)) {\n      minPositive = lst[i];\n    }\n\n    if(lst[i] < 0 && (maxNegative === null || lst[i] > maxNegative)) {\n      maxNegative = lst[i];\n    }\n  }\n\n  return [maxNegative, minPositive];\n}"}
{"task_id": "typescript/64", "language": "typescript", "completion": "/**\n * You're an expert TypeScript programmer\n * The Brazilian factorial is defined as:\n * brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n * where n > 0\n * \n * For example:\n * >>> special_factorial(4)\n * 288\n * \n * The function will receive an integer as input and should return the special\n * factorial of this integer.\n */\nconst special_factorial = function (n: number) : number {\n  // Base case: if n is 0 or 1, the special factorial is 1\n  if (n === 0 || n === 1) {\n    return 1;\n  }\n\n  // Recursive step: calculate the special factorial of n-1 and multiply it by n\n  return special_factorial(n - 1) * n;\n}"}
{"task_id": "typescript/65", "language": "typescript", "completion": "/**\n * You're an expert TypeScript programmer\n * \n * You are given a string representing a sentence,\n * the sentence contains some words separated by a space,\n * and you have to return a string that contains the words from the original sentence,\n * whose lengths are prime numbers,\n * the order of the words in the new string should be the same as the original one.\n * \n * Example 1:\n * Input: sentence = \"This is a test\"\n * Output: \"is\"\n * \n * Example 2:\n * Input: sentence = \"lets go for swimming\"\n * Output: \"go for\"\n * \n * Constraints:\n * * 1 <= len(sentence) <= 100\n * * sentence contains only letters\n * \n */\nconst words_in_sentence = function (sentence: string) : string  {\n\n    let res:string = \"\";\n    let isPrime:boolean;\n    for (let i = 0; i < sentence.length; i++) \n    {\n        if(i === 0 && !isAlpha(sentence[i]))\n            continue;\n        else if(!isAlpha(sentence[i-1]) && isAlpha(sentence[i])){\n            let word:string = \"\";\n            word += sentence[i];\n            isPrime = true;\n            for (let j = 2, sqrtJ = Math.sqrt(j); j <= sqrtJ; j++) {\n                if(word.length % j === 0) {\n                    isPrime = false;\n                    break;\n                } \n            }\n            if(isPrime)\n                res += word + \" \";\n        }\n        else if (isAlpha(sentence[i]) && !isAlpha(sentence[i+1])){\n            \n            let word:string = \"\";\n            for (let j = i; j >= 0; j--) {\n                if(!isAlpha(sentence[j]))\n                    break;\n                word += sentence[j];\n            }\n\n            isPrime = true;\n            for (let k = 2, sqrtK = Math.sqrt(k); k <= sqrtK; k++) {\n                if(word.length % k === 0) {\n                    isPrime = false;\n                    break;\n                } \n            }\n            \n            if(isPrime)\n                res += word + \" \";\n        }\n    }\n    \n    return res;\n};\n\nfunction isAlpha(c:string):boolean{\n\n    const alpha_lower = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'];\n    const alpha_upper = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n\n    if(alpha_lower.includes(c) || alpha_upper.includes(c))\n        return true;\n    else\n        return false;\n}"}
{"task_id": "typescript/66", "language": "typescript", "completion": "/**\n * You're an expert TypeScript programmer\n * Your task is to implement a function that will simplify the expression\n * x * n. The function returns True if x * n evaluates to a whole number and False\n * otherwise. Both x and n, are string representation of a fraction, and have the following format,\n * <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n * \n * You can assume that x, and n are valid fractions, and do not have zero as denominator.\n * \n * simplify(\"1/5\", \"5/1\") = True\n * simplify(\"1/6\", \"2/1\") = False\n * simplify(\"7/10\", \"10/2\") = False\n * \n */\nconst simplify = function (x: string, n: string) : boolean  {\n\n    let xArray = x.split(\"/\")\n    let nArray = n.split(\"/\")\n\n    let numeratorX = parseInt(xArray[0])\n    let denominatorX = parseInt(xArray[1])\n    let numeratorN = parseInt(nArray[0])\n    let denominatorN = parseInt(nArray[1])\n\n    if (denominatorX * denominatorN === 0) {\n        return false\n    }\n\n    return (numeratorX * denominatorN === denominatorX * numeratorN)\n}"}
{"task_id": "typescript/67", "language": "typescript", "completion": "/**\n * You're an expert TypeScript programmer\n * \n * Write a function which sorts the given list of integers\n * in ascending order according to the sum of their digits.\n * Note: if there are several items with similar sum of their digits,\n * order them based on their index in original list.\n * \n * For example:\n * >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n * >>> order_by_points([]) == []\n * \n */\nconst order_by_points = function (nums: Array<number>) : Array<number>  {\n    return nums.sort((a, b) => get_sum(a) - get_sum(b) || a - b);\n\n    function get_sum(n: number): number {\n        let sum = 0;\n        while (n > 0) {\n            const lastDigit = n % 10;\n            sum += lastDigit;\n            n = Math.floor(n / 10);\n        }\n\n        return sum;\n    }\n}"}
{"task_id": "typescript/68", "language": "typescript", "completion": "/**\n * You're an expert TypeScript programmer\n * Write a function that takes an array of numbers as input and returns \n * the number of elements in the array that are greater than 10 and both \n * first and last digits of a number are odd (1, 3, 5, 7, 9).\n * For example:\n * specialFilter([15, -73, 14, -15]) => 1 \n * specialFilter([33, -2, -3, 45, 21, 109]) => 2\n * \n */\nconst specialFilter = function (nums: Array<number>) : number  {\n    let count : number = 0;\n\n    for(let index = 0; index < nums.length; index++) {\n        if (Math.abs(nums[index]) > 10) {\n            // get the first and last digits\n            let firstDigit = Math.floor(Math.abs(nums[index]) / 10);\n            let secondDigit = Math.floor(Math.abs(nums[index]) % 10);\n\n            if (firstDigit === 1 || firstDigit === 3 || firstDigit === 5 || \n                firstDigit === 7 || firstDigit === 9 &&\n                secondDigit === 1 || secondDigit === 3 || secondDigit === 5 || \n                secondDigit === 7 || secondDigit === 9) {\n                    count++;\n            }\n        }\n    }\n\n    return count;\n}"}
{"task_id": "typescript/69", "language": "typescript", "completion": "/**\n * You're an expert TypeScript programmer\n * \n * You are given a positive integer n. You have to create an integer array a of length n.\n * For each i (1 \u2264 i \u2264 n), the value of a[i] = i * i - i + 1.\n * Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n * and a[i] + a[j] + a[k] is a multiple of 3.\n * \n * Example :\n * Input: n = 5\n * Output: 1\n * Explanation: \n * a = [1, 3, 7, 13, 21]\n * The only valid triple is (1, 7, 13).\n * \n */\nconst get_max_triples = function (n: number) : number  {\n    let i, j, k;\n\n    const a = new Array(n);\n\n    for (i = 0; i < n; i++)\n        a[i] = i * i - i + 1;\n    \n    // count the elements that are multiples of 3\n    const c3 = Math.floor(n / 3);\n    let mod_count = [0, 0, 0];\n\n    for (i = 0; i < n; i++)\n        mod_count[a[i] % 3]++;\n\n    // count the number of triples where a[i] + a[j] + a[k] is a multiple of 3\n    let t = c3 * (mod_count[1] + mod_count[2]);\n\n    for (i = 0; i < n && mod_count[0] > 0; i++) {\n        const m = a[i];\n\n        if (m % 3 == 0)\n            continue;\n\n        for (j = i+1; j < n && mod_count[(3 - m%3)%3] > 0; j++) {\n            const m2 = a[j];\n\n            if ((m + m2) % 3 != 0)\n                continue;\n\n            for (k = j + 1; k < n && mod_count[2] > 0; k++) {\n                const m3 = a[k];\n\n                if ((m + m2 + m3) % 3 != 0)\n                    continue;\n\n                t++;\n                mod_count[(m%3)%3]--;\n            }\n\n            // reset count for this value of j\n            mod_count[(m2%3)%3]++;\n        }\n\n        // reset count for this value of i\n        mod_count[m % 3]++;\n    }\n\n    return t;\n}"}
{"task_id": "typescript/70", "language": "typescript", "completion": "/**\n * You're an expert TypeScript programmer\n * \n * There are eight planets in our solar system: the closerst to the Sun \n * is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n * Uranus, Neptune.\n * Write a function that takes two planet names as strings planet1 and planet2. \n * The function should return a tuple containing all planets whose orbits are \n * located between the orbit of planet1 and the orbit of planet2, sorted by \n * the proximity to the sun. \n * The function should return an empty tuple if planet1 or planet2\n * are not correct planet names. \n * Examples\n * bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n * bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n * bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n * \n */\nconst bf = function (planet1: string, planet2: string) : Array<string>  {"}
{"task_id": "typescript/71", "language": "typescript", "completion": "/**\n * You're an expert TypeScript programmer\n * A simple program which should return the value of x if n is \n * a prime number and should return the value of y otherwise.\n * \n * Examples:\n * for x_or_y(7, 34, 12) == 34\n * for x_or_y(15, 8, 5) == 5\n * \n */\nconst isPrime = (n : number) => {\n    if (n < 2) return false;\n    \n    for (let i=2; i<=Math.sqrt(n); i++) {\n        if (n % i === 0) return false;\n    }\n    return true;\n};\n\nconst x_or_y = function (n: number, x: number, y: number) : number  {\n    if (isPrime(n)) {\n        return x;\n    } else {\n        return y;\n    }\n};"}
{"task_id": "typescript/72", "language": "typescript", "completion": "/**\n * You're an expert TypeScript programmer\n * \n * Given a list of numbers, return the sum of squares of the numbers\n * in the list that are odd. Ignore numbers that are negative or not integers.\n * \n * double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n * double_the_difference([-1, -2, 0]) == 0\n * double_the_difference([9, -2]) == 81\n * double_the_difference([0]) == 0  \n * \n * If the input list is empty, return 0.\n * \n */\nconst double_the_difference = function (lst: Array<number>) : number  {\n  let outputSum = 0;\n\n  if (lst.length === 0)\n    return 0;\n\n  for (let num of lst) {\n    // Is it an integer?\n    if (num % 1 != 0 || num < 0)\n      continue;\n\n    // Is it odd?\n    if (num % 2 == 1)\n      outputSum += Math.pow(num, 2);\n  }\n\n  return outputSum;\n}"}
{"task_id": "typescript/73", "language": "typescript", "completion": "/**\n * You're an expert TypeScript programmer\n * You will be given the name of a class (a string) and a list of extensions.\n * The extensions are to be used to load additional classes to the class. The\n * strength of the extension is as follows: Let CAP be the number of the uppercase\n * letters in the extension's name, and let SM be the number of lowercase letters \n * in the extension's name, the strength is given by the fraction CAP - SM. \n * You should find the strongest extension and return a string in this \n * format: ClassName.StrongestExtensionName.\n * If there are two or more extensions with the same strength, you should\n * choose the one that comes first in the list.\n * For example, if you are given \"Slices\" as the class and a list of the\n * extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n * return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n * (its strength is -1).\n * Example:\n * for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n * \n */\nconst Strongest_Extension = function (class_name: string, extensions: Array<string>) : string  {\n  let strongestExtension = '';\n\n  for(let i = 0; i < extensions.length; i++)\n  {\n    if(extensions[i].split('').filter(x => x === x.toUpperCase()).length >\n      extensions[strongestExtension].split('').filter(x => x === x.toUpperCase()).length)\n    {\n      strongestExtension = extensions[i];\n    }\n  }\n\n  return `${class_name}.${strongestExtension}`;\n}"}
{"task_id": "typescript/74", "language": "typescript", "completion": "/**\n * You're an expert TypeScript programmer\n * You are given 2 words. You need to return True if the second word or any of its rotations is a substring in the first word\n * cycpattern_check(\"abcd\",\"abd\") => False\n * cycpattern_check(\"hello\",\"ell\") => True\n * cycpattern_check(\"whassup\",\"psus\") => False\n * cycpattern_check(\"abab\",\"baa\") => True\n * cycpattern_check(\"efef\",\"eeff\") => False\n * cycpattern_check(\"himenss\",\"simen\") => True\n * \n */\nconst cycpattern_check = function (a: string, b: string) : boolean  {\n    let index = a.indexOf(b);\n    if (index > -1)\n        return true;\n    for (let i =0;i<b.length-1;i++)\n        b = b[b.length-1] + b.substring(0,b.length-1);\n    index = a.indexOf(b);\n    console.log(index);\n    if (index > -1)\n        return true;\n    return false;\n}"}
{"task_id": "typescript/75", "language": "typescript", "completion": "/**\n * You're an expert TypeScript programmer\n * \n * Given a positive integer, obtain its roman numeral equivalent as a string,\n * and return it in lowercase.\n * Restrictions: 1 <= num <= 1000\n * \n * Examples:\n * >>> int_to_mini_roman(19) == 'xix'\n * >>> int_to_mini_roman(152) == 'clii'\n * >>> int_to_mini_roman(426) == 'cdxxvi'\n * \n */\nconst int_to_mini_roman = function (number0: number) : string  {\n    // https://www.freecodecamp.org/news/convert-number-into-roman-numerals-javascript/\n\n    const values: {[index:string]: number} = {'i':1,'v':5,'x':10,'l':50,'c':100,'d':500,'m':1000};\n    let numString : string = String(number0);\n    let result : string = \"\";\n    for (let i=numString.length-1; i>=0 ; i--) {\n        if (values[numString.charAt(i)]){\n            let value_char: number = values[numString.charAt(i)];\n            if (value_char >= 5 && numString.charAt(i) > numString.charAt(i+1)){\n                result += (result.length > 0)? ' '+result : '';\n                result += \"IVXLCDM\".charAt(4*(\"IX\".indexOf(numString.charAt(i)))-3);\n            } else {\n                let n = Math.floor(i/2);\n                for (let j=0;j<n;j++)\n                    result += values[Object.keys(values)[Object.keys(values).length-1]];\n                result += numString.charAt(i);\n            }\n        }\n    }\n\n    return result;\n}"}
{"task_id": "typescript/76", "language": "typescript", "completion": "/**\n * You're an expert TypeScript programmer\n * \n * Given the lengths of the three sides of a triangle. Return True if the three\n * sides form a right-angled triangle, False otherwise.\n * A right-angled triangle is a triangle in which one angle is right angle or \n * 90 degree.\n * Example:\n * right_angle_triangle(3, 4, 5) == True\n * right_angle_triangle(1, 2, 3) == False\n * \n */\nconst right_angle_triangle = function (a: number, b: number, c: number) : boolean  {\n    let sortedSides = [a, b, c].sort((a,b) => a - b);\n    return (sortedSides[2] ** 2) == (sortedSides[0] ** 2 + sortedSides[1] ** 2);\n}"}
{"task_id": "typescript/77", "language": "typescript", "completion": "/**\n * You're an expert TypeScript programmer\n * You are given a string s.\n * if s[i] is a letter, reverse its case from lower to upper or vise versa, \n * otherwise keep it as it is.\n * If the string contains no letters, reverse the string.\n * The function should return the resulted string.\n * Examples\n * solve(\"1234\") = \"4321\"\n * solve(\"ab\") = \"AB\"\n * solve(\"#a@C\") = \"#A@c\"\n * \n */\nconst solve = function (s: string) : string  {\n    \n    const regExp=/[a-zA-Z]/g;\n    let result=regExp.test(s);\n\n    if(!result){\n        s=s.split(\"\").reverse().join(\"\")\n    }else{\n        for(let i=0;i<s.length;i++){\n            if(/[a-z]/.test(s[i])){\n                // console.log(s.charCodeAt(i)-32);\n                let code = s.charCodeAt(i)>=65 && s.charCodeAt(i)<=90 ? s.charCodeAt(i)+32 : s.charCodeAt(i)-32;\n                result=String.fromCharCode(code)\n                s=`${s.slice(0,i)}${result}${s.slice(i+1)}`;\n            }\n        }\n    }\n\n    return s\n};"}
{"task_id": "typescript/78", "language": "typescript", "completion": "/**\n * You're an expert TypeScript programmer\n * \n * Given a string 'text', return its md5 hash equivalent string.\n * If 'text' is an empty string, return None.\n * \n * >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n * \n */\nconst string_to_md5 = function (text: string) : any  {"}
{"task_id": "typescript/79", "language": "typescript", "completion": "/**\n * You're an expert TypeScript programmer\n * \n * Given two positive integers a and b, return the even digits between a\n * and b, in ascending order.\n * \n * For example:\n * generate_integers(2, 8) => [2, 4, 6, 8]\n * generate_integers(8, 2) => [2, 4, 6, 8]\n * generate_integers(10, 14) => []\n * \n */\nconst generate_integers = function (a: number, b: number) : Array<number> {\n  const output: Array<number> = [];\n\n  if (b < a) return output;\n\n  for (let i = a; i <= b; i++) {\n    if (i % 2 == 0) output.push(i);\n  }\n\n  return output;\n};"}
