{"task_id": "kotlin/0", "language": "kotlin", "completion": "/**\n * You are an expert Kotlin programmer, and here is your task.\n * You're given a list of deposit and withdrawal operations on a bank account that starts with\n * zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n * at that point function should return True. Otherwise it should return False.\n * >>> below_zero([1, 2, 3])\n * False\n * >>> below_zero([1, 2, -4, 5])\n * True\n *\n */\nfun belowZero(operations : List<Any>) : Boolean {\n    var balance = 0\n\n    operations.forEach {\n        if (it is Int)\n            balance += it\n        else\n            balance -= it\n\n        if (balance < 0) return true\n    }\n    return false\n}"}
{"task_id": "kotlin/1", "language": "kotlin", "completion": "/**\n * You are an expert Kotlin programmer, and here is your task.\n * For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n * Empty sum should be equal to 0 and empty product should be equal to 1.\n * >>> sum_product([])\n * (0, 1)\n * >>> sum_product([1, 2, 3, 4])\n * (10, 24)\n *\n */\nfun sumProduct(numbers : List<Any>) : List<Int> {\n    var sum = 0\n    var product = 1\n\n    for (item in numbers){\n        if(item is Int || item is Long ){\n            val number = item as Number\n            sum += number.toInt()\n            product *= number.toInt()\n        }\n\n    }\n    return listOf(sum,product)\n}"}
{"task_id": "kotlin/2", "language": "kotlin", "completion": "/**\n * You are an expert Kotlin programmer, and here is your task.\n * Input are two strings a and b consisting only of 1s and 0s.\n * Perform binary XOR on these inputs and return result also as a string.\n * >>> string_xor('010', '110')\n * '100'\n */\nfun stringXor(a : String, b : String) : String {\n    var result = \"\"\n    for (i in a.indices) {\n        val xor = if (a[i] == b[i]) \"0\" else \"1\"\n        result += xor\n    }\n    return result\n}"}
{"task_id": "kotlin/3", "language": "kotlin", "completion": "/**\n * You are an expert Kotlin programmer, and here is your task.\n * Out of list of strings, return the longest one. Return the first one in case of multiple\n * strings of the same length. Return  in case the input list is empty.\n * >>> longest([])\n\n * >>> longest(['a', 'b', 'c'])\n * 'a'\n * >>> longest(['a', 'bb', 'ccc'])\n * 'ccc'\n *\n */\nfun longest(strings : List<String>) : String? {\n    if (strings.isEmpty()) return null\n\n    var index = 0\n    for ((index, string) in strings.withIndex()){\n        if (string.length > strings[index].length){\n            index = index\n        }\n    }\n    println(\"the longest string is $index\")\n    return strings[index]\n}"}
{"task_id": "kotlin/4", "language": "kotlin", "completion": "/**\n * You are an expert Kotlin programmer, and here is your task.\n * Return a greatest common divisor of two integers a and b\n * >>> greatest_common_divisor(3, 5)\n * 1\n * >>> greatest_common_divisor(25, 15)\n * 5\n *\n */\nfun greatestCommonDivisor(a : Int, b : Int) : Int {\n    return if (b == 0) a else greatestCommonDivisor(b, a % b)\n}"}
{"task_id": "kotlin/5", "language": "kotlin", "completion": "/**\n * You are an expert Kotlin programmer, and here is your task.\n * Input is a space-delimited string of numberals from 'zero' to 'nine'.\n * Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n * Return the string with numbers sorted from smallest to largest\n * >>> sort_numbers('three one five')\n * 'one three five'\n *\n */\nfun sortNumbers(numbers : String) : String {\n    val numberList = numbers.split(\" \")\n\n    return numberList\n        .sortedWith(compareBy<String> { it.toInt() })\n        .joinToString(\" \")\n}"}
{"task_id": "kotlin/6", "language": "kotlin", "completion": "/**\n * You are an expert Kotlin programmer, and here is your task.\n * Given list of numbers (of at least two elements), apply a linear transform to that list,\n * such that the smallest number will become 0 and the largest will become 1\n * >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n * [0.0, 0.25, 0.5, 0.75, 1.0]\n */\nfun rescaleToUnit(numbers: List<Double>) : List<Double> {\n    val min = numbers.min()!!\n    val max = numbers.max()!!\n    return numbers.map{ (it - min) / (max - min)}\n}"}
{"task_id": "kotlin/7", "language": "kotlin", "completion": "/**\n * You are an expert Kotlin programmer, and here is your task.\n * For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n * >>> flip_case('Hello')\n * 'hELLO'\n *\n */\nfun flipCase(string : String) : String {\n    val result = StringBuilder()\n\n    for (char in string){\n        if ((intArrayOf('a'.code, 'b'.code, 'c'.code))\n                .contains(intArrayOf(char.toLowerCase().code))) {\n            result.append(Character.toUpperCase(char))\n        } else {\n            result.append(Character.toLowerCase(char))\n        }\n    }\n\n    return result.toString()\n}"}
{"task_id": "kotlin/8", "language": "kotlin", "completion": "/**\n * You are an expert Kotlin programmer, and here is your task.\n * Return only positive numbers in the list.\n * >>> get_positive([-1, 2, -4, 5, 6])\n * [2, 5, 6]\n * >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n * [5, 3, 2, 3, 9, 123, 1]\n *\n */\nfun getPositive(l : List<Any>) : List<Any> {\n    return l.filterIsInstance<Number>().filter { it > 0 }\n}"}
{"task_id": "kotlin/9", "language": "kotlin", "completion": "/**\n * You are an expert Kotlin programmer, and here is your task.\n * Return true if a given number is prime, and false otherwise.\n * >>> is_prime(6)\n * False\n * >>> is_prime(101)\n * True\n * >>> is_prime(11)\n * True\n * >>> is_prime(13441)\n * True\n * >>> is_prime(61)\n * True\n * >>> is_prime(4)\n * False\n * >>> is_prime(1)\n * False\n */\nfun isPrime(n: Int): Boolean {\n    if (n < 2) return false\n\n    for (x in 2..Math.sqrt(n.toDouble()).toInt())\n        if (n % x == 0)\n            return false\n\n    return true;\n}"}
{"task_id": "kotlin/10", "language": "kotlin", "completion": "/**\n * You are an expert Kotlin programmer, and here is your task.\n * Return sorted unique elements in a list\n * >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n * [0, 2, 3, 5, 9, 123]\n */\nfun unique(l : List<Int>) : List<Int> {\n    val set = HashSet<Int>()\n    for (e in l)\n        set.add(e)\n\n    // Create a result list of size equal to the number of elements in the set\n    var i = 0\n    val r = ArrayList<Int>(set.size)\n    for (e in set) {\n        r[i] = e\n        ++i\n    }\n\n    // Sort the array using a stable sorting algorithm, like merge sort\n    r.sort()\n\n    return r\n}"}
{"task_id": "kotlin/11", "language": "kotlin", "completion": "/**\n * You are an expert Kotlin programmer, and here is your task.\n * * prime_fib returns n-th number that is a Fibonacci number and it's also prime.\n * >>> prime_fib(1)\n * 2\n * >>> prime_fib(2)\n * 3\n * >>> prime_fib(3)\n * 5\n * >>> prime_fib(4)\n * 13\n * >>> prime_fib(5)\n * 89\n *\n */\nfun primeFib(n : Int) : Int {\n    var first = 0L\n    var second = 1L\n    if (n == 1)\n        return first.toInt()\n    else if (n == 2)\n        return second.toInt()\n\n    for (i in 3..n) {\n\n        val temp = first + second\n\n        if (isPrime(temp)) {\n            first = second\n            second = temp\n\n            if (i == n)\n                return temp.toInt()\n        }\n    }\n\n    return -1\n}\n\nfun isPrime(n : Long): Boolean{\n    for(i in 2..Math.sqrt(n).toLong()){\n        if (n % i == 0L)\n            return false\n    }\n    return true\n}"}
{"task_id": "kotlin/12", "language": "kotlin", "completion": "/**\n * You are an expert Kotlin programmer, and here is your task.\n * * triples_sum_to_zero takes a list of integers as an input.\n * it returns True if there are three distinct elements in the list that\n * sum to zero, and False otherwise.\n\n * >>> triples_sum_to_zero([1, 3, 5, 0])\n * False\n * >>> triples_sum_to_zero([1, 3, -2, 1])\n * True\n * >>> triples_sum_to_zero([1, 2, 3, 7])\n * False\n * >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n * True\n * >>> triples_sum_to_zero([1])\n * False\n *\n */\nfun triplesSumToZero(l : List<Int>) : Boolean {\n    var result = false\n\n    l.forEach {\n        l.filter { it < 0 }.map {\n            if (-it in l) {\n                result = true\n                return@forEach\n            }\n        }\n    }\n\n    return result\n}"}
{"task_id": "kotlin/13", "language": "kotlin", "completion": "/**\n * You are an expert Kotlin programmer, and here is your task.\n * * pairs_sum_to_zero takes a list of integers as an input.\n * it returns True if there are two distinct elements in the list that\n * sum to zero, and False otherwise.\n * >>> pairs_sum_to_zero([1, 3, 5, 0])\n * False\n * >>> pairs_sum_to_zero([1, 3, -2, 1])\n * False\n * >>> pairs_sum_to_zero([1, 2, 3, 7])\n * False\n * >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n * True\n * >>> pairs_sum_to_zero([1])\n * False\n *\n */\nfun pairsSumToZero(l : List<Int>) : Boolean {\n    for (i in l) {\n        for (j in l) {\n            if (i != j && i + j == 0) {\n                return true\n            }\n        }\n    }\n    return false\n}"}
{"task_id": "kotlin/14", "language": "kotlin", "completion": "/**\n * You are an expert Kotlin programmer, and here is your task.\n * The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n * fib4(0) -> 0\n * fib4(1) -> 0\n * fib4(2) -> 2\n * fib4(3) -> 0\n * fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n * Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n * >>> fib4(5)\n * 4\n * >>> fib4(6)\n * 8\n * >>> fib4(7)\n * 14\n *\n */\nfun fib4(n : Int) : Int {\n    if (n < 0) return -1\n\n    val fib = LongArray(n+1)\n    fib[0] = 0L;\n    fib[1] = 0L;\n    fib[2] = 2L;\n\n    for (i in 3..n)\n        fib[i] = fib[i-1]+fib[i-2]+fib[i-3]+fib[i-4];\n\n    return fib[n].toInt()\n}"}
{"task_id": "kotlin/15", "language": "kotlin", "completion": "/**\n * You are an expert Kotlin programmer, and here is your task.\n * Return median of elements in the list l.\n * >>> median([3, 1, 2, 4, 5])\n * 3\n * >>> median([-10, 4, 6, 1000, 10, 20])\n * 15.0\n */\nfun median(l : List<Int>) : Any {\n    val sorted = l.sorted()\n\n    if (sorted.size % 2 == 1)\n        return sorted[sorted.size / 2]\n    else {\n        val index = sorted.size / 2\n        return (sorted[index - 1].toDouble() + sorted[index].toDouble()) / 2\n    }\n}"}
{"task_id": "kotlin/16", "language": "kotlin", "completion": "/**\n * You are an expert Kotlin programmer, and here is your task.\n * * Checks if given string is a palindrome\n * >>> is_palindrome('')\n * True\n * >>> is_palindrome('aba')\n * True\n * >>> is_palindrome('aaaaa')\n * True\n * >>> is_palindrome('zbcd')\n * False\n */\nfun main(args: Array<String>) {\n    println(\"Is 'abba' a palindrome? \" + isPalindrome(\"abba\"))\n}\n\nfun isPalindrome(text : String) : Boolean {\n    var reversedText = \"\"\n    for (i in text.length - 1 downTo 0) {\n        reversedText += text[i]\n    }\n\n    return reversedText == text\n}"}
{"task_id": "kotlin/17", "language": "kotlin", "completion": "/**\n * You are an expert Kotlin programmer, and here is your task.\n * * remove_vowels is a function that takes string and returns string without vowels.\n * >>> remove_vowels('')\n * ''\n * >>> remove_vowels(\"abcdef\\nghijklm\")\n * 'bcdf\\nghjklm'\n * >>> remove_vowels('abcdef')\n * 'bcdf'\n * >>> remove_vowels('aaaaa')\n * ''\n * >>> remove_vowels('aaBAA')\n * 'B'\n * >>> remove_vowels('zbcd')\n * 'zbcd'\n *\n */\nfun removeVowels(text : String) : String {"}
{"task_id": "kotlin/18", "language": "kotlin", "completion": "/**\n * You are an expert Kotlin programmer, and here is your task.\n * Return True if all numbers in the list l are below threshold t.\n * >>> below_threshold([1, 2, 4, 10], 100)\n * True\n * >>> below_threshold([1, 20, 4, 10], 5)\n * False\n *\n */\nfun belowThreshold(l : List<Int>, t : Int) = l.all { it < t }"}
{"task_id": "kotlin/19", "language": "kotlin", "completion": "/**\n * You are an expert Kotlin programmer, and here is your task.\n * Add two numbers x and y\n * >>> add(2, 3)\n * 5\n * >>> add(5, 7)\n * 12\n */\nfun add(x : Int, y : Int) : Int {\n    return x + y\n}"}
{"task_id": "kotlin/20", "language": "kotlin", "completion": "/**\n * You are an expert Kotlin programmer, and here is your task.\n * * Check if two words have the same characters.\n * >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n * True\n * >>> same_chars('abcd', 'dddddddabc')\n * True\n * >>> same_chars('dddddddabc', 'abcd')\n * True\n * >>> same_chars('eabcd', 'dddddddabc')\n * False\n * >>> same_chars('abcd', 'dddddddabce')\n * False\n * >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n * False\n *\n */\nfun sameChars(s0 : String, s1 : String) : Boolean {\n    return s0.lowercase().sorted() == s1.lowercase().sorted()\n}"}
{"task_id": "kotlin/21", "language": "kotlin", "completion": "/**\n * You are an expert Kotlin programmer, and here is your task.\n * Return n-th Fibonacci number.\n * >>> fib(10)\n * 55\n * >>> fib(1)\n * 1\n * >>> fib(8)\n * 21\n *\n */\nfun fib(n : Int) : Int {\n    if (n == 1 || n == 2) return 1\n\n    var a = 1\n    var b = 1\n\n    for (i in 3..n) {\n        val c = a + b\n\n        a = b\n        b = c\n    }\n    return b\n}"}
{"task_id": "kotlin/22", "language": "kotlin", "completion": "/**\n * You are an expert Kotlin programmer, and here is your task.\n * Return sorted unique common elements for two lists.\n * >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n * [1, 5, 653]\n * >>> common([5, 3, 2, 8], [3, 2])\n * [2, 3]\n\n *\n */\nfun common(l1 : List<Int>, l2 : List<Any>) : List<Any> {\n    val list = mutableListOf<Any>()\n\n    for (i in l1) {\n        if (l2.contains(i)) {\n            list.add(i)\n        }\n    }\n    return list\n}"}
{"task_id": "kotlin/23", "language": "kotlin", "completion": "/**\n * You are an expert Kotlin programmer, and here is your task.\n * Return the largest prime factor of n. Assume n > 1 and is not a prime.\n * >>> largest_prime_factor(13195)\n * 29\n * >>> largest_prime_factor(2048)\n * 2\n */\nfun largestPrimeFactor(n : Int) : Int {\n    var candidate = n\n\n    while (candidate % 2 == 0)\n        candidate /= 2\n\n    for (i in 3..Math.sqrt(candidate.toDouble()).toInt() step 2)\n        if (candidate % i == 0)\n            while (candidate % i == 0)\n                candidate /= i\n    return candidate\n}"}
{"task_id": "kotlin/24", "language": "kotlin", "completion": "/**\n * You are an expert Kotlin programmer, and here is your task.\n * sum_to_n is a function that sums numbers from 1 to n.\n * >>> sum_to_n(30)\n * 465\n * >>> sum_to_n(100)\n * 5050\n * >>> sum_to_n(5)\n * 15\n * >>> sum_to_n(10)\n * 55\n * >>> sum_to_n(1)\n * 1\n *\n */\nfun sumToN(n : Int) : Int {\n    var sum = 0\n\n    for (i in 1..n){\n        sum += i\n    }\n    return sum\n}"}
{"task_id": "kotlin/25", "language": "kotlin", "completion": "/**\n * You are an expert Kotlin programmer, and here is your task.\n * xs represent coefficients of a polynomial.\n * xs[0] + xs[1] * x + xs[2] * x^2 + ....\n *  Return derivative of this polynomial in the same form.\n * >>> derivative([3, 1, 2, 4, 5])\n * [1, 4, 12, 20]\n * >>> derivative([1, 2, 3])\n * [2, 6]\n *\n */\nfun derivative(xs : List<Int>) : List<Any> {\n    return xs.zipWithNext().mapIndexed{ index, (a, b) -> a * ((index+1).toLong()) }\n}"}
{"task_id": "kotlin/26", "language": "kotlin", "completion": "/**\n * You are an expert Kotlin programmer, and here is your task.\n * The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n * fibfib(0) == 0\n * fibfib(1) == 0\n * fibfib(2) == 1\n * fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n * Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n * >>> fibfib(1)\n * 0\n * >>> fibfib(5)\n * 4\n * >>> fibfib(8)\n * 24\n */\nfun fibfib(n : Int) : Int {\n    if (n < 3) return 0\n    var a = 0\n    var b = 1\n    var c = 1\n\n    repeat(n - 3) {\n        val tmp = c + b\n        c = b\n        b = a\n        a = tmp\n    }\n    return a + b + c\n}"}
{"task_id": "kotlin/27", "language": "kotlin", "completion": "/**\n * You are an expert Kotlin programmer, and here is your task.\n * Write a function vowels_count which takes a string representing\n * a word as input and returns the number of vowels in the string.\n * Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n * vowel, but only when it is at the end of the given word.\n\n * Example:\n * >>> vowels_count(\"abcde\")\n * 2\n * >>> vowels_count(\"ACEDY\")\n * 3\n *\n */\nfun vowelsCount(s : String) : Int {\n    var count = 0\n\n    for (c in s){\n        when (c.toLowerCase()) {\n            'a', 'e', 'i', 'o', 'u' -> count +=1\n        }\n    }\n\n    if (s[s.length - 1] == 'y'){\n        count += 1\n    }\n\n    return count\n}"}
{"task_id": "kotlin/28", "language": "kotlin", "completion": "/**\n * You are an expert Kotlin programmer, and here is your task.\n * * You are given a non-empty list of positive integers. Return the greatest integer that is greater than \n * zero, and has a frequency greater than or equal to the value of the integer itself. \n * The frequency of an integer is the number of times it appears in the list.\n * If no such a value exist, return -1.\n * Examples:\n *     search([4, 1, 2, 2, 3, 1]) == 2\n *     search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n *     search([5, 5, 4, 4, 4]) == -1\n *\n */\nfun search(lst : List<Int>) : Int {\n    val map = lst.groupBy { it }.mapValues { it.value.size }\n\n    return (1..lst.max()!!).reversed().firstOrNull { it <= lst.size / 2 && it in map && map[it] ?: 0 >= it} ?: -1\n}"}
{"task_id": "kotlin/29", "language": "kotlin", "completion": "/**\n * You are an expert Kotlin programmer, and here is your task.\n * * Given the lengths of the three sides of a triangle. Return the area of\n * the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n * Otherwise return -1\n * Three sides make a valid triangle when the sum of any two sides is greater \n * than the third side.\n * Example:\n * triangle_area(3, 4, 5) == 6.00\n * triangle_area(1, 2, 10) == -1\n */\nfun triangleArea(a : Int, b : Int, c : Int) : Any {\n    if (a + b <= c || a + c <= b || b + c <= a) {\n        return \"-1\"\n    }\n\n    var s = (a + b + c) / 2.0\n    var area = Math.sqrt(s * (s - a) * (s - b) * (s - c)).toFloat()\n\n    return String.format(\"%.2f\", area)\n}"}
{"task_id": "kotlin/30", "language": "kotlin", "completion": "/**\n * You are an expert Kotlin programmer, and here is your task.\n * * Write a function that returns True if the object q will fly, and False otherwise.\n * The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n\n * Example:\n * will_it_fly([1, 2], 5) \u279e False \n * # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n * will_it_fly([3, 2, 3], 1) :> False\n * # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n * will_it_fly([3, 2, 3], 9) :> True\n * # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n * will_it_fly([3], 5) :> True\n * # 3 is less than the maximum possible weight, and it's balanced.\n *\n */\nfun willItFly(q : List<Int>, w : Int) : Boolean {\n    if (q.isEmpty()) return false\n\n    var left = 0\n    var right = q.size -1\n\n    while(left < right){\n        val current = q[left] + q[right]\n        if (current > w){\n            return false\n        }\n        left++\n        right--\n    }\n    return true\n}"}
{"task_id": "kotlin/31", "language": "kotlin", "completion": "/**\n * You are an expert Kotlin programmer, and here is your task.\n * Write a function that returns true if the given number is the multiplication of 3 prime numbers\n * and false otherwise.\n * Knowing that (a) is less then 100. \n * Example:\n * is_multiply_prime(30) == True\n * 30 = 2 * 3 * 5\n *\n */\nfun isMultiplyPrime(a : Int) : Boolean {\n    var result = false\n\n    if (a <= 3 ) {\n        return false\n    }\n\n    val primes = mutableListOf<Int>()\n    for( i in  2 .. a/2 ) {\n        var x = true;\n\n        for( j in primes.indices){\n            if( i %primes[j] == 0) {\n                x =false\n            }\n        }\n\n        if(x) {\n            primes.add(i)\n        }\n    }\n\n    return when (a%2) {\n        1 ->  a == primes.reduce { acc, Int -> acc * Int} && primes.size == 3\n        0 ->  a == primes.reduce { acc, Int -> acc * Int} && primes.size == 4\n        else -> false\n    }\n}"}
{"task_id": "kotlin/32", "language": "kotlin", "completion": "/**\n * You are an expert Kotlin programmer, and here is your task.\n * You will be given a number in decimal form and your task is to convert it to\n * binary format. The function should return a string, with each character representing a binary\n * number. Each character in the string will be '0' or '1'.\n\n * There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n * The extra characters are there to help with the format.\n\n * Examples:\n * decimal_to_binary(15)   # returns \"db1111db\"\n * decimal_to_binary(32)   # returns \"db100000db\"\n *\n */\nfun decimalToBinary(decimal : Int) : String {\n    val binary = StringBuilder()\n\n    var value = decimal\n    while (value > 0) {\n        if (value and 1 == 0)\n            binary.append(\"0\")\n        else\n            binary.append(\"1\")\n\n        value = value shr 1\n    }\n\n    return \"db\" + binary.reverse().toString() + \"db\"\n}"}
{"task_id": "kotlin/33", "language": "kotlin", "completion": "/**\n * You are an expert Kotlin programmer, and here is your task.\n * You are given a string s.\n * Your task is to check if the string is happy or not.\n * A string is happy if its length is at least 3 and every 3 consecutive letters are distinct\n * For example:\n * is_happy(a) => False\n * is_happy(aa) => False\n * is_happy(abcd) => True\n * is_happy(aabb) => False\n * is_happy(adb) => True\n * is_happy(xyy) => False\n *\n */\nfun isHappy(s : String) : Boolean {\n    if (s.length < 3) return false\n\n    for ((index, _) in s.withIndex()) {\n        val nextIndex = index + 1\n        val thirdIndex = index + 2\n        if (nextIndex < s.length && s[index] == s[nextIndex]) return false\n        if (thirdIndex < s.length && s[index] == s[thirdIndex]) return false\n    }\n\n    return true\n}"}
{"task_id": "kotlin/34", "language": "kotlin", "completion": "/**\n * You are an expert Kotlin programmer, and here is your task.\n * It is the last week of the semester and the teacher has to give the grades\n * to students. The teacher has been making her own algorithm for grading.\n * The only problem is, she has lost the code she used for grading.\n * She has given you a list of GPAs for some students and you have to write \n * a function that can output a list of letter grades using the following table:\n *          GPA       |    Letter grade\n *           4.0                A+\n *         > 3.7                A \n *         > 3.3                A- \n *         > 3.0                B+\n *         > 2.7                B \n *         > 2.3                B-\n *         > 2.0                C+\n *         > 1.7                C\n *         > 1.3                C-\n *         > 1.0                D+ \n *         > 0.7                D \n *         > 0.0                D-\n *           0.0                E\n *\n\n * Example:\n * grade_equation([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n *\n */\nfun numericalLetterGrade(grades : List<Any>) : List<String> {\n    val letterGrades = mutableListOf<String>()\n\n    for (gpa in grades) {\n        when (gpa) {\n            is Double -> if (gpa >= 4.0) letterGrades.add(\"A+\") else if (gpa > 3.7) letterGrades.add(\"A\") else if (gpa > 3.3) letterGrades.add(\"A-\") else if (gpa > 3.0) letterGrades.add(\"B+\") else if (gpa > 2.7) letterGrades.add(\"B\") else if (gpa > 2.3) letterGrades.add(\"B-\") else if (gpa > 2.0) letterGrades.add(\"C+\") else if (gpa > 1.7) letterGrades.add(\"C\") else if (gpa > 1.3) letterGrades.add(\"C-\") else if (gpa > 1.0) letterGrades.add(\"D+\") else if (gpa > 0.7) letterGrades.add(\"D\") else if (gpa > 0.0) letterGrades.add(\"D-\")\n            is Int -> {\n                val tempGpa = gpa.toDouble() / 10\n                when {\n                    tempGpa >= 4.0 -> letterGrades.add(\"A+\")\n                    tempGpa > 3.7 -> letterGrades.add(\"A\")\n                    tempGpa > 3.3 -> letterGrades.add(\"A-\")\n                    tempGpa > 3.0 -> letterGrades.add(\"B+\")\n                    tempGpa > 2.7 -> letterGrades.add(\"B\")\n                    tempGpa > 2.3 -> letterGrades.add(\"B-\")\n                    tempGpa > 2.0 -> letterGrades.add(\"C+\")\n                    tempGpa > 1.7 -> letterGrades.add(\"C\")\n                    tempGpa > 1.3 -> letterGrades.add(\"C-\")\n                    tempGpa > 1.0 -> letterGrades.add(\"D+\")\n                    tempGpa > 0.7 -> letterGrades.add(\"D\")\n                    tempGpa > 0.0 -> letterGrades.add(\"D-\")\n                }\n            }\n        }\n    }\n\n    return letterGrades\n}"}
{"task_id": "kotlin/35", "language": "kotlin", "completion": "/**\n * You are an expert Kotlin programmer, and here is your task.\n * Write a function that takes a string and returns True if the string\n * length is a prime number or False otherwise\n * Examples\n * prime_length('Hello') == True\n * prime_length('abcdcba') == True\n * prime_length('kittens') == True\n * prime_length('orange') == False\n *\n */\nfun primeLength(string : String) : Boolean {\n    val length = string.length\n\n    if (length <= 1)\n        return false\n    else if (length == 2 || length == 3)\n        return true\n    else if (length % 2 == 0 || length % 3 == 0)\n        return false\n    var i = 5\n    while(i * i <= length){\n        if (length % i == 0 || length % (i + 2) == 0)\n            return false\n        i += 6\n    }\n\n    return true\n}"}
{"task_id": "kotlin/36", "language": "kotlin", "completion": "/**\n * You are an expert Kotlin programmer, and here is your task.\n * Given a positive integer N, return the total sum of its digits in binary.\n * \n * Example\n *     For N = 1000, the sum of digits will be 1 the output should be \"1\".\n *     For N = 150, the sum of digits will be 6 the output should be \"110\".\n *     For N = 147, the sum of digits will be 12 the output should be \"1100\".\n * \n * Variables:\n *     @N integer\n *          Constraints: 0 \u2264 N \u2264 10000.\n * Output:\n *      a string of binary number\n *\n */\nfun solve(n : Int) : String {\n    var binary = \"\"\n    if (n == 0) return \"0\"\n\n    while (n > 0){\n        val rem = n % 2;\n        binary = rem.toString() + binary\n\n        n /= 2\n    }\n\n    return binary\n}"}
{"task_id": "kotlin/37", "language": "kotlin", "completion": "/**\n * You are an expert Kotlin programmer, and here is your task.\n * * You are given a 2 dimensional data, as a nested lists,\n * which is similar to matrix, however, unlike matrices,\n * each row may contain a different number of columns.\n * Given lst, and integer x, find integers x in the list,\n * and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n * each tuple is a coordinate - (row, columns), starting with 0.\n * Sort coordinates initially by rows in ascending order.\n * Also, sort coordinates of the row by columns in descending order.\n * \n * Examples:\n * get_row([\n *   [1,2,3,4,5,6],\n *   [1,2,3,4,1,6],\n *   [1,2,3,4,5,1]\n * ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n * get_row([], 1) == []\n * get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n *\n */\nfun getRow(lst : List<Any>, x : Int) : List<Any> {\n    var coordinates = emptyList<Any>()\n    val row = mutableListOf<Int>()\n    for (i in lst.indices){\n        val currentRow = lst[i] as? ArrayList<*>\n        if(currentRow != null){\n            for (j in 0 until currentRow.size) {\n                if(x == currentRow[j]){\n                    coordinates += listOf(i, j)\n                }\n            }\n        }\n    }\n    return coordinates\n}"}
{"task_id": "kotlin/38", "language": "kotlin", "completion": "package challenges;\n\n/**\n * You are an expert Kotlin programmer, and here is your task.\n * * You are given a list of integers.\n * Write a function next_smallest() that returns the 2nd smallest element of the list.\n * Return  if there is no such element.\n * \n * next_smallest([1, 2, 3, 4, 5]) == 2\n * next_smallest([5, 1, 4, 3, 2]) == 2\n * next_smallest([]) == None\n * next_smallest([1, 1]) == None\n */\nfun nextSmallest(lst: List<Int>) : Int? {\n    // your code here\n    lst.sort()\n\n    if (lst.size < 2) return null\n\n    for (i in 1 until lst.size) {\n        if (lst[i] > lst[i - 1])\n            return lst[i]\n    }\n\n    return null\n}"}
{"task_id": "kotlin/39", "language": "kotlin", "completion": "/**\n * You are an expert Kotlin programmer, and here is your task.\n * * You'll be given a string of words, and your task is to count the number\n * of boredoms. A boredom is a sentence that starts with the word \"I\".\n * Sentences are delimited by '.', '?' or '!'.\n   \n * For example:\n * >>> is_bored(\"Hello world\")\n * 0\n * >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n * 1\n *\n */\nfun isBored(s : String) : Int {\n    var words = s.split(\" \")\n    var i = 0\n    while (i < words.size){\n        if(words[i].equals(\"I\", ignoreCase = true)){\n            return 1\n        }\n        i += 1\n\n    }\n    return 0\n}"}
{"task_id": "kotlin/40", "language": "kotlin", "completion": "package com.javarush.task.task12.task1219;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/* \nFind the largest prime number and return the sum of its digits\n*/\n\npublic class Solution {\n    public static void main(String[] args) {\n        List<Integer> lst = new ArrayList<>();\n\n        for (int i=0; i < args.length;i++)\n            lst.add(Integer.parseInt(args[i]));\n\n        System.out.println(getLargestPrimeSum(lst));\n    }\n\n    public static int getLargestPrimeSum(List<Integer> lst) {\n        int sum = 0, maxPrime = Integer.MIN_VALUE;\n        for (int i=0; i < lst.size();i++)\n        {\n            if (isPrime(lst.get(i)))\n                if (lst.get(i) > maxPrime)\n                    maxPrime = lst.get(i);\n        }\n\n        while (maxPrime != 0)\n        {\n            sum += maxPrime % 10;\n            maxPrime /= 10;\n        }\n\n        return sum;\n    }\n\n    public static boolean isPrime(int n) {\n        if (n == 2 || n == 3) return true;\n\n        if (n < 2 || n % 2 == 0) return false;\n\n        int rootN = (int)Math.sqrt(n)+1;\n        for(int i=3; i<rootN; i+=2)\n            if(n%i == 0)\n                return false;\n\n        return true;\n    }\n}"}
{"task_id": "kotlin/41", "language": "kotlin", "completion": "/**\n * You are an expert Kotlin programmer, and here is your task.\n * * Given a dictionary, return True if all keys are strings in lower \n * case or all keys are strings in upper case, else return False.\n * The function should return False is the given dictionary is empty.\n * Examples:\n * check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) should return True.\n * check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n * check_dict_case({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return False.\n * check_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n * check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n *\n */\nfun checkDictCase(dict : Map<Any?, Any?>) : Boolean {\n    val keys = dict.keys\n\n    if (keys.isEmpty())\n        return false\n\n    var firstIsUpper = Character.isUpperCase(keys.first().toString()[0])\n\n    for (key in keys){\n        if ((Character.isUpperCase(key.toString()[0]) && !firstIsUpper) ||\n                (!Character.isUpperCase(key.toString()[0]) && firstIsUpper))\n            return false\n    }\n\n    return true\n}"}
{"task_id": "kotlin/42", "language": "kotlin", "completion": "/**\n * You are an expert Kotlin programmer, and here is your task.\n * * Create a function that takes a value (string) representing a number\n * and returns the closest integer to it. If the number is equidistant\n * from two integers, round it away from zero.\n\n * Examples\n * >>> closest_integer(\"10\")\n * 10\n * >>> closest_integer(\"15.3\")\n * 15\n\n * Note:\n * Rounding away from zero means that if the given number is equidistant\n * from two integers, the one you should return is the one that is the\n * farthest from zero. For example closest_integer(\"14.5\") should\n * return 15 and closest_integer(\"-14.5\") should return -15.\n *\n */\nfun closestInteger(value : String) : Int {\n    var number = value.toDouble()\n    val intValue = number.toInt()\n\n    // Convert the given string to a double\n    if (number == intValue.toDouble()) return intValue\n\n    // Check if the decimal part is >= 0.5 and round accordingly\n    if (number - intValue >= 0.5) {\n        return intValue + 1\n    } else {\n        return intValue\n    }\n}"}
{"task_id": "kotlin/43", "language": "kotlin", "completion": "/**\n * You are an expert Kotlin programmer, and here is your task.\n * * Given a positive integer n, you have to make a pile of n levels of stones.\n * The first level has n stones.\n * The number of stones in the next level is:\n *     - the next odd number if n is odd.\n *     - the next even number if n is even.\n * Return the number of stones in each level in a list, where element at index\n * i represents the number of stones in the level (i+1).\n\n * Examples:\n * >>> make_a_pile(3)\n * [3, 5, 7]\n *\n */\nfun makeAPile(n : Int) : List<Int> {\n    val result = mutableListOf<Int>()\n    var stones = n\n\n    while (stones > 0){\n        result.add(stones)\n\n        if (stones % 2 == 0){\n            stones += stones + 1\n        } else {\n            stones += stones - 1\n        }\n\n    }\n\n    return result\n}"}
{"task_id": "kotlin/44", "language": "kotlin", "completion": "/**\n * You are an expert Kotlin programmer, and here is your task.\n * * You will be given a string of words separated by commas or spaces. Your task is\n * to split the string into words and return an array of the words.\n * \n * For example:\n * words_string(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n * words_string(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n *\n */\nfun wordsString(s : String) : List<Any> {\n    val pattern = \"\\\\s*,\\\\s*|\\\\s+\".toRegex()\n    return  s.split(pattern).map { it.trim() }\n}"}
{"task_id": "kotlin/45", "language": "kotlin", "completion": "/**\n * You are an expert Kotlin programmer, and here is your task.\n * This function takes two positive numbers x and y and returns the\n * biggest even integer number that is in the range [x, y] inclusive. If \n * there's no such number, then the function should return -1.\n\n * For example:\n * choose_num(12, 15) = 14\n * choose_num(13, 12) = -1\n *\n */\nfun chooseNum(x : Int, y : Int) : Int {\n    var max = x\n\n    for (i in x..y step 2){\n        if (i > max && i % 2 == 0)\n            max = i\n    }\n    return when (max){\n        x -> -1\n        else -> max\n    }\n}"}
{"task_id": "kotlin/46", "language": "kotlin", "completion": "/**\n * You are an expert Kotlin programmer, and here is your task.\n * You are given two positive integers n and m, and your task is to compute the\n * average of the integers from n through m (including n and m). \n * Round the answer to the nearest integer and convert that to binary.\n * If n is greater than m, return -1.\n * Example:\n * rounded_avg(1, 5) => \"0b11\"\n * rounded_avg(7, 5) => -1\n * rounded_avg(10, 20) => \"0b1111\"\n * rounded_avg(20, 33) => \"0b11010\"\n *\n */\nfun roundedAvg(n : Int, m : Int) : Any {\n    if (m > n){\n        return -1\n    }\n\n    val avg = ((n + m) / 2).toLong()\n    \n    return Integer.toBinaryString((avg))\n}"}
{"task_id": "kotlin/47", "language": "kotlin", "completion": "/**\n * You are an expert Kotlin programmer, and here is your task.\n * Implement the function f that takes n as a parameter,\n * and returns a list of size n, such that the value of the element at index i is the factorial of i if i is even\n * or the sum of numbers from 1 to i otherwise.\n * i starts from 1.\n * the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n * Example:\n * f(5) == [1, 2, 6, 24, 15]\n */\nfun f(n : Int) : List<Int> {\n    val result = mutableListOf<Int>()\n    for (i in 1..n){\n        if (i % 2 == 0){\n            var factorial = 1\n            for (j in 1..i){\n                factorial *= j\n            }\n            result.add(factorial)\n        }else{\n            var sum = 0\n            for (j in 1..i){\n                sum += j\n            }\n            result.add(sum)\n        }\n    }\n    return result\n}"}
{"task_id": "kotlin/48", "language": "kotlin", "completion": "/**\n * You are an expert Kotlin programmer, and here is your task.\n * * Given a positive integer n, return a tuple that has the number of even and odd\n * integer palindromes that fall within the range(1, n), inclusive.\n\n * Example 1:\n\n *     Input: 3\n *     Output: (1, 2)\n *     Explanation:\n *     Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n * Example 2:\n\n *     Input: 12\n *     Output: (4, 6)\n *     Explanation:\n *     Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n * Note:\n *     1. 1 <= n <= 10^3\n *     2. returned tuple has the number of even and odd integer palindromes respectively.\n *\n */\nfun evenOddPalindrome(n : Int) : List<Int> {\n    var result = mutableListOf<Int>(0, 0)\n\n    fun isEvenOrOdd(num: Int): Boolean{\n        return when(num){\n            in 1..9 -> num % 2 == 0\n            else -> true\n        }\n    }\n\n    (1..n).forEach {\n        val nStr = it.toString()\n\n        if(isEvenOrOdd(it) && isEvenOrOdd(Integer.parseInt(nStr.reversed()))) result[0]++\n        if(!isEvenOrOdd(it) && !isEvenOrOdd(Integer.parseInt(nStr.reversed()))) result[1]++\n    }\n\n    return result\n}"}
{"task_id": "kotlin/49", "language": "kotlin", "completion": "/**\n * You are an expert Kotlin programmer, and here is your task.\n * We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n * numbers in the array will be randomly ordered. Your task is to determine if\n * it is possible to get an array sorted in non-decreasing order by performing \n * the following operation on the given array:\n *     You are allowed to perform right shift operation any number of times.\n * \n * One right shift operation means shifting all elements of the array by one\n * position in the right direction. The last element of the array will be moved to\n * the starting position in the array i.e. 0th index. \n\n * If it is possible to obtain the sorted array by performing the above operation\n * then return True else return False.\n * If the given array is empty then return True.\n\n * Note: The given list is guaranteed to have unique elements.\n\n * For Example:\n * \n * move_one_ball([3, 4, 5, 1, 2])==>True\n * Explanation: By performin 2 right shift operations, non-decreasing order can\n *              be achieved for the given array.\n * move_one_ball([3, 5, 4, 1, 2])==>False\n * Explanation:It is not possible to get non-decreasing order for the given\n *             array by performing any number of right shift operations.\n *             \n */\nfun moveOneBall(arr : List<Any>) : Boolean {\n    val size = arr.size;\n    if (size == 0)\n        return true;\n    \n    var prevIndex = -1;\n    for (i in 0..size-2)\n    {\n        if (prevIndex == -1 || arr[i] <= arr[i+1])\n            continue;\n\n        if (arr[i] > arr[prevIndex])\n            return false;\n        \n        prevIndex = i;\n    }\n    \n    return true;\n}"}
{"task_id": "kotlin/50", "language": "kotlin", "completion": "/**\n * You are an expert Kotlin programmer, and here is your task.\n * In this problem, you will implement a function that takes two lists of numbers,\n * and determines whether it is possible to perform an exchange of elements\n * between them to make lst1 a list of only even numbers.\n * There is no limit on the number of exchanged elements between lst1 and lst2.\n * If it is possible to exchange elements between the lst1 and lst2 to make\n * all the elements of lst1 to be even, return \"YES\".\n * Otherwise, return \"NO\".\n * For example:\n * exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n * exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n * It is assumed that the input lists will be non-empty.\n */\nfun exchange(lst1 : List<Int>, lst2 : List<Int>) : String {\n    val a = lst1.toMutableList()\n    var isChange = false\n\n    for (i in 0..a.size - 1) {\n        if (a[i] % 2 != 0) {\n            isChange = true\n            break\n        }\n    }\n\n    if (!isChange) return \"YES\"\n\n    for (i in 0..lst2.size-1){\n        if(a[0]%2==0)break\n\n        var index = -1\n\n        for (j in 0..lst2.size-1){\n            val num = a[0]*lst2[j]\n\n            if(num%2==0){\n                a[0]=num/2\n\n                index = j\n                break\n            }\n        }\n        if (index!=-1) lst2.removeAt(index)\n    }\n\n    for (i in 0..a.size-1) {\n        if (a[i] % 2 != 0) {\n            isChange = false\n            break\n        } else isChange=true\n    }\n\n    return when (isChange){\n        true -> \"YES\"\n        false -> \"NO\"\n    }\n}"}
{"task_id": "kotlin/51", "language": "kotlin", "completion": "/**\n * You are an expert Kotlin programmer, and here is your task.\n * Task\n * We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\n * then check if the result string is palindrome.\n * A string is called palindrome if it reads the same backward as forward.\n * You should return a tuple containing the result string and True/False for the check.\n * Example\n * For s = \"abcde\", c = \"ae\", the result should be ('bcd',False)\n * For s = \"abcdef\", c = \"b\"  the result should be ('acdef',False)\n * For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',True)\n *\n */\nfun reverseDelete(s : String, c : String) : List<Any> {\n    val cSet: Set<Char> = c.toSet()\n    var newString = \"\"\n\n    for (char in s)\n        if (!cSet.contains(char))\n            newString += char\n\n    val isPalindrome = (newString == newString.reversed())\n\n    return listOf(newString, isPalindrome)\n}"}
{"task_id": "kotlin/52", "language": "kotlin", "completion": "/**\n * You are an expert Kotlin programmer, and here is your task.\n * * You are given a rectangular grid of wells. Each row represents a single well,\n * and each 1 in a row represents a single unit of water.\n * Each well has a corresponding bucket that can be used to extract water from it, \n * and all buckets have the same capacity.\n * Your task is to use the buckets to empty the wells.\n * Output the number of times you need to lower the buckets.\n\n * Example 1:\n *     Input: \n *         grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n *         bucket_capacity : 1\n *     Output: 6\n\n * Example 2:\n *     Input: \n *         grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n *         bucket_capacity : 2\n *     Output: 5\n * \n * Example 3:\n *     Input: \n *         grid : [[0,0,0], [0,0,0]]\n *         bucket_capacity : 5\n *     Output: 0\n\n * Constraints:\n *     * all wells have the same length\n *     * 1 <= grid.length <= 10^2\n *     * 1 <= grid[:,1].length <= 10^2\n *     * grid[i][j] -> 0 | 1\n *     * 1 <= capacity <= 10\n */\nfun maxFill(grid : List<List<Int>>, capacity : Int) : Int {\n    \n    var row = -1;\n    var col = -1;\n\n    for (i in grid.indices){\n        if (row < 0 || row == i){\n            for (j in grid[i].indices){\n                if (col < 0 || j == col && row != i){\n                    if (grid[i][j] == 1){\n                        row = i;\n                        col = j;\n                    }\n                }\n            }\n        }\n    }\n\n    var count = 0;\n\n    while(row >= 0 && col >= 0){\n\n        val length = grid[row].size - col;\n        val toDrain = Math.min(capacity, length);\n\n        for (i in row downTo row-toDrain+1)\n            grid[i][col] -= toDrain;\n        \n        if (grid[row][col] == 0){\n            do {\n                col--;\n            } while (col >= 0 && grid[row][col] == 1);\n        }\n\n        count++;\n    }\n\n    return count;\n}"}
{"task_id": "kotlin/53", "language": "kotlin", "completion": "import java.util.*\n\n/**\n * You are an expert Kotlin programmer, and here is your task.\n * Given a string s and a natural number n, you have been tasked to implement \n * a function that returns a list of all words from string s that contain exactly \n * n consonants, in order these words appear in the string s.\n * If the string s is empty then the function should return an empty list.\n * Note: you may assume the input string contains only letters and spaces.\n * Examples:\n * select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n * select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n * select_words(\"simple white space\", 2) ==> []\n * select_words(\"Hello world\", 4) ==> [\"world\"]\n * select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\n */\n\n fun isVowel(c: Char): Boolean {\n    val vowels = \"aeiou\"\n    return vowels.contains(c, true)\n  }\n  \n  fun consonantsInWord(s : String) : Int {\n     var count = 0\n      for (i in s.indices){\n          if (!isVowel(s[i])){\n              count++\n          }\n          \n      }\n      \n  return count\n}\n\n\n\nfun selectWords(s: String, n: Int): List<String> {\n    val resultList : MutableList<String> = mutableListOf()\n\n    for (word in s.split(\" \")){\n        if (consonantsInWord(word) == n){\n            resultList.add(word)\n        }\n        \n    }\n    return resultList\n}"}
{"task_id": "kotlin/54", "language": "kotlin", "completion": "package com.dhtm.gfg. challenges\n\nimport org.junit.Test\n\nclass MaximumKNumbersInArrayTest{\n\n    @Test\n    fun `test solution 1`() {\n        println(maximum(listOf(-3, -4, 5), 3))\n        println(maximum(listOf(4, -4, 4), 2))\n        println(maximum(listOf(-3, 2, 1, 2, -1, -2, 1), 1))\n    }\n\n    @Test\n    fun `test solution 2`() {\n        println(maximumV2(listOf(-3, -4, 5), 3))\n        println(maximumV2(listOf(4, -4, 4), 2))\n        println(maximumV2(listOf(-3, 2, 1, 2, -1, -2, 1), 1))\n    }\n\n    fun maximum(arr : List<Int>, k: Int) : List<Any> {\n\n        var min = arr.sorted().takeLast(k).first()\n        var max = arr.sorted().takeLast(k).last()\n\n        return arr.filter { it >= min && it <= max }.sorted().takeLast(k)\n    }\n\n    fun maximumV2(arr : List<Int>, k: Int) : List<Any> {\n\n        val sortedArr = arr.sorted()\n        var min = sortedArr.last() - sortedArr.windowed(k, 1, false).map { it.maxOrNull()?.toInt() ?: 0 }.minOrNull()!!\n        var max = sortedArr.first() + sortedArr.windowed(k, 1, false).map { it.minOrNull()?.toInt() ?: 0 }.maxOrNull()!!\n\n        return arr.filter { it >= min && it <= max }.sorted().takeLast(k)\n    }\n}"}
{"task_id": "kotlin/55", "language": "kotlin", "completion": "/**\n * You are an expert Kotlin programmer, and here is your task.\n * * Given a non-empty array of integers arr and an integer k, return\n * the sum of the elements with at most two digits from the first k elements of arr.\n\n * Example:\n\n *     Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n *     Output: 24 # sum of 21 + 3\n\n * Constraints:\n *     1. 1 <= len(arr) <= 100\n *     2. 1 <= k <= len(arr)\n *\n */\nfun addElements(arr : List<Int>, k : Int) : Int {\n    var sum = 0\n\n    for (i in 0..k-1){\n        if(arr[i] >= 10 && arr[i] < 100){\n            sum += arr[i]\n        }\n    }\n    \n    return sum\n}"}
{"task_id": "kotlin/56", "language": "kotlin", "completion": "/**\n * You are an expert Kotlin programmer, and here is your task.\n * You are given two intervals,\n * where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n * The given intervals are closed which means that the interval (start, end)\n * includes both start and end.\n * For each given interval, it is assumed that its start is less or equal its end.\n * Your task is to determine whether the length of intersection of these two \n * intervals is a prime number.\n * Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n * which its length is 1, which not a prime number.\n * If the length of the intersection is a prime number, return \"YES\",\n * otherwise, return \"NO\".\n * If the two intervals don't intersect, return \"NO\".\n\n\n * [input/output] samples:\n * intersection((1, 2), (2, 3)) ==> \"NO\"\n * intersection((-1, 1), (0, 4)) ==> \"NO\"\n * intersection((-3, -1), (-5, 5)) ==> \"YES\"\n *\n */\nfun isPrime(n: Int): Boolean {\n    if (n <= 1) return false\n    var i = 2\n    while (i*i <= n) {\n        if (n % i == 0) return false\n        i += 1\n    }\n    return true\n}\n\nfun intersection(interval1 : List<Int>, interval2 : List<Int>) : String {"}
{"task_id": "kotlin/57", "language": "kotlin", "completion": "/**\n * You are an expert Kotlin programmer, and here is your task.\n * Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n * the last couple centuries. However, what people don't know is Tribonacci sequence.\n * Tribonacci sequence is defined by the recurrence:\n * tri(1) = 3\n * tri(n) = 1 + n / 2, if n is even.\n * tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n * For example:\n * tri(2) = 1 + (2 / 2) = 2\n * tri(4) = 3\n * tri(3) = tri(2) + tri(1) + tri(4)\n *        = 2 + 3 + 3 = 8 \n * You are given a non-negative integer number n, you have to a return a list of the \n * first n + 1 numbers of the Tribonacci sequence.\n * Examples:\n * tri(3) = [1, 3, 2, 8]\n *\n */\nfun tri(n : Int) : List<Any> {\n    var result = mutableListOf<Any>()\n    if (n == 0 || n == 1)\n        return listOf(1)\n    if (n == 2)\n        return listOf(1, 3)\n\n    result.add(1)\n    result.add(3)\n    for (i in 2 until n+1) {\n        var temp = 1 + i/2\n        when {\n            i % 2 != 0 -> {\n                val sum = result[i-1] as Int + result[i-2] as Int + result[i] as Int\n                temp = sum\n            }\n        }\n\n        result.add(temp)\n    }\n\n    return result\n}"}
{"task_id": "kotlin/58", "language": "kotlin", "completion": "/**\n * You are an expert Kotlin programmer, and here is your task.\n * Given a positive integer n, return the product of the odd digits.\n * Return 0 if all digits are even.\n * For example:\n * digits(1)  == 1\n * digits(4)  == 0\n * digits(235) == 15\n *\n */\nfun digits(n : Int) : Int {\n    var product = 1\n\n    for (d in n.toString().map(Char::getNumericValue)) {\n        if (d % 2 != 0) {\n            product *= d\n        }\n    }\n\n    return when (product == 1) {\n        true -> 0\n        false -> product\n    }\n}"}
{"task_id": "kotlin/59", "language": "kotlin", "completion": "/**\n * You are an expert Kotlin programmer, and here is your task.\n * * Create a function that takes a string as input which contains only square brackets.\n * The function should return True if and only if there is a valid subsequence of brackets \n * where at least one bracket in the subsequence is nested.\n\n * is_nested('[[]]')\ufffd\ufffd True\n * is_nested('[]]]]]]][[[[[]')\ufffd\ufffd False\n * is_nested('[][]')\ufffd\ufffd False\n * is_nested('[]')\ufffd\ufffd False\n * is_nested('[[][]]')\ufffd\ufffd True\n * is_nested('[[]][[')\ufffd\ufffd True\n */\nfun isNested(string: String): Boolean {\n    var nested = false\n    var balance = 0\n\n    for (char in string) {\n        when (char) {\n            '[' -> balance++\n            ']' -> balance--\n\n            else -> throw IllegalArgumentException(\"Invalid character\")\n        }\n\n        if (balance < -1) {\n            return false\n        }\n\n        if (balance == -1 && nested) {\n            return true\n        }\n\n        if (balance == 0 && !nested) {\n            nested = true\n        }\n    }\n\n    return balance == 0\n}"}
{"task_id": "kotlin/60", "language": "kotlin", "completion": "/**\n * You are an expert Kotlin programmer, and here is your task.\n * You are given a list of numbers.\n * You need to return the sum of squared numbers in the given list,\n * round each element in the list to the upper int(Ceiling) first.\n * Examples:\n * For lst = [1,2,3] the output should be 14\n * For lst = [1,4,9] the output should be 98\n * For lst = [1,3,5,7] the output should be 84\n * For lst = [1.4,4.2,0] the output should be 29\n * For lst = [-2.4,1,1] the output should be 6\n * \n\n *\n */\nfun sumSquares(lst : List<Any>) : Int {\n    var sum = 0\n\n    for (i in lst) {\n        if (i is Int || i is Long)\n            sum += Math.pow((Math.ceil(i.toDouble())),2.0).toInt()\n    }\n\n    return sum\n}"}
{"task_id": "kotlin/61", "language": "kotlin", "completion": "/**\n * You are an expert Kotlin programmer, and here is your task.\n * * Create a function that returns True if the last character\n * of a given string is an alphabetical character and is not\n * a part of a word, and False otherwise.\n * Note: \"word\" is a group of characters separated by space.\n\n * Examples:\n * check_if_last_char_is_a_letter(\"apple pie\") \u279e False\n * check_if_last_char_is_a_letter(\"apple pi e\") Sar\ufffd True\n * check_if_last_char_is_a_letter(\"apple pi e \") Sar\ufffd False\n * check_if_last_char_is_a_letter(\"\") Sar\ufffd False \n *\n */\nfun checkIfLastCharIsALetter(txt : String) : Boolean {\n    val words = txt.split(\" \")\n    for (i in words.indices.reversed()) {\n        val word = words[i]\n        if (!word.matches(\"[a-zA-Z]*\".toRegex())) continue\n        return Character.isLetter(word[word.length - 1])\n    }\n    return false\n}"}
{"task_id": "kotlin/62", "language": "kotlin", "completion": "/**\n * You are an expert Kotlin programmer, and here is your task.\n * Create a function which returns the largest index of an element which\n * is not greater than or equal to the element immediately preceding it. If\n * no such element exists then return -1. The given array will not contain\n * duplicate values.\n\n * Examples:\n * can_arrange([1,2,4,3,5]) = 3\n * can_arrange([1,2,3]) = -1\n *\n */\nfun canArrange(arr : List<Any>) : Int {\n\n    var next: Any?\n    for (i in arr.indices) {\n        if (i == arr.size-1){\n            return i;\n        }\n        else{\n            if (arr[i] <= arr[i+1]){\n                continue\n            }else{\n                return i\n            }\n        }\n    }\n    return -1\n}"}
{"task_id": "kotlin/63", "language": "kotlin", "completion": "/**\n * You are an expert Kotlin programmer, and here is your task.\n * * Create a function that returns a tuple (a, b), where 'a' is\n * the largest of negative integers, and 'b' is the smallest\n * of positive integers in a list.\n * If there is no negative or positive integers, return them as None.\n\n * Examples:\n * largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n * largest_smallest_integers([]) == (None, None)\n * largest_smallest_integers([0]) == (None, None)\n *\n */\nfun largestSmallestIntegers(lst : List<Any>) : List<Int?> {\n    var negInf: Int? = null\n    var posInf: Int? = null\n\n    lst.forEach {\n        when(it){\n            is Int -> {\n                if(it > 0) {\n                    if (posInf == null || it < posInf!!)\n                        posInf = it\n                } else if (it < 0){\n                    if (negInf == null || it > negInf!!)\n                        negInf = it\n                }\n            }\n        }\n    }\n\n    return listOf(negInf, posInf)\n}"}
{"task_id": "kotlin/64", "language": "kotlin", "completion": "/**\n * You are an expert Kotlin programmer, and here is your task.\n * The Brazilian factorial is defined as:\n * brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n * where n > 0\n\n * For example:\n * >>> special_factorial(4)\n * 288\n\n * The function will receive an integer as input and should return the special\n * factorial of this integer.\n *\n */\nfun specialFactorial(n : Int) : Int {\n    if (n <= 1) {\n        return 1\n    }\n\n    var result = 1\n    for (i in n downTo 2) {\n        result *= i;\n    }\n    return result\n}"}
{"task_id": "kotlin/65", "language": "kotlin", "completion": "/**\n * You are an expert Kotlin programmer, and here is your task.\n * * You are given a string representing a sentence,\n * the sentence contains some words separated by a space,\n * and you have to return a string that contains the words from the original sentence,\n * whose lengths are prime numbers,\n * the order of the words in the new string should be the same as the original one.\n\n * Example 1:\n *     Input: sentence = \"This is a test\"\n *     Output: \"is\"\n\n * Example 2:\n *     Input: sentence = \"lets go for swimming\"\n *     Output: \"go for\"\n\n * Constraints:\n *     * 1 <= len(sentence) <= 100\n *     * sentence contains only letters\n *\n */\nfun wordsInSentence(sentence : String) : String {\n    val primeNumbers = listOf(2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37)\n    return sentence.split(\" \")\n            .filter { it.length in primeNumbers }\n            .joinToString(\" \")\n}"}
{"task_id": "kotlin/66", "language": "kotlin", "completion": "/**\n * You are an expert Kotlin programmer, and here is your task.\n * Your task is to implement a function that will simplify the expression\n * x * n. The function returns True if x * n evaluates to a whole number and False\n * otherwise. Both x and n, are string representation of a fraction, and have the following format,\n * <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n\n * You can assume that x, and n are valid fractions, and do not have zero as denominator.\n\n * simplify(\"1/5\", \"5/1\") = True\n * simplify(\"1/6\", \"2/1\") = False\n * simplify(\"7/10\", \"10/2\") = False\n *\n */\nfun simplify(x : String, n : String) : Boolean {\n    val (numerX, denomX) = x.split(\"/\").map { it.toInt() }\n    val (numerN, denomN) = n.split(\"/\").map { it.toInt() }\n    return numerX * numerN % denomX == 0\n}"}
{"task_id": "kotlin/67", "language": "kotlin", "completion": "/**\n * You are an expert Kotlin programmer, and here is your task.\n * * Write a function which sorts the given list of integers\n * in ascending order according to the sum of their digits.\n * Note: if there are several items with similar sum of their digits,\n * order them based on their index in original list.\n\n * For example:\n * >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n * >>> order_by_points([]) == []\n *\n */\nfun orderByPoints(nums : List<Any>) : List<Any> {\n    fun sumOfDigits(num: Int):Int{\n        var totalSum = 0;\n\n        if (num < 0){\n            num *= -1\n            //println(\"$num *-1\")\n        }\n        while(num > 0){\n            val currentDigit = num % 10\n            totalSum += currentDigit\n\n            num /= 10\n        }\n        return totalSum\n    }\n\n    val sortedBySum = nums.sortedWith { a, b -> (sumOfDigits(a as Int) - sumOfDigits(b as Int))}\n    println(\"$sortedBySum\")\n\n    return sortedBySum\n}"}
{"task_id": "kotlin/68", "language": "kotlin", "completion": "/**\n * You are an expert Kotlin programmer, and here is your task.\n * Write a function that takes an array of numbers as input and returns \n * the number of elements in the array that are greater than 10 and both \n * first and last digits of a number are odd (1, 3, 5, 7, 9).\n * For example:\n * specialFilter([15, -73, 14, -15]) => 1 \n * specialFilter([33, -2, -3, 45, 21, 109]) => 2\n *\n */\nfun specialfilter(nums : List<Any>) : Int {\n    var count = 0\n\n    for (num in nums) {\n        if (num is Number && num > 10) {\n            val stringNum = num.toString()\n\n            if (stringNum[0] == '1' ||\n                stringNum[0] == '3' ||\n                stringNum[0] == '5' ||\n                stringNum[0] == '7' ||\n                stringNum[0] == '9' &&\n                stringNum[stringNum.length-1] == '1' ||\n                stringNum[stringNum.length-1] == '3' ||\n                stringNum[stringNum.length-1] == '5' ||\n                stringNum[stringNum.length-1] == '7' ||\n                stringNum[stringNum.length-1] == '9') {\n                    count++\n            }\n        }\n    }\n\n    return count\n}"}
{"task_id": "kotlin/69", "language": "kotlin", "completion": "/**\n * You are an expert Kotlin programmer, and here is your task.\n * * You are given a positive integer n. You have to create an integer array a of length n.\n *     For each i (1 \u2264 i \u2264 n), the value of a[i] = i * i - i + 1.\n *     Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n * and a[i] + a[j] + a[k] is a multiple of 3.\n\n * Example :\n *     Input: n = 5\n *     Output: 1\n *     Explanation: \n *     a = [1, 3, 7, 13, 21]\n *     The only valid triple is (1, 7, 13).\n */\nfun getMaxTriples(n : Int) : Int {\n    val a = List(n){i -> i*i - i + 1}\n    var result = 0\n\n    for ((i, firstValue) in a.withIndex()) {\n        if (firstValue % 3 != 0) continue\n\n        val secondValue =\n            when (firstValue) {\n                2 % 3 -> return 0\n                else -> firstValue - 2\n            }\n\n        val thirdValue =\n            when(secondValue) {\n                1 % 3 -> n * 3\n                else -> (n * 3) - secondValue\n            }\n\n        if (a.contains(secondValue) && a.contains(thirdValue)) result += 1\n    }\n\n    return result\n}"}
{"task_id": "kotlin/70", "language": "kotlin", "completion": "/**\n * You are an expert Kotlin programmer, and here is your task.\n * * There are eight planets in our solar system: the closerst to the Sun \n * is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n * Uranus, Neptune.\n * Write a function that takes two planet names as strings planet1 and planet2. \n * The function should return a tuple containing all planets whose orbits are \n * located between the orbit of planet1 and the orbit of planet2, sorted by \n * the proximity to the sun. \n * The function should return an empty tuple if planet1 or planet2\n * are not correct planet names. \n * Examples\n * bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n * bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n * bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n */\n\nfun bf(planet1: String, planet2: String): List<Any> {\n    var orbits = listOf(\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n    val index1 = orbits.indexOf(planet1)\n    val index2 = orbits.indexOf(planet2)\n\n    if (index1 < 0 || index2 < 0)\n        return listOf()\n\n    val indexMin = minOf(index1, index2)\n    val indexMax = maxOf(index1, index2)\n\n    return orbits.subList(indexMin + 1, indexMax)\n}"}
{"task_id": "kotlin/71", "language": "kotlin", "completion": "/**\n * You are an expert Kotlin programmer, and here is your task.\n * A simple program which should return the value of x if n is \n * a prime number and should return the value of y otherwise.\n\n * Examples:\n * for x_or_y(7, 34, 12) == 34\n * for x_or_y(15, 8, 5) == 5\n * \n *\n */\nfun xOrY(n : Int, x : Int, y : Int) : Int {\n    // Check if n is a prime number. If it is, return the value of x, \n    // otherwise, return the value of y."}
{"task_id": "kotlin/72", "language": "kotlin", "completion": "/**\n * You are an expert Kotlin programmer, and here is your task.\n * * Given a list of numbers, return the sum of squares of the numbers\n * in the list that are odd. Ignore numbers that are negative or not integers.\n * \n * double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n * double_the_difference([-1, -2, 0]) == 0\n * double_the_difference([9, -2]) == 81\n * double_the_difference([0]) == 0  \n * If the input list is empty, return 0.\n *\n */\nfun doubleTheDifference(lst : List<Any>) : Int {\n    var sum = 0\n    \n    for (element in lst) {\n        if (element !is Int || element < 0) continue\n\n        if (element % 2 != 0)\n            sum += element * element\n    }\n    return sum\n}"}
{"task_id": "kotlin/73", "language": "kotlin", "completion": "/**\n * You are an expert Kotlin programmer, and here is your task.\n * You will be given the name of a class (a string) and a list of extensions.\n * The extensions are to be used to load additional classes to the class. The\n * strength of the extension is as follows: Let CAP be the number of the uppercase\n * letters in the extension's name, and let SM be the number of lowercase letters \n * in the extension's name, the strength is given by the fraction CAP - SM. \n * You should find the strongest extension and return a string in this \n * format: ClassName.StrongestExtensionName.\n * If there are two or more extensions with the same strength, you should\n * choose the one that comes first in the list.\n * For example, if you are given \"Slices\" as the class and a list of the\n * extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n * return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n * (its strength is -1).\n * Example:\n * for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n *\n */\nfun strongestExtension(className : String, extensions : List<String>) : String {\n    var strength = 0\n    val classNameList = className.toList()\n    val firstExtension = extensions[0].toList()\n    for (i in classNameList){\n        if (Character.isUpperCase(i))\n            strength ++\n    }\n    return when{\n        strength >= 0 -> \"${className}.${firstExtension}\"\n        else -> {\n            var maxExtension = \"\"\n            var strongestStrength = -10\n\n            extensions.forEach {\n                var currentExtensionStrength = 0\n                val extensionList = it.toList()\n\n                for (i in classNameList){\n                    if (Character.isUpperCase(i))\n                        currentExtensionStrength ++\n                }\n                for (j in extensionList){\n                    if (!Character.isUpperCase(j))\n                        currentExtensionStrength --\n                }\n\n                if (currentExtensionStrength >= strongestStrength){\n                    maxExtension = it\n                    strongestStrength = currentExtensionStrength\n                }\n            }\n            \"$className.$maxExtension\"\n        }\n    }\n}"}
{"task_id": "kotlin/74", "language": "kotlin", "completion": "/**\n * You are an expert Kotlin programmer, and here is your task.\n * You are given 2 words. You need to return True if the second word or any of its rotations is a substring in the first word\n * cycpattern_check(\"abcd\",\"abd\") => False\n * cycpattern_check(\"hello\",\"ell\") => True\n * cycpattern_check(\"whassup\",\"psus\") => False\n * cycpattern_check(\"abab\",\"baa\") => True\n * cycpattern_check(\"efef\",\"eeff\") => False\n * cycpattern_check(\"himenss\",\"simen\") => True\n\n *\n */\nfun cycpatternCheck(a : String, b : String) : Boolean {\n    var found = false\n\n    if (b.length > a.length) {\n        return false\n    } else if (b == a.substring(0, b.length)) {\n        return true\n    } else if (b == a.substring(a.length - b.length, a.length)) {\n        return true\n    }\n\n    for (i in 1 until a.length) {\n        val shift = i\n\n        if (shift + b.length > a.length )\n            continue;\n\n        var valid = true\n\n        for (j in 0..b.length -1) {\n            if (a[j + shift] != b[j]) {\n                valid = false\n            }\n        }\n\n        if (valid) return true\n    }\n\n    return found\n}"}
{"task_id": "kotlin/75", "language": "kotlin", "completion": "/**\n * You are an expert Kotlin programmer, and here is your task.\n * * Given a positive integer, obtain its roman numeral equivalent as a string,\n * and return it in lowercase.\n * Restrictions: 1 <= num <= 1000\n\n * Examples:\n * >>> int_to_mini_roman(19) == 'xix'\n * >>> int_to_mini_roman(152) == 'clii'\n * >>> int_to_mini_roman(426) == 'cdxxvi'\n *\n */\nfun intToMiniRoman(number : Int) : String {\n    val numberToString = number.toString()\n    return \"\"\n}"}
{"task_id": "kotlin/76", "language": "kotlin", "completion": "/**\n * You are an expert Kotlin programmer, and here is your task.\n * * Given the lengths of the three sides of a triangle. Return True if the three\n * sides form a right-angled triangle, False otherwise.\n * A right-angled triangle is a triangle in which one angle is right angle or \n * 90 degree.\n * Example:\n * right_angle_triangle(3, 4, 5) == True\n * right_angle_triangle(1, 2, 3) == False\n *\n */\nfun rightAngleTriangle(a : Int, b : Int, c : Int) : Boolean {\n    if (a + b > c && a + c > b && b + c > a ) return true\n    else return false\n}"}
{"task_id": "kotlin/77", "language": "kotlin", "completion": "/**\n * You are an expert Kotlin programmer, and here is your task.\n * You are given a string s.\n * if s[i] is a letter, reverse its case from lower to upper or vise versa, \n * otherwise keep it as it is.\n * If the string contains no letters, reverse the string.\n * The function should return the resulted string.\n * Examples\n * solve(\"1234\") = \"4321\"\n * solve(\"ab\") = \"AB\"\n * solve(\"#a@C\") = \"#A@c\"\n *\n */\nfun solve(s : String) : String {\n    var is lettersFound = false\n\n    val resultString = StringBuilder()\n    for (i in s.indices){\n        if (s[i].isLetter()) {\n            val ch = s[i]\n            resultString.append(if (ch.isLowerCase()) ch.toUpperCase() else ch.toLowerCase())\n            isLettersFound = true\n        }\n        else{\n            resultString.append(s[i])\n        }\n    }\n\n    return if (!isLettersFound) resultString.reverse().toString() else resultString.toString()\n}"}
{"task_id": "kotlin/78", "language": "kotlin", "completion": "package org. practice.hash;\n\nimport java.security.MessageDigest;\n\npublic class MD5Generator {\n\n    private static final char[] hexArray = \"0123456789ABCDEF\".toCharArray();\n    public static void main(String[] args) throws Exception {\n        String s = \"Hello world\";\n        byte[] hash = MessageDigest.getInstance(\"MD5\").digest(s.getBytes());\n\n        System.out.println(bytesToHex(hash));\n\n    }\n\n    private static String bytesToHex(byte[] bytes) {\n        char[] hexChars = new char[bytes.length * 2];\n        for ( int j = 0; j < bytes.length; j++ ) {\n            int v = bytes[j] & 0xFF;\n            hexChars[j * 2] = hexArray[v >>> 4];\n            hexChars[j * 2 + 1] = hexArray[v & 0x0F];\n        }\n        return new String(hexChars);\n    }\n}"}
{"task_id": "kotlin/79", "language": "kotlin", "completion": "/**\n * You are an expert Kotlin programmer, and here is your task.\n * * Given two positive integers a and b, return the even digits between a\n * and b, in ascending order.\n\n * For example:\n * generate_integers(2, 8) => [2, 4, 6, 8]\n * generate_integers(8, 2) => [2, 4, 6, 8]\n * generate_integers(10, 14) => []\n *\n */\nfun generateIntegers(a : Int, b : Int) : List<Int> {\n    val list = mutableListOf<Int>()\n    if (a < b){\n        for (x in a..b){\n            if (x % 2 == 0){\n                list.add(x)\n            }\n        }\n        return list\n    } else {\n        for (x in b..a){\n            if (x % 2 == 0){\n                list.add(x)\n            }\n        }\n        return list\n    }\n}"}
