{"task_id": "kotlin/0", "language": "kotlin", "completion": "/**\n * Du bist ein erfahrener Kotlin-Programmierer und hier ist deine Aufgabe.\n * Sie erhalten eine Liste von Einzahlungs- und Abhebungsvorg\u00e4ngen auf einem Bankkonto, das mit einem Nullsaldo beginnt. Ihre Aufgabe besteht darin, festzustellen, ob zu irgendeinem Zeitpunkt das Guthaben des Kontos unter Null f\u00e4llt, und an diesem Punkt sollte die Funktion True zur\u00fcckgeben. Andernfalls sollte sie False zur\u00fcckgeben.\n * >>> below_zero([1, 2, 3])\n * False\n * >>> below_zero([1, 2, -4, 5])\n * True\n */\nfun belowZero(operations : List<Any>) : Boolean {\n    var zero = false\n    for (operation in operations) {\n        if (zero) {\n            return true\n        } else if (operation is Int && operation < 0){\n            zero = true\n        }\n    }\n    return false\n}"}
{"task_id": "kotlin/1", "language": "kotlin", "completion": "/**\n * Du bist ein erfahrener Kotlin-Programmierer und hier ist deine Aufgabe.\n * F\u00fcr eine gegebene Liste von ganzen Zahlen soll ein Tupel zur\u00fcckgegeben werden, das aus der Summe und dem Produkt aller Zahlen in der Liste besteht.\n * Eine leere Summe soll gleich 0 und ein leeres Produkt gleich 1 sein.\n * >>> sum_product([])\n * (0, 1)\n * >>> sum_product([1, 2, 3, 4])\n * (10, 24)\n *\n */\nfun sumProduct(numbers : List<Any>) : List<Int> {\n    return listOf(\n        numbers.filterIsInstance<Number>().sum(),\n        numbers.filterIsInstance<Number>().fold(1) { acc, i -> acc * i.toInt() }\n    )\n}"}
{"task_id": "kotlin/2", "language": "kotlin", "completion": "/**\n * Du bist ein erfahrener Kotlin-Programmierer und hier ist deine Aufgabe.\n * Die Eingabe sind zwei Zeichenketten a und b, die nur aus 1en und 0en bestehen.\n * F\u00fchren Sie eine bin\u00e4re XOR-Operation auf diesen Eingaben aus und geben Sie das Ergebnis ebenfalls als Zeichenkette zur\u00fcck.\n * >>> string_xor('010', '110')\n * '100'\n *\n */\nfun stringXor(a : String, b : String) : String {\n    val aArray = a.split(\"\")\n    val bArray = b.split(\"\")\n    var result = \"\"\n\n    for (i in 0 until aArray.size) {\n        if (aArray[i] == bArray[i])\n            result += \"0\"\n        else\n            result += \"1\"\n    }\n\n    return result\n}"}
{"task_id": "kotlin/3", "language": "kotlin", "completion": "/**\n *Du bist ein erfahrener Kotlin-Programmierer und hier ist deine Aufgabe.\n * Aus einer Liste von Zeichenketten soll die l\u00e4ngste zur\u00fcckgegeben werden. Im Falle von mehreren Zeichenketten mit gleicher L\u00e4nge soll die erste zur\u00fcckgegeben werden. Falls die Eingabeliste leer ist, soll null zur\u00fcckgegeben werden.\n * >>> longest([])\n\n * >>> longest(['a', 'b', 'c'])\n * 'a'\n * >>> longest(['a', 'bb', 'ccc'])\n * 'ccc'\n *\n */\nfun longest(strings : List<Any>) : String? {\n    if (strings.isEmpty()) return null\n\n    var result = strings[0] as String\n    for (str in strings) {\n        val currentString = str as String\n        if (currentString.length > result.length)\n            result = currentString\n    }\n\n    return result\n}"}
{"task_id": "kotlin/4", "language": "kotlin", "completion": "/**\n * Du bist ein erfahrener Kotlin-Programmierer und hier ist deine Aufgabe.\n * Gib den gr\u00f6\u00dften gemeinsamen Teiler von zwei ganzen Zahlen a und b zur\u00fcck.\n * >>> greatest_common_divisor(3, 5)\n * 1\n * >>> greatest_common_divisor(25, 15)\n * 5\n *\n */\nfun greatestCommonDivisor(a : Int, b : Int) : Int {\n    return when{\n        a == b -> a\n        else -> greatestCommonDivisor(minOf(a,b), maxOf(a,b) % minOf(a,b))\n    }\n}"}
{"task_id": "kotlin/5", "language": "kotlin", "completion": "/**\n * Du bist ein erfahrener Kotlin-Programmierer und hier ist deine Aufgabe.\n * Die Eingabe ist ein durch Leerzeichen getrennter String von Ziffern von 'null' bis 'neun'.\n *     G\u00fcltige Optionen sind 'null', 'eins', 'zwei', 'drei', 'vier', 'f\u00fcnf', 'sechs', 'sieben', 'acht' und 'neun'.\n *     Gib den String mit den Zahlen sortiert von klein nach gro\u00df zur\u00fcck.\n * >>> sort_numbers('three one five')\n * 'one three five'\n */\nfun sortNumbers(numbers: String): String {\n    val numberList = numbers.split(\" \")\n    return numberList.sorted().joinToString(separator = \" \")\n}"}
{"task_id": "kotlin/6", "language": "kotlin", "completion": "/**\n * Du bist ein erfahrener Kotlin-Programmierer und hier ist deine Aufgabe.\n * Gegeben sei eine Liste von Zahlen (mit mindestens zwei Elementen). Wenden Sie eine lineare Transformation auf diese Liste an, so dass die kleinste Zahl zu 0 und die gr\u00f6\u00dfte zu 1 wird.\n * >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n * [0.0, 0.25, 0.5, 0.75, 1.0]\n */\nfun rescaleToUnit(numbers : List<Double>) : List<Double> {\n    var min = numbers[0]\n    var max = numbers[0]\n\n    for (number in numbers) {\n        if (number < min) {\n            min = number\n        }\n\n        if (number > max) {\n            max = number\n        }\n    }\n\n    val range = max - min\n    return numbers.map { (it - min) / range }\n}"}
{"task_id": "kotlin/7", "language": "kotlin", "completion": "/**\n * Du bist ein erfahrener Kotlin-Programmierer und hier ist deine Aufgabe.\n * F\u00fcr einen gegebenen String, tausche Kleinbuchstaben in Gro\u00dfbuchstaben und Gro\u00dfbuchstaben in Kleinbuchstaben um.\n * >>> flip_case('Hello')\n * 'hELLO'\n *\n */\nfun flipCase(string : String) : String {\n    var flipped = \"\"\n\n    for (char in string) {\n        if (Character.isUpperCase(char)) {\n            val lowerChar = Character.toLowerCase(char)\n\n            flipped += lowerChar\n        } else {\n            val upperChar = Character.toUpperCase(char)\n\n            flipped += upperChar\n        }\n    }\n\n    return flipped\n}"}
{"task_id": "kotlin/8", "language": "kotlin", "completion": "/**\n * Du bist ein erfahrener Kotlin-Programmierer und hier ist deine Aufgabe.\n * Gib nur positive Zahlen in der Liste zur\u00fcck.\n * >>> get_positive([-1, 2, -4, 5, 6])\n * [2, 5, 6]\n * >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n * [5, 3, 2, 3, 9, 123, 1]\n *\n */\nfun getPositive(l : List<Any>) : List<Any> {\n    val positiveList = mutableListOf<Any>()\n\n    for (e in l) {\n        if (e is Int && e > 0)\n            positiveList.add(e)\n    }\n    return positiveList\n}"}
{"task_id": "kotlin/9", "language": "kotlin", "completion": "/**\n * Du bist ein erfahrener Kotlin-Programmierer und hier ist deine Aufgabe.\n * Gib \"true\" zur\u00fcck, wenn eine gegebene Zahl eine Primzahl ist, andernfalls gib \"false\" zur\u00fcck.\n * >>> is_prime(6)\n * False\n * >>> is_prime(101)\n * True\n * >>> is_prime(11)\n * True\n * >>> is_prime(13441)\n * True\n * >>> is_prime(61)\n * True\n * >>> is_prime(4)\n * False\n * >>> is_prime(1)\n * False\n */\nfun isPrime(n : Int) : Boolean {\n    if (n <= 1)\n        return false\n\n    var i = 2\n\n    while (i*i <= n) {\n        if (n % i == 0)\n            return false\n        i += 1\n    }\n\n    return true;\n}"}
{"task_id": "kotlin/10", "language": "kotlin", "completion": "/**\n * Du bist ein erfahrener Kotlin-Programmierer und hier ist deine Aufgabe.\n * Gib sortierte eindeutige Elemente in einer Liste zur\u00fcck.\n * >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n * [0, 2, 3, 5, 9, 123]\n *\n */\nfun unique(l : List<Int>) : List<Int> {\n    return l.toSet().toList().sorted()\n}"}
{"task_id": "kotlin/11", "language": "kotlin", "completion": "/**\n *Du bist ein erfahrener Kotlin-Programmierer und hier ist deine Aufgabe.\n * * prime_fib gibt die n-te Zahl zur\u00fcck, die sowohl eine Fibonacci-Zahl als auch eine Primzahl ist.\n * >>> primeFib(1)\n * 2\n * >>> primeFib(2)\n * 3\n * >>> primeFib(3)\n * 5\n * >>> primeFib(4)\n * 13\n * >>> primeFib(5)\n * 89\n */\nfun primeFib(n : Int) : Int {"}
{"task_id": "kotlin/12", "language": "kotlin", "completion": "/**\n *Du bist ein erfahrener Kotlin-Programmierer und hier ist deine Aufgabe.\n * triples_sum_to_zero nimmt eine Liste von ganzen Zahlen als Eingabe.\n * Es gibt True zur\u00fcck, wenn es drei verschiedene Elemente in der Liste gibt, die zu Null addieren, andernfalls gibt es False zur\u00fcck.\n * >>> triples_sum_to_zero([1, 3, 5, 0])\n * False\n * >>> triples_sum_to_zero([1, 3, -2, 1])\n * True\n * >>> triples_sum_to_zero([1, 2, 3, 7])\n * False\n * >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n * True\n * >>> triples_sum_to_zero([1])\n * False\n *\n */\nfun triplesSumToZero(l : List<Int>) : Boolean {\n\n    return false\n}"}
{"task_id": "kotlin/13", "language": "kotlin", "completion": "/**\n * Du bist ein erfahrener Kotlin-Programmierer und hier ist deine Aufgabe.\n * * pairs_sum_to_zero nimmt eine Liste von ganzen Zahlen als Eingabe.\n * Es gibt True zur\u00fcck, wenn es zwei unterschiedliche Elemente in der Liste gibt, die sich zu Null addieren, andernfalls gibt es False zur\u00fcck.\n * >>> pairs_sum_to_zero([1, 3, 5, 0])\n * False\n * >>> pairs_sum_to_zero([1, 3, -2, 1])\n * False\n * >>> pairs_sum_to_zero([1, 2, 3, 7])\n * False\n * >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n * True\n * >>> pairs_sum_to_zero([1])\n * False\n */\nfun pairsSumToZero(l : List<Int>) : Boolean {\n    for (i in l.indices) {\n        if(l[i] == 0)\n            return true\n        for(j in i+1 until l.size) {\n            if((l[i] + l[j]) == 0)\n                return true\n\n        }\n\n    }\n    return false\n}"}
{"task_id": "kotlin/14", "language": "kotlin", "completion": "/**\n *Du bist ein erfahrener Kotlin-Programmierer und hier ist deine Aufgabe.\n * Die Fib4-Zahlenfolge ist eine Folge \u00e4hnlich der Fibonacci-Folge, die wie folgt definiert ist:\n *     fib4(0) -> 0\n *     fib4(1) -> 0\n *     fib4(2) -> 2\n *     fib4(3) -> 0\n *     fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n *     Bitte schreiben Sie eine Funktion, um das n-te Element der Fib4-Zahlenfolge effizient zu berechnen. Verwenden Sie keine Rekursion.\n * >>> fib4(5)\n * 4\n * >>> fib4(6)\n * 8\n * >>> fib4(7)\n * 14\n */\nfun fib4(n : Int) : Int {\n    if (n == 0 || n == 1) return 0\n\n    var f1 = 0\n    var f2 = 0\n    var f3 = 2\n    var fn = 0\n\n    for (i in 3..n-1) {\n        fn = f1 + f2 + f3\n\n        f1 = f2\n        f2 = f3\n        f3 = fn\n    }\n\n    return fn\n}"}
{"task_id": "kotlin/15", "language": "kotlin", "completion": "/**\n * Du bist ein erfahrener Kotlin-Programmierer und hier ist deine Aufgabe.\n * Gib den Median der Elemente in der Liste l zur\u00fcck.\n * >>> median([3, 1, 2, 4, 5])\n * 3\n * >>> median([-10, 4, 6, 1000, 10, 20])\n * 15.0\n *\n */\nfun median(l : List<Int>) : Any {\n    var list = l\n    if (list.isEmpty()) return null\n    val size = list.size\n    list = list.sorted()\n\n    //if the list has an odd number of elements, we can simply return the middle element\n    if (size % 2 == 1) {\n        return list[(size - 1) / 2]\n    } else {   //in case it's even, we return the average of the two middle elements\n        val i = size/2\n        return (list[i-1] + list[i]).toDouble() / 2.0\n    }\n}"}
{"task_id": "kotlin/16", "language": "kotlin", "completion": "/**\n * Du bist ein erfahrener Kotlin-Programmierer und hier ist deine Aufgabe.\n * * \u00dcberpr\u00fcft, ob der gegebene String ein Palindrom ist.\n * >>> is_palindrome('')\n * True\n * >>> is_palindrome('aba')\n * True\n * >>> is_palindrome('aaaaa')\n * True\n * >>> is_palindrome('zbcd')\n * False\n */\nfun isPalindrome(text : String) : Boolean {\n    var forward = 0\n    val backward = text.length -1\n\n    while (forward < backward) {\n        if (text[forward] != text[backward])\n            return false\n\n        ++forward\n        --backward\n    }\n    return true\n}"}
{"task_id": "kotlin/17", "language": "kotlin", "completion": "/**\n * Du bist ein erfahrener Kotlin-Programmierer und hier ist deine Aufgabe.\n * * remove_vowels ist eine Funktion, die einen String entgegennimmt und einen String ohne Vokale zur\u00fcckgibt.\n * >>> remove_vowels('')\n * ''\n * >>> remove_vowels(\"abcdef\\nghijklm\")\n * 'bcdf\\nghjklm'\n * >>> remove_vowels('abcdef')\n * 'bcdf'\n * >>> remove_vowels('aaaaa')\n * ''\n * >>> remove_vowels('aaBAA')\n * 'B'\n * >>> remove_vowels('zbcd')\n * 'zbcd'\n */\nfun removeVowels(text: String): String = text.replace(\"[aeiouAEIOU]\".toRegex(), \"\")"}
{"task_id": "kotlin/18", "language": "kotlin", "completion": "/**\n * Du bist ein erfahrener Kotlin-Programmierer und hier ist deine Aufgabe.\n * Gib True zur\u00fcck, wenn alle Zahlen in der Liste l unterhalb des Schwellenwerts t liegen.\n * >>> below_threshold([1, 2, 4, 10], 100)\n * True\n * >>> below_threshold([1, 20, 4, 10], 5)\n * False\n *\n */\nfun belowThreshold(l : List<Int>, t : Int) : Boolean {\n    var below = true;\n\n    for (x in l) {\n        if (x >= t) {\n            below = false;\n            break;\n        }\n    }\n    return below;\n}"}
{"task_id": "kotlin/19", "language": "kotlin", "completion": "/**\n * Du bist ein erfahrener Kotlin-Programmierer und hier ist deine Aufgabe.\n * Addiere zwei Zahlen x und y.\n * >>> add(2, 3)\n * 5\n * >>> add(5, 7)\n * 12\n *\n */\nfun add(x : Int, y : Int) = x + y"}
{"task_id": "kotlin/20", "language": "kotlin", "completion": "/**\n * Du bist ein erfahrener Kotlin-Programmierer und hier ist deine Aufgabe.\n * * \u00dcberpr\u00fcfen Sie, ob zwei W\u00f6rter dieselben Zeichen enthalten.\n * >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n * True\n * >>> same_chars('abcd', 'dddddddabc')\n * True\n * >>> same_chars('dddddddabc', 'abcd')\n * True\n * >>> same_chars('eabcd', 'dddddddabc')\n * False\n * >>> same_chars('abcd', 'dddddddabce')\n * False\n * >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n * False\n */\nfun sameChars(s0 : String, s1 : String) : Boolean {"}
{"task_id": "kotlin/21", "language": "kotlin", "completion": "/**\n * Du bist ein erfahrener Kotlin-Programmierer und hier ist deine Aufgabe.\n * Gib die n-te Fibonacci-Zahl zur\u00fcck.\n * >>> fib(10)\n * 55\n * >>> fib(1)\n * 1\n * >>> fib(8)\n * 21\n */\nfun main() {\n    println(\"Hier ist deine Aufgabe: \")\n    val n = readLine()?.toIntOrNull() ?: throw NumberFormatException(\"Ung\u00fcltige Eingabe.\")\n    println(fib(n))\n}\n\nfun fib(n : Int) : Int {\n\n    if (n <= 0) return 1;\n    else {\n        var a = 1\n        var b = 1\n\n        for (i in 2..n-1) {\n            val c = a + b\n            a = b\n            b = c\n        }\n\n        return b\n    }\n}"}
{"task_id": "kotlin/22", "language": "kotlin", "completion": "/**\n * Du bist ein erfahrener Kotlin-Programmierer und hier ist deine Aufgabe.\n * Gib sortierte eindeutige gemeinsame Elemente f\u00fcr zwei Listen zur\u00fcck.\n * >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n * [1, 5, 653]\n * >>> common([5, 3, 2, 8], [3, 2])\n * [2, 3]\n\n *\n */\nfun common(l1 : List<Int>, l2 : List<Any>) : List<Any> {\n    val set = l1.toSet()\n    return set.intersect(l2).toList().sorted()\n}"}
{"task_id": "kotlin/23", "language": "kotlin", "completion": "/**\n * Du bist ein erfahrener Kotlin-Programmierer und hier ist deine Aufgabe.\n * Gib den gr\u00f6\u00dften Primfaktor von n zur\u00fcck. Gehe davon aus, dass n > 1 und keine Primzahl ist.\n * >>> largest_prime_factor(13195)\n * 29\n * >>> largest_prime_factor(2048)\n * 2\n *\n */\nfun largestPrimeFactor(n : Int) : Int {\n    if (n % 2 == 0)\n        return 2;\n    for (i in 3..Math.sqrt(n).toInt step 2) {\n        if (n % i == 0)\n            return i;\n    }\n    return n;\n}"}
{"task_id": "kotlin/24", "language": "kotlin", "completion": "/**\n *Du bist ein erfahrener Kotlin-Programmierer und hier ist deine Aufgabe.\n * sum_to_n ist eine Funktion, die Zahlen von 1 bis n summiert.\n * >>> sum_to_n(30)\n * 465\n * >>> sum_to_n(100)\n * 5050\n * >>> sum_to_n(5)\n * 15\n * >>> sum_to_n(10)\n * 55\n * >>> sum_to_n(1)\n * 1\n */\nfun sumToN(n: Int): Int {\n    var sum = 0;\n\n    for (i in 1..n) {\n        sum += i\n    }\n    return sum\n}"}
{"task_id": "kotlin/25", "language": "kotlin", "completion": "/**\n * Du bist ein erfahrener Kotlin-Programmierer und hier ist deine Aufgabe.\n * xs repr\u00e4sentieren die Koeffizienten eines Polynoms.\n *     xs[0] + xs[1] * x + xs[2] * x^2 + ....\n *     Gib die Ableitung dieses Polynoms in derselben Form zur\u00fcck.\n * >>> derivative([3, 1, 2, 4, 5])\n * [1, 4, 12, 20]\n * >>> derivative([1, 2, 3])\n * [2, 6]\n */\nfun derivative(xs : List<Int>) : List<Any> {\n    val ys = mutableListOf<Any>()\n\n    for (i in xs.indices) {\n        if (i == 0) {\n            ys.add(xs[i+1])\n        } else {\n            ys.add(xs[i]*i)\n        }\n    }\n\n    return ys\n}"}
{"task_id": "kotlin/26", "language": "kotlin", "completion": "/**\n * Du bist ein erfahrener Kotlin-Programmierer und hier ist deine Aufgabe.\n * Die FibFib-Zahlenfolge ist eine Folge \u00e4hnlich der Fibonacci-Folge, die wie folgt definiert ist:\n *     fibfib(0) == 0\n *     fibfib(1) == 0\n *     fibfib(2) == 1\n *     fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n *     Bitte schreiben Sie eine Funktion, um das n-te Element der FibFib-Zahlenfolge effizient zu berechnen.\n * >>> fibfib(1)\n * 0\n * >>> fibfib(5)\n * 4\n * >>> fibfib(8)\n * 24\n */\nfun main() {\n    println(fibfib(1)) //0\n    println(fibfib(5)) //4\n    println(fibfib(8)) //24\n}\n\ntailrec fun fibfib(n: Int): Int{\n    if(n == 0) return 0\n    else if(n == 1) return 0\n    else if(n == 2) return 1\n\n    var a = 0\n    var b = 0\n    var c = 1\n\n    for (i in 3..n){\n        val temp = a + b + c\n        a = b\n        b = c\n        c = temp\n    }\n\n    return c\n}"}
{"task_id": "kotlin/27", "language": "kotlin", "completion": "/**\n * Du bist ein erfahrener Kotlin-Programmierer und hier ist deine Aufgabe.\n * Schreiben Sie eine Funktion vowels_count, die einen String, der ein Wort repr\u00e4sentiert, als Eingabe erh\u00e4lt und die Anzahl der Vokale im String zur\u00fcckgibt. Vokale sind in diesem Fall 'a', 'e', 'i', 'o', 'u'. Hierbei ist 'y' auch ein Vokal, aber nur wenn es am Ende des gegebenen Wortes steht.\n * \n * Beispiel:\n * >>> vowels_count(\"abcde\")\n * 2\n * >>> vowels_count(\"ACEDY\")\n * 3\n */\nfun vowelsCount(s : String) : Int {\n  var count = 0\n  \n  for (letter in s)\n    if (letter == 'a' || letter == 'e' || letter == 'i' || letter == 'o' || letter == 'u')\n      count += 1\n    else if (letter == 'y' && s.last() == 'y')\n      count += 1\n\n  return count\n}"}
{"task_id": "kotlin/28", "language": "kotlin", "completion": "/**\n *Du bist ein erfahrener Kotlin-Programmierer und hier ist deine Aufgabe.\n * * Sie erhalten eine nicht-leere Liste von positiven Ganzzahlen. Geben Sie die gr\u00f6\u00dfte Ganzzahl zur\u00fcck, die gr\u00f6\u00dfer als Null ist und eine H\u00e4ufigkeit hat, die gr\u00f6\u00dfer oder gleich dem Wert der Ganzzahl selbst ist. Die H\u00e4ufigkeit einer Ganzzahl ist die Anzahl der Male, die sie in der Liste vorkommt. Wenn kein solcher Wert existiert, geben Sie -1 zur\u00fcck. Beispiele:\n * \n *     search([4, 1, 2, 2, 3, 1]) == 2\n *     search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n *     search([5, 5, 4, 4, 4]) == -1\n *\n */\nfun search(lst : List<Int>) : Int {\n    var map = mutableMapOf<Int, Int>()\n\n    for (i in lst) {\n        if (map.containsKey(i))\n            map[i] = map[i] ?: 0 + 1\n        else\n            map[i] = 1\n    }\n\n    return map.keys.sortedDescending().firstOrNull() ?: -1\n}"}
{"task_id": "kotlin/29", "language": "kotlin", "completion": "fun triangleArea(a : Int, b : Int, c : Int) : Double {\n    if (a + b > c && a + c > b && b + c > a){\n        val s = (a + b + c) / 2.0\n        return Math.sqrt(s * (s - a) * (s - b) * (s - c)).roundedTo(2)\n    }\n    else return -1.0\n}\nfun Double.roundedTo(digits: Int) = \"%.${digits}f\".format(this).toDouble()"}
{"task_id": "kotlin/30", "language": "kotlin", "completion": "/**\n * Du bist ein erfahrener Kotlin-Programmierer und hier ist deine Aufgabe.\n * * Schreiben Sie eine Funktion, die True zur\u00fcckgibt, wenn das Objekt q fliegen wird, und False sonst. Das Objekt q wird fliegen, wenn es ausbalanciert ist (es ist eine palindromische Liste) und die Summe seiner Elemente kleiner oder gleich dem maximal m\u00f6glichen Gewicht w ist.\n * \n *     Beispiel:\n *     will_it_fly([1, 2], 5) \u279e False \n *     # 1+2 ist kleiner als das maximal m\u00f6gliche Gewicht, aber es ist unausgeglichen.\n * \n *     will_it_fly([3, 2, 3], 1) \u279e False\n *     # es ist ausbalanciert, aber 3+2+3 ist mehr als das maximal m\u00f6gliche Gewicht.\n * \n *     will_it_fly([3, 2, 3], 9) \u279e True\n *     # 3+2+3 ist kleiner als das maximal m\u00f6gliche Gewicht, und es ist ausbalanciert.\n * \n *     will_it_fly([3], 5) \u279e True\n *     # 3 ist kleiner als das maximal m\u00f6gliche Gewicht, und es ist ausbalanciert.\n * \n *\n */\nfun willItFly(q : List<Int>, w : Int) : Boolean {\n    if (w < q.sum()) return false\n    \n    val left = q.dropLast(1)\n    val right = q.reversed().dropLast(1).reversed()\n    \n    var stack: Stack<Char> = Stack()\n\n    for ((index, c) in left.withIndex()) {\n        while (stack.isNotEmpty() && stack.peek() < c) stack.pop()\n\n        if (stack.isEmpty() || stack.peek() > c) {\n            stack.push(c)\n        }\n    }\n\n    if (stack.isNotEmpty()) return false\n\n    for ((index, c) in right.withIndex()) {\n        while (stack.isNotEmpty() && stack.peek() < c) stack.pop()\n\n        if (stack.isEmpty() || stack.peek() > c) {\n            stack.push(c)\n        }\n    }\n\n    return stack.isEmpty()\n}"}
{"task_id": "kotlin/31", "language": "kotlin", "completion": "/**\n *Du bist ein erfahrener Kotlin-Programmierer und hier ist deine Aufgabe.\n * Schreiben Sie eine Funktion, die true zur\u00fcckgibt, wenn die gegebene Zahl das Produkt von 3 Primzahlen ist, und false sonst. Dabei ist bekannt, dass (a) kleiner als 100 ist. Beispiel:\n * \n * is_multiply_prime(30) == True\n * 30 = 2 * 3 * 5\n *\n */\nfun isMultiplyPrime(a : Int) : Boolean {\n    var current_number = a\n    for (i in 2..current_number / 2) {\n        if (current_number % i == 0 && isPrime(i)) {\n            current_number /= i\n            i--\n        }\n    }\n    return current_number == 1\n}\n\nfun isPrime(n: Int): Boolean {\n    // check if n is a multiple of 2\n    if (n % 2 == 0) return false\n\n    // if not, then just check the odds\n    for (i in 3..sqrt(n.toDouble()).toInt()) {\n        if (n % i == 0)\n            return false\n    }\n\n    return true\n}"}
{"task_id": "kotlin/32", "language": "kotlin", "completion": "/**\n *Du bist ein erfahrener Kotlin-Programmierer und hier ist deine Aufgabe.\n * Sie erhalten eine Zahl in Dezimalform und Ihre Aufgabe besteht darin, sie in das Bin\u00e4rformat umzuwandeln. Die Funktion sollte einen String zur\u00fcckgeben, wobei jedes Zeichen eine Bin\u00e4rzahl darstellt. Jedes Zeichen im String wird '0' oder '1' sein.\n * \n * Es wird ein zus\u00e4tzliches Paar von Zeichen 'db' am Anfang und am Ende des Strings geben. Die zus\u00e4tzlichen Zeichen dienen zur Formatierungshilfe.\n * \n * Beispiele:\n * \n * decimal_to_binary(15)   # returns \"db1111db\"\n * decimal_to_binary(32)   # returns \"db100000db\"\n */\nfun decimalToBinary(decimal : Int) : String {\n    if (decimal == 0) return \"db0db\"\n\n    var remainder = decimal\n    var quotient = 0\n    val binary = StringBuilder()\n\n    while (remainder > 0) {\n        quotient = remainder and 1\n\n        binary.append(quotient)\n        remainder = remainder shr 1\n    }\n    binary.reverse()\n\n    return \"db$binarydb\"\n}"}
{"task_id": "kotlin/33", "language": "kotlin", "completion": "/**\n * Du bist ein erfahrener Kotlin-Programmierer und hier ist deine Aufgabe.\n * Du erh\u00e4ltst einen String s.\n * Deine Aufgabe ist es zu \u00fcberpr\u00fcfen, ob der String gl\u00fccklich ist oder nicht.\n * Ein String ist gl\u00fccklich, wenn seine L\u00e4nge mindestens 3 betr\u00e4gt und jede Gruppe von 3 aufeinanderfolgenden Buchstaben unterschiedlich ist.\n * Zum Beispiel:\n * \n * is_happy(a) => False\n * is_happy(aa) => False\n * is_happy(abcd) => True\n * is_happy(aabb) => False\n * is_happy(adb) => True\n * is_happy(xyy) => False\n */\nfun isHappy(s: String): Boolean {\n    if (s.length < 3) return false\n\n    val charList = s.toList()\n    for ((index, value) in charList.withIndex()) {\n        if (index > 1 && charList[index - 2] == value && charList[index - 1] == value)\n            return false\n    }\n\n    return true\n}"}
{"task_id": "kotlin/34", "language": "kotlin", "completion": "/**\n * Du bist ein erfahrener Kotlin-Programmierer und hier ist deine Aufgabe.\n * Es ist die letzte Woche des Semesters und der Lehrer muss die Noten an die Sch\u00fcler verteilen. Der Lehrer hat seinen eigenen Algorithmus zur Bewertung entwickelt. Das einzige Problem ist, dass er den Code, den er zur Bewertung verwendet hat, verloren hat. Er hat Ihnen eine Liste von GPAs f\u00fcr einige Sch\u00fcler gegeben und Sie m\u00fcssen eine Funktion schreiben, die eine Liste von Buchstabennoten gem\u00e4\u00df der folgenden Tabelle aus gibt:\n * \n *              GPA       |    Buchstaben Note\n *               4.0                A+\n *             > 3.7                A \n *             > 3.3                A- \n *             > 3.0                B+\n *             > 2.7                B \n *             > 2.3                B-\n *             > 2.0                C+\n *             > 1.7                C\n *             > 1.3                C-\n *             > 1.0                D+ \n *             > 0.7                D \n *             > 0.0                D-\n *               0.0                E\n *     \n * \n *     Beispiel:\n * \n * grade_equation([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n *\n */\nfun numericalLetterGrade(grades : List<Any>) : List<String> {\n    return grades.map { when (it) {\n        in 4.0..Double.MAX_VALUE -> \"A+\"\n        in 3.7..3.999999 -> \"A\"\n        in 3.3..3.6999999 -> \"A-\"\n        in 3.0..3.2999999 -> \"B+\"\n        in 2.7..2.9999999 -> \"B\"\n        in 2.3..2.6999999 -> \"B-\"\n        in 2.0..2.2999999 -> \"C+\"\n        in 1.7..1.9999999 -> \"C\"\n        in 1.3..1.6999999 -> \"C-\"\n        in 1.0..1.2999999 -> \"D+\"\n        in 0.7..0.9999999 -> \"D\"\n        in 0.0..Double.MIN_VALUE -> \"D-\"\n        else -> \"E\"\n    }}\n}"}
{"task_id": "kotlin/35", "language": "kotlin", "completion": "/**\n *Du bist ein erfahrener Kotlin-Programmierer und hier ist deine Aufgabe.\n * Schreiben Sie eine Funktion, die einen String entgegennimmt und True zur\u00fcckgibt, wenn die L\u00e4nge des Strings eine Primzahl ist, andernfalls False.\n *     Beispiele\n * \n * prime_length('Hello') == True\n * prime_length('abcdcba') == True\n * prime_length('kittens') == True\n * prime_length('orange') == False\n */\nfun primeLength(string: String): Boolean {\n    // your code here\n    if (string.length == 0) return false\n\n    var i = 2\n    while (i < string.length) {\n        if (string.length % i == 0)\n            return false\n\n        i += 1\n    }\n    return true\n}"}
{"task_id": "kotlin/36", "language": "kotlin", "completion": "/**\n * Du bist ein erfahrener Kotlin-Programmierer und hier ist deine Aufgabe.\n * Gegeben eine positive Ganzzahl N, gib die Gesamtsumme ihrer Ziffern in bin\u00e4rer Form zur\u00fcck.\n * \n *     Beispiel\n *         F\u00fcr N = 1000 ist die Summe der Ziffern 1, die Ausgabe sollte \"1\" sein.\n *         F\u00fcr N = 150 ist die Summe der Ziffern 6, die Ausgabe sollte \"110\" sein.\n *         F\u00fcr N = 147 ist die Summe der Ziffern 12, die Ausgabe sollte \"1100\" sein.\n *     \n *     Variablen:\n *         @N Ganzzahl\n *              Einschr\u00e4nkungen: 0 \u2264 N \u2264 10000.\n *     Ausgabe:\n *          eine Zeichenkette mit der bin\u00e4ren Zahl.\n * \n */\nfun solve(n : Int) : String {\n    return n.toString().map{ it - '0' }.sum().toString(2)\n}"}
{"task_id": "kotlin/37", "language": "kotlin", "completion": "/**\n *Du bist ein erfahrener Kotlin-Programmierer und hier ist deine Aufgabe.\n * * Sie erhalten eine zweidimensionale Datenstruktur als verschachtelte Listen, die einer Matrix \u00e4hnelt, jedoch k\u00f6nnen im Gegensatz zu Matrizen unterschiedlich viele Spalten in jeder Zeile vorhanden sein. Gegeben sei eine Liste \"lst\" und eine ganze Zahl \"x\". Finden Sie die Zahlen \"x\" in der Liste und geben Sie eine Liste von Tupeln zur\u00fcck, [(x1, y1), (x2, y2) ...], wobei jedes Tupel eine Koordinate (Zeile, Spalte) darstellt, beginnend bei 0. Sortieren Sie die Koordinaten zun\u00e4chst nach Zeilen in aufsteigender Reihenfolge. Sortieren Sie auch die Koordinaten der Zeile nach Spalten in absteigender Reihenfolge.\n * \n * Beispiele:\n * \n * get_row([\n *   [1,2,3,4,5,6],\n *   [1,2,3,4,1,6],\n *   [1,2,3,4,5,1]\n * ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n * get_row([], 1) == []\n * get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n */\nfun getRow(lst: List<List<Int>>, x: Int): List<Pair<Int, Int>> {\n    val coordinate = mutableListOf<Pair<Int, Int>>()\n\n    lst.forEachIndexed { index, subList ->\n        subList.forEachIndexed { ind, number ->\n            if (x == number) {\n                coordinate.add(Pair(index, ind))\n            }\n        }\n    }\n    return coordinate\n}"}
{"task_id": "kotlin/38", "language": "kotlin", "completion": "/**\n * Du bist ein erfahrener Kotlin-Programmierer und hier ist deine Aufgabe.\n * * Sie erhalten eine Liste von ganzen Zahlen.\n * Schreiben Sie eine Funktion next_smallest(), die das zweitkleinste Element der Liste zur\u00fcckgibt.\n * Geben Sie null zur\u00fcck, wenn es kein solches Element gibt.\n * next_smallest([1, 2, 3, 4, 5]) == 2\n * next_smallest([5, 1, 4, 3, 2]) == 2\n * next_smallest([]) == None\n * next_smallest([1, 1]) == None\n *\n */\nfun nextSmallest(lst : List<Int>) : Int? {\n    var min = lst.min()\n\n    return if (min != null) lst.filter{ it < min }.max() else null\n}"}
{"task_id": "kotlin/39", "language": "kotlin", "completion": "/**\n *Du bist ein erfahrener Kotlin-Programmierer und hier ist deine Aufgabe.\n * * Du bekommst einen String von W\u00f6rtern und deine Aufgabe ist es, die Anzahl der Langeweilen zu z\u00e4hlen. Eine Langeweile ist ein Satz, der mit dem Wort \"Ich\" beginnt. S\u00e4tze werden durch '.', '?' oder '!' begrenzt.\n * \n * Zum Beispiel:\n * >>> is_bored(\"Hello world\")\n * 0\n * >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n * 1\n */\nfun isBored(s : String) : Int {\n\tval sentences = s.split(\".\")\n    var counter = 0;\n    for (sentence in sentences) {\n        if (sentence.startsWith(\"Ich\")) {\n            ++counter;\n        }\n    }\n\n    return counter;\n}"}
{"task_id": "kotlin/40", "language": "kotlin", "completion": "/**\n *Du bist ein erfahrener Kotlin-Programmierer und hier ist deine Aufgabe.\n * Sie erhalten eine Liste von ganzen Zahlen.\n *     Sie m\u00fcssen den gr\u00f6\u00dften Primzahlwert finden und die Summe seiner Ziffern zur\u00fcckgeben.\n * \n *     Beispiele:\n * \n * For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n * For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n * For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n * For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n * For lst = [0,81,12,3,1,21] the output should be 3\n * For lst = [0,8,1,2,1,7] the output should be 7\n */\nfun main() {\n    println(skjkasdkd(listOf(0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3)))\n}\nfun skjkasdkd(lst : List<Int>) : Int {\n    var max = 0\n\n    for (i in lst) {\n        if (isPrime(i)) {\n            var summe = 0\n\n            while (i != 0) {\n                val temp = i % 10\n\n                i /= 10\n\n                summe += temp\n            }\n\n            if (summe > max) max = summe\n        }\n    }\n\n    return max\n}\nfun isPrime(i : Int) : Boolean {\n    if (i <= 1) return false\n\n    for (j in 2 until Math.sqrt(i.toDouble()).toInt()) {\n        if (i % j == 0) return false\n    }\n\n    return true\n}"}
{"task_id": "kotlin/41", "language": "kotlin", "completion": "/**\n * Du bist ein erfahrener Kotlin-Programmierer und hier ist deine Aufgabe.\n * * Gegeben ein W\u00f6rterbuch, gibt True zur\u00fcck, wenn alle Schl\u00fcssel Strings in Kleinbuchstaben oder alle Schl\u00fcssel Strings in Gro\u00dfbuchstaben sind, sonst gibt es False zur\u00fcck. Die Funktion sollte False zur\u00fcckgeben, wenn das gegebene W\u00f6rterbuch leer ist. Beispiele:\n * \n * check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) should return True.\n * check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n * check_dict_case({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return False.\n * check_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n * check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n *\n */\nfun checkDictCase(dict : Map<Any?, Any?>) : Boolean {\n    // Your code here..."}
{"task_id": "kotlin/42", "language": "kotlin", "completion": "/**\n * Du bist ein erfahrener Kotlin-Programmierer und hier ist deine Aufgabe.\n * * Erstellen Sie eine Funktion, die einen Wert (String) annimmt, der eine Zahl darstellt, und gibt die n\u00e4chstgelegene Ganzzahl zur\u00fcck. Wenn die Zahl gleich weit von zwei Ganzzahlen entfernt ist, runden Sie sie weg von Null.\n * \n *     Beispiele\n * >>> closest_integer(\"10\")\n * 10\n * >>> closest_integer(\"15.3\")\n * 15\n\n * Note:\n * Rounding away from zero means that if the given number is equidistant\n * from two integers, the one you should return is the one that is the\n * farthest from zero. For example closest_integer(\"14.5\") should\n * return 15 and closest_integer(\"-14.5\") should return -15.\n */\nfun main(args: Array<String>) {\n    val value = \"10\"\n    println(closestInteger(value)) // Should print 10\n}\n\nfun closestInteger(value : String) : Int {\n    var roundedValue = 0\n\n    if (value.contains(\".\")) {\n        val parts = value.split(\".\")\n        val decimalPart = parts[1].toDouble()\n\n        if (decimalPart == 0.5 || decimalPart == -0.5) {\n            val intPart = parts[0].toInt()\n            roundedValue = if (intPart > 0) {\n                intPart + 1\n            } else {\n                intPart - 1\n            }\n        }\n    }\n\n    return roundedValue\n}"}
{"task_id": "kotlin/43", "language": "kotlin", "completion": "/**\n * Du bist ein erfahrener Kotlin-Programmierer und hier ist deine Aufgabe.\n * * Gegeben eine positive ganze Zahl n, m\u00fcssen Sie einen Haufen von n Ebenen von Steinen machen.\n *     Die erste Ebene hat n Steine.\n *     Die Anzahl der Steine in der n\u00e4chsten Ebene ist:\n *         - die n\u00e4chste ungerade Zahl, wenn n ungerade ist.\n *         - die n\u00e4chste gerade Zahl, wenn n gerade ist.\n *     Geben Sie die Anzahl der Steine in jeder Ebene in einer Liste zur\u00fcck, wobei das Element an Index\n *     i die Anzahl der Steine in der Ebene (i+1) darstellt.\n * \n *     Beispiele:\n * >>> make_a_pile(3)\n * [3, 5, 7]\n */\nfun makeAPile(n : Int) = when {\n    n % 2 == 0 -> makeAPileHelper(n - 1).plusElement(n + 1)\n    else        -> makeAPileHelper(n).plusElement(n + 2)\n}\nprivate fun makeAPileHelper(n : Int) = if (n <= 1) listOf() else makeAPileHelper(n - 2).plusElement(n)"}
{"task_id": "kotlin/44", "language": "kotlin", "completion": "/**\n *Du bist ein erfahrener Kotlin-Programmierer und hier ist deine Aufgabe.\n * * Sie erhalten einen String von W\u00f6rtern, die durch Kommas oder Leerzeichen getrennt sind. Ihre Aufgabe ist es, den String in W\u00f6rter aufzuteilen und ein Array der W\u00f6rter zur\u00fcckzugeben.\n * \n * Zum Beispiel:\n * \n * words_string(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n * words_string(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n */\nfun wordsString(s : String) : List<Any> {\n\n    val list = s.split(Regex(\"[ ,]\"))\n    return list;\n}"}
{"task_id": "kotlin/45", "language": "kotlin", "completion": "/**\n *Du bist ein erfahrener Kotlin-Programmierer und hier ist deine Aufgabe.\n * Diese Funktion nimmt zwei positive Zahlen x und y entgegen und gibt die gr\u00f6\u00dfte gerade Zahl zur\u00fcck, die im Bereich [x, y] enthalten ist. Wenn es keine solche Zahl gibt, sollte die Funktion -1 zur\u00fcckgeben.\n * \n * Zum Beispiel:\n * \n * choose_num(12, 15) = 14\n * choose_num(13, 12) = -1\n *\n */\nfun chooseNum(x : Int, y : Int) : Int {\n    return if (x > y) -1 else {\n        for (i in x..y step 2) {\n            return i;\n        }\n        -1;\n    }\n}"}
{"task_id": "kotlin/46", "language": "kotlin", "completion": "/**\n *Du bist ein erfahrener Kotlin-Programmierer und hier ist deine Aufgabe.\n * Sie erhalten zwei positive Ganzzahlen n und m. Ihre Aufgabe besteht darin, den Durchschnitt der Ganzzahlen von n bis m (einschlie\u00dflich n und m) zu berechnen. Runden Sie die Antwort auf die n\u00e4chste Ganzzahl und konvertieren Sie diese in bin\u00e4r. Wenn n gr\u00f6\u00dfer als m ist, geben Sie -1 zur\u00fcck. Beispiel:\n * \n * rounded_avg(1, 5) => \"0b11\"\n * rounded_avg(7, 5) => -1\n * rounded_avg(10, 20) => \"0b1111\"\n * rounded_avg(20, 33) => \"0b11010\"\n *\n */\nfun main() {\n    fun roundedAvg(n : Int, m : Int) : Any {\n        var avg = (n + m) / 2\n        return if (n > m)\n            -1\n        else\n            Integer.toBinaryString(avg)\n    }\n\n    println(\"rounded_avg(1, 5) => ${roundedAvg(1, 5)}\")\n    println(\"rounded_avg(7, 5) => ${roundedAvg(7, 5)}\")\n    println(\"rounded_avg(10, 20) => ${roundedAvg(10, 20)}\")\n    println(\"rounded_avg(20, 33) => ${roundedAvg(20, 33)}\")\n}"}
{"task_id": "kotlin/47", "language": "kotlin", "completion": "/**\n * Du bist ein erfahrener Kotlin-Programmierer und hier ist deine Aufgabe.\n * Implementieren Sie die Funktion f, die n als Parameter annimmt und eine Liste der Gr\u00f6\u00dfe n zur\u00fcckgibt, wobei der Wert des Element an der Stelle i das Fakult\u00e4t von i ist, wenn i gerade ist, oder die Summe der Zahlen von 1 bis i, wenn i ungerade ist. i beginnt bei 1. Die Fakult\u00e4t von i ist das Produkt der Zahlen von 1 bis i (1 * 2 * ... * i). Beispiel:\n * \n * f(5) == [1, 2, 6, 24, 15]\n *\n */\nfun f(n : Int) : List<Int> {\n    var list = mutableListOf<Int>()\n    for (i in 1..n) {\n        if (i % 2 == 0) {\n            list.add(factorial(i))\n        } else {\n            list.add(sumUntilI(i))\n        }\n    }\n    return list\n}\n\nfun factorial(i: Int): Int = if (i <= 1) 1 else i * factorial(i - 1)\n\nfun sumUntilI(i: Int): Int {\n    var sum = 0;\n    for (j in 1..i){\n        sum += j\n    }\n    return sum\n}"}
{"task_id": "kotlin/48", "language": "kotlin", "completion": "/**\n *Du bist ein erfahrener Kotlin-Programmierer und hier ist deine Aufgabe.\n * * Gegeben eine positive ganze Zahl n, gibt eine Tupel zur\u00fcck, das die Anzahl der geraden und ungeraden ganzen Palindrome enth\u00e4lt, die im Bereich (1, n) einschlie\u00dflich liegen.\n * \n *     Beispiel 1:\n * \n *         Eingabe: 3\n *         Ausgabe: (1, 2)\n *         Erkl\u00e4rung:\n *         Ganze Palindrome sind 1, 2, 3. Eines davon ist gerade und zwei davon sind ungerade.\n * \n *     Beispiel 2:\n * \n *         Eingabe: 12\n *         Ausgabe: (4, 6)\n *         Erkl\u00e4rung:\n *         Ganze Palindrome sind 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. Vier davon sind gerade und sechs davon sind ungerade.\n * \n *     Hinweis:\n *         1. 1 <= n <= 10^3\n *         2. Das zur\u00fcckgegebene Tupel enth\u00e4lt die Anzahl der geraden und ungeraden ganzen Palindrome.\n */\nfun evenOddPalindrome(n : Int) = (1..n).map { it.toString() == it.toString().reversed() }.let {\n    val odd = it.count{it}\n    val even = it.size - odd\n    listOf(even, odd)\n}"}
{"task_id": "kotlin/49", "language": "kotlin", "completion": "/**\n *Du bist ein erfahrener Kotlin-Programmierer und hier ist deine Aufgabe.\n * Wir haben ein Array 'arr' mit N ganzen Zahlen arr[1], arr[2], ..., arr[N]. Die Zahlen im Array werden zuf\u00e4llig angeordnet sein. Deine Aufgabe besteht darin zu bestimmen, ob es m\u00f6glich ist, ein Array in nicht abnehmender Reihenfolge zu sortieren, indem du die folgende Operation auf das gegebene Array anwendest:\n * Du darfst beliebig oft eine Rechtsschiebeoperation durchf\u00fchren.\n * Eine Rechtsschiebeoperation bedeutet, dass alle Elemente des Arrays um eine Position in Richtung rechts verschoben werden. Das letzte Element des Arrays wird an die Startposition im Array verschoben, d.h. an den Index 0.\n * \n * Wenn es m\u00f6glich ist, das sortierte Array durch Ausf\u00fchren der oben genannten Operation zu erhalten, gib True zur\u00fcck, sonst gib False zur\u00fcck.\n * Wenn das gegebene Array leer ist, gib True zur\u00fcck.\n * \n * Hinweis: Die gegebene Liste hat garantiert eindeutige Elemente.\n * \n * Zum Beispiel:\n * \n * move_one_ball([3, 4, 5, 1, 2])==>True\n * Erkl\u00e4rung: Durch Ausf\u00fchren von 2 Rechtsschiebeoperationen kann die nicht abnehmende Reihenfolge f\u00fcr das gegebene Array erreicht werden.\n * move_one_ball([3, 5, 4, 1, 2])==>False\n * Erkl\u00e4rung: Es ist nicht m\u00f6glich, die nicht abnehmende Reihenfolge f\u00fcr das gegebene Array durch Ausf\u00fchren beliebiger Anzahl von Rechtsschiebeoperationen zu erhalten.\n * \n *             \n */\nfun moveOneBall(arr : List<Any>) : Boolean {\n    var swapped = true\n    while (swapped) {\n        swapped = false\n\n        for (i in 1 until arr.size) {\n            if (arr[i - 1] > arr[i]) {\n                val tmp = arr[i-1]\n                arr[i-1] = arr[i]\n                arr[i] = tmp\n\n                swapped = true\n            }\n        }\n    }\n\n    for( i in  0 until arr.size - 1) {\n        if (arr[i] > arr[i+1]) return false\n    }\n\n    return true\n}"}
{"task_id": "kotlin/50", "language": "kotlin", "completion": "/**\n *Du bist ein erfahrener Kotlin-Programmierer und hier ist deine Aufgabe.\n * In diesem Problem implementieren Sie eine Funktion, die zwei Listen von Zahlen entgegennimmt und bestimmt, ob es m\u00f6glich ist, einen Austausch von Elementen zwischen ihnen durchzuf\u00fchren, um lst1 zu einer Liste nur mit geraden Zahlen zu machen. Es gibt keine Begrenzung f\u00fcr die Anzahl der ausgetauschten Elemente zwischen lst1 und lst2. Wenn es m\u00f6glich ist, Elemente zwischen lst1 und lst2 auszutauschen, um alle Elemente von lst1 gerade zu machen, geben Sie \"YES\" zur\u00fcck. Andernfalls geben Sie \"NO\" zur\u00fcck. Zum Beispiel: exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\" exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\". Es wird angenommen, dass die Eingabelisten nicht leer sein werden.\n * \n * @param lst1 eine Liste von Zahlen\n * @param lst2 eine Liste von Zahlen\n */\nfun exchange(lst1 : List<Int>, lst2 : List<Int>) : String {\n    if (lst1.size != lst2.size) return \"NO\"\n\n    val map = mutableMapOf<Int, Int>()\n    for (i in 0 until lst1.size) {\n        map[lst1[i]] = i\n        if (!map.containsKey(lst2[i]) || map[lst2[i]] != i)\n            return \"NO\"\n    }\n\n    var count = 0\n    val result = mutableListOf<Int>()\n    for (i in lst1.size - 1 downTo 0) {\n        if (lst1[i] % 2 == 0) continue\n\n        if (!map.containsKey(lst1[i]+1)) return \"NO\"\n        val index = map[lst1[i]+1]!!\n        result.add(index, lst1[i])\n        count++\n    }\n\n    if (count > lst1.size / 2) return \"YES\"\n    else return \"NO\"\n}"}
{"task_id": "kotlin/51", "language": "kotlin", "completion": "/**\n *Du bist ein erfahrener Kotlin-Programmierer und hier ist deine Aufgabe.\n *     Wir haben zwei Zeichenketten s und c. Du musst alle Zeichen in s l\u00f6schen, die einem Zeichen in c entsprechen.\n *     Dann musst du \u00fcberpr\u00fcfen, ob die resultierende Zeichenkette ein Palindrom ist.\n *     Eine Zeichenkette ist ein Palindrom, wenn sie r\u00fcckw\u00e4rts gelesen genauso aussieht wie vorw\u00e4rts.\n *     Du solltest ein Tupel zur\u00fcckgeben, das die resultierende Zeichenkette und True/False f\u00fcr die \u00dcberpr\u00fcfung enth\u00e4lt.\n *     Beispiel\n *     F\u00fcr s = \"abcde\", c = \"ae\" sollte das Ergebnis ('bcd',False) sein.\n *     F\u00fcr s = \"abcdef\", c = \"b\" sollte das Ergebnis ('acdef',False) sein.\n *     F\u00fcr s = \"abcdedcba\", c = \"ab\" sollte das Ergebnis ('cdedc',True) sein.\n */\nfun reverseDelete(s : String, c : String) : List<Any> {\n    var copyOfS = s.toList()\n    for (i in 0..s.length-1){\n        if(c.contains(s[i])){\n            copyOfS = copyOfS.filterIndexed { index, char -> index != i }\n        }\n    }\n    return listOf(copyOfS.joinToString(\"\"), isPalindrome(copyOfS))\n}\nfun main(args: Array<String>) {\n\n    fun isPalindrome(str : String) : Boolean{\n        if (str == \"\")\n            return true\n        val first = str[0]\n        val last  = str[str.length-1]\n        if(first !=last){\n            return false\n        } else {\n            return isPalindrome(str.substring(1, str.length-1))\n        }\n    }\n}"}
{"task_id": "kotlin/52", "language": "kotlin", "completion": "package de.kramhal.proggrammiere exercises.formel_1.v003\n\nimport org.junit.jupiter.api.Test\n\ninternal class KataV3Test {\n\n  @Test\n  fun `example 1`() {\n    // given\n    val grid = listOf(\n      listOf(0,0,1,0),\n      listOf(0,1,0,0),\n      listOf(1,1,1,1)\n    )\n\n    val capacity = 1\n\n    // when\n    val result = maxFill(grid, capacity)\n\n    // then\n    assert(result == 6)\n  }\n}"}
{"task_id": "kotlin/53", "language": "kotlin", "completion": "/**\n *Du bist ein erfahrener Kotlin-Programmierer und hier ist deine Aufgabe.\n * Gegeben eine Zeichenkette s und eine nat\u00fcrliche Zahl n, wurde Ihnen die Aufgabe zugewiesen, eine Funktion zu implementieren, die eine Liste aller W\u00f6rter aus der Zeichenkette s zur\u00fcckgibt, die genau n Konsonanten enthalten, in der Reihenfolge, in der diese W\u00f6rter in der Zeichenkette s erscheinen. Wenn die Zeichenkette s leer ist, sollte die Funktion eine leere Liste zur\u00fcckgeben. Hinweis: Sie k\u00f6nnen davon ausgehen, dass die Eingabezeichenkette nur Buchstaben und Leerzeichen enth\u00e4lt. Beispiele:\n * \n * select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n * select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n * select_words(\"simple white space\", 2) ==> []\n * select_words(\"Hello world\", 4) ==> [\"world\"]\n * select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\n *\n */\nfun selectWords(s : String, n : Int) : List<String> {\n    if (s.isEmpty()) return emptyList()\n\n    val words = mutableListOf<String>()\n\n    var wordBuilder = StringBuilder()\n    for (c in s) {\n        when(c) {\n            'a', 'e', 'i', 'o', 'u' -> continue\n            else -> {\n                wordBuilder.append(c)\n                if (!s[s.length - 1].isLetter()) {\n                    words += wordBuilder.toString()\n                    wordBuilder = StringBuilder()\n                }\n            }\n        }\n    }\n\n    val filteredWords = mutableListOf<String>()\n    for (word in words) {\n        var count = 0\n        for (c in word) if (c !in 'a'..'z') count++\n\n        if(count == n)\n            filteredWords += word\n    }\n\n    return filteredWords\n}"}
{"task_id": "kotlin/54", "language": "kotlin", "completion": "/**\n *Du bist ein erfahrener Kotlin-Programmierer und hier ist deine Aufgabe.\n * * Gegeben sei ein Array arr von ganzen Zahlen und eine positive ganze Zahl k. Gib eine sortierte Liste der L\u00e4nge k zur\u00fcck, die die k gr\u00f6\u00dften Zahlen in arr enth\u00e4lt.\n * \n *     Beispiel 1:\n * \n *         Eingabe: arr = [-3, -4, 5], k = 3\n *         Ausgabe: [-4, -3, 5]\n * \n *     Beispiel 2:\n * \n *         Eingabe: arr = [4, -4, 4], k = 2\n *         Ausgabe: [4, 4]\n * \n *     Beispiel 3:\n * \n *         Eingabe: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n *         Ausgabe: [2]\n * \n *     Hinweis:\n *         1. Die L\u00e4nge des Arrays wird im Bereich von [1, 1000] liegen.\n *         2. Die Elemente im Array werden im Bereich von [-1000, 1000] liegen.\n *         3. 0 <= k <= len(arr)\n */\nfun maximum(arr : List<Int>, k : Int) : List<Any> {\n    val heap = mutableListOf<Pair<Int, Any>>()\n\n    for (i in arr.indices){\n        if (heap.size < k){\n            heap.add(Pair(arr[i], i))\n        } else if (arr[i] > heap[0].first) {\n            heap[0] = Pair(arr[i], i)\n        }\n\n        Collections.sort(heap, object : Comparator<Pair<Int, Any>> {\n            override fun compare(o1: Pair<Int, Any>, o2: Pair<Int, Any>): Int {\n                return o2.first - o1.first\n            }\n        })\n    }\n\n    return heap.map{it.second}\n}"}
{"task_id": "kotlin/55", "language": "kotlin", "completion": "/**\n *Du bist ein erfahrener Kotlin-Programmierer und hier ist deine Aufgabe.\n * * Gegeben sei ein nicht-leeres Array von ganzen Zahlen arr und eine ganze Zahl k. Gib die Summe der Elemente mit h\u00f6chstens zwei Ziffern aus den ersten k Elementen von arr zur\u00fcck.\n * \n *     Beispiel:\n * \n *         Eingabe: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n *         Ausgabe: 24 # Summe von 21 + 3\n * \n *     Einschr\u00e4nkungen:\n *         1. 1 <= len(arr) <= 100\n *         2. 1 <= k <= len(arr)\n * \n */\nfun addElements(arr : List<Int>, k : Int) : Int {\n  return arr.sortedWith(compareBy({ it % 10 }, {it}))\n      .take(k)\n      .sum()\n}"}
{"task_id": "kotlin/56", "language": "kotlin", "completion": "/**\n * Du bist ein erfahrener Kotlin-Programmierer und hier ist deine Aufgabe.\n * Sie erhalten zwei Intervalle,\n *     wobei jedes Intervall ein Paar von ganzen Zahlen ist. Zum Beispiel, Intervall = (start, end) = (1, 2).\n *     Die gegebenen Intervalle sind geschlossen, was bedeutet, dass das Intervall (start, end)\n *     sowohl start als auch end einschlie\u00dft.\n *     F\u00fcr jedes gegebene Intervall wird angenommen, dass sein Start kleiner oder gleich seinem Ende ist.\n *     Ihre Aufgabe ist es zu bestimmen, ob die L\u00e4nge des Schnitts dieser beiden\n *     Intervalle eine Primzahl ist.\n *     Zum Beispiel ist der Schnitt der Intervalle (1, 3), (2, 4) (2, 3),\n *     dessen L\u00e4nge 1 ist, was keine Primzahl ist.\n *     Wenn die L\u00e4nge des Schnitts eine Primzahl ist, geben Sie \"YES\" zur\u00fcck,\n *     andernfalls geben Sie \"NO\" zur\u00fcck.\n *     Wenn sich die beiden Intervalle nicht \u00fcberschneiden, geben Sie \"NO\" zur\u00fcck.\n * \n * \n *     [Eingabe/Ausgabe] Beispiele:\n * \n * intersection((1, 2), (2, 3)) ==> \"NO\"\n * intersection((-1, 1), (0, 4)) ==> \"NO\"\n * intersection((-3, -1), (-5, 5)) ==> \"YES\"\n *\n */\nfun intersection(interval1 : List<Int>, interval2 : List<Int>) : String {\n    var start = Math.max(interval1[0], interval2[0])\n    var end = Math.min(interval1[1], interval2[1])\n\n    return when {\n        (start <= end) -> \"YES\"\n        else -> \"NO\"\n    }\n}"}
{"task_id": "kotlin/57", "language": "kotlin", "completion": "/**\n * Du bist ein erfahrener Kotlin-Programmierer und hier ist deine Aufgabe.\n * Jeder kennt die Fibonacci-Folge, die in den letzten Jahrhunderten von Mathematikern tiefgehend untersucht wurde. Was die meisten Menschen jedoch nicht wissen, ist die Tribonacci-Folge. Die Tribonacci-Folge wird durch die Rekursion definiert: tri(1) = 3 tri(n) = 1 + n / 2, wenn n gerade ist. tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), wenn n ungerade ist. Zum Beispiel: tri(2) = 1 + (2 / 2) = 2 tri(4) = 3 tri(3) = tri(2) + tri(1) + tri(4) = 2 + 3 + 3 = 8 Sie erhalten eine nicht-negative ganze Zahl n und m\u00fcssen eine Liste der ersten n + 1 Zahlen der Tribonacci-Folge zur\u00fcckgeben. Beispiele: tri(3) = [1, 3, 2, 8]\n * \n */\nfun tri(n : Int) : List<Any> {\n    // TODO\n}"}
{"task_id": "kotlin/58", "language": "kotlin", "completion": "/**\n * Du bist ein erfahrener Kotlin-Programmierer und hier ist deine Aufgabe.\n * Gegeben eine positive ganze Zahl n, gib das Produkt der ungeraden Ziffern zur\u00fcck.\n *     Gib 0 zur\u00fcck, wenn alle Ziffern gerade sind.\n *     Zum Beispiel:\n * \n * digits(1)  == 1\n * digits(4)  == 0\n * digits(235) == 15\n */\nfun digits(n : Int) : Int {\n    var result = 1\n    for (digit in n.toString())\n        if (digit != '0' && digit.toInt() % 2 != 0)\n            result *= digit.toInt()\n    return result\n}"}
{"task_id": "kotlin/59", "language": "kotlin", "completion": "/**\n *Du bist ein erfahrener Kotlin-Programmierer und hier ist deine Aufgabe.\n * * Erstellen Sie eine Funktion, die einen String als Eingabe erh\u00e4lt, der nur eckige Klammern enth\u00e4lt. Die Funktion sollte True zur\u00fcckgeben, wenn und nur wenn es eine g\u00fcltige Teilfolge von Klammern gibt, bei der mindestens eine Klammer in der Teilfolge verschachtelt ist.\n * is_nested('[[]]')\ufffd\ufffd True\n * is_nested('[]]]]]]][[[[[]')\ufffd\ufffd False\n * is_nested('[][]')\ufffd\ufffd False\n * is_nested('[]')\ufffd\ufffd False\n * is_nested('[[][]]')\ufffd\ufffd True\n * is_nested('[[]][[')\ufffd\ufffd True\n */\nfun isNested(string : String) : Boolean {\n    var leftBrackets = 0\n    for (char in string){\n        if (char == '['){\n            leftBrackets++\n        } else if (char == ']'){\n            if (leftBrackets < 1){\n                return false\n            }\n            leftBrackets--\n        }\n    }\n    return leftBrackets == 0\n}"}
{"task_id": "kotlin/60", "language": "kotlin", "completion": "/**\n *Du bist ein erfahrener Kotlin-Programmierer und hier ist deine Aufgabe.\n * Sie erhalten eine Liste von Zahlen.\n * Sie m\u00fcssen die Summe der quadrierten Zahlen in der gegebenen Liste zur\u00fcckgeben,\n * runda jedes Element in der Liste zuerst auf die n\u00e4chste Ganzzahl (Ceiling).\n * Beispiele:\n * F\u00fcr lst = [1,2,3] sollte die Ausgabe 14 sein\n * F\u00fcr lst = [1,4,9] sollte die Ausgabe 98 sein\n * F\u00fcr lst = [1,3,5,7] sollte die Ausgabe 84 sein\n * F\u00fcr lst = [1.4,4.2,0] sollte die Ausgabe 29 sein\n * F\u00fcr lst = [-2.4,1,1] sollte die Ausgabe 6 sein\n * \n *\n */\nfun sumSquares(lst : List<Any>) : Int {\n\n    var squareSum = 0\n    for (element in lst) {\n        if (element is Double || element is Float) {\n            val ceilElement = Math.ceil(element as Number).toInt()\n            val squareElement = ceilElement * ceilElement\n            squareSum += squareElement\n        } else {\n            println(\"The list contains a non-numeric value\")\n        }\n    }\n    return squareSum\n}"}
{"task_id": "kotlin/61", "language": "kotlin", "completion": "/**\n * Du bist ein erfahrener Kotlin-Programmierer und hier ist deine Aufgabe.\n * * Erstellen Sie eine Funktion, die True zur\u00fcckgibt, wenn das letzte Zeichen eines gegebenen Strings ein alphabetisches Zeichen ist und nicht Teil eines Wortes ist, und False sonst.\n * Hinweis: \"Wort\" ist eine Gruppe von Zeichen, die durch Leerzeichen getrennt sind.\n * \n * Beispiele:\n * \n * check_if_last_char_is_a_letter(\"apple pie\")\ufffdFalse\n * check_if_last_char_is_a_letter(\"apple pi e\") \u279e True\n * check_if_last_char_is_a_letter(\"apple pi e \")\ufffdFalse\n * check_if_last_char_is_a_letter(\"\") \u279e False \n *\n */\nfun checkIfLastCharIsALetter(txt : String) : Boolean {\n    return txt.matches(\".*\\\\s?\\\\w\".toRegex()) && !txt.matches(\".*\\\\s?\\\\w\\\\s?.*\".toRegex())\n}"}
{"task_id": "kotlin/62", "language": "kotlin", "completion": "/**\n *Du bist ein erfahrener Kotlin-Programmierer und hier ist deine Aufgabe.\n * Erstellen Sie eine Funktion, die den gr\u00f6\u00dften Index eines Elements zur\u00fcckgibt, das nicht gr\u00f6\u00dfer oder gleich dem unmittelbar vorhergehenden Element ist. Wenn kein solches Element vorhanden ist, geben Sie -1 zur\u00fcck. Das gegebene Array enth\u00e4lt keine doppelten Werte.\n * \n * Beispiele:\n * \n * can_arrange([1,2,4,3,5]) = 3\n * can_arrange([1,2,3]) = -1\n *\n */\nfun canArrange(arr : List<Any>) : Int {\n    for (i in arr.indices) {\n        if (i == 0) {\n            continue\n        }\n\n        if (arr[i-1] >= arr[i]) {\n            continue\n        }\n\n        return i\n    }\n\n    return -1\n}"}
{"task_id": "kotlin/63", "language": "kotlin", "completion": "/**\n * Du bist ein erfahrener Kotlin-Programmierer und hier ist deine Aufgabe.\n * * Erstellen Sie eine Funktion, die ein Tupel (a, b) zur\u00fcckgibt, wobei 'a' die gr\u00f6\u00dfte negative Ganzzahl und 'b' die kleinste positive Ganzzahl in einer Liste ist. Wenn es keine negativen oder positiven Ganzzahlen gibt, geben Sie sie als None zur\u00fcck.\n * \n * Beispiele:\n * \n * largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n * largest_smallest_integers([]) == (None, None)\n * largest_smallest_integers([0]) == (None, None)\n *\n */\nfun largestSmallestIntegers(lst : List<Any>) : Pair<Int?, Int?> {\n    var negative : Int? = null\n    var positive : Int? = null\n\n    for(num in lst){\n        if(num is Number && num < 0){\n            if(negative == null || num > negative)\n                negative = num as Int\n        }\n\n        else if(num is Number && num > 0){\n            if(positive == null || num < positive)\n                positive = num as Int\n        }\n    }\n\n    return Pair(negative, positive)\n}"}
{"task_id": "kotlin/64", "language": "kotlin", "completion": "/**\n * Du bist ein erfahrener Kotlin-Programmierer und hier ist deine Aufgabe.\n * Das brasilianische Fakult\u00e4t ist definiert als:\n *     brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n *     wobei n > 0\n * \n *     Zum Beispiel:\n * >>> special_factorial(4)\n * 288\n\n * The function will receive an integer as input and should return the special\n * factorial of this integer.\n */\n\nfun main() {\n    println(specialFactorial(4)) // 288\n}\n\nfun specialFactorial(n : Int) : Int {\n    var fact = n\n    for (i in n-1 downTo 1)\n        fact *= i\n\n    return fact\n}"}
{"task_id": "kotlin/65", "language": "kotlin", "completion": "/**\n * Du bist ein erfahrener Kotlin-Programmierer und hier ist deine Aufgabe.\n * * Du erh\u00e4ltst einen String, der einen Satz repr\u00e4sentiert. Der Satz enth\u00e4lt einige W\u00f6rter, die durch ein Leerzeichen getrennt sind. Du musst einen String zur\u00fcckgeben, der die W\u00f6rter aus dem urspr\u00fcnglichen Satz enth\u00e4lt, deren L\u00e4ngen Primzahlen sind. Die Reihenfolge der W\u00f6rter im neuen String sollte dieselbe wie im Original sein.\n * \n *     Beispiel 1:\n *         Eingabe: sentence = \"This is a test\"\n *         Ausgabe: \"is\"\n * \n *     Beispiel 2:\n *         Eingabe: sentence = \"lets go for swimming\"\n *         Ausgabe: \"go for\"\n * \n *     Einschr\u00e4nkungen:\n *         * 1 <= len(sentence) <= 100\n *         * Der Satz enth\u00e4lt nur Buchstaben.\n */\nfun wordsInSentence(sentence : String) : String {"}
{"task_id": "kotlin/66", "language": "kotlin", "completion": "/**\n * Du bist ein erfahrener Kotlin-Programmierer und hier ist deine Aufgabe.\n * Deine Aufgabe ist es, eine Funktion zu implementieren, die den Ausdruck x * n vereinfacht. Die Funktion gibt True zur\u00fcck, wenn x * n zu einer ganzen Zahl ausgewertet wird, andernfalls False. Sowohl x als auch n sind Zeichenketten, die eine Bruchzahl darstellen und das folgende Format haben: <Z\u00e4hler>/<Nenner>, wobei sowohl Z\u00e4hler als auch Nenner positive ganze Zahlen sind.\n * \n * Du kannst davon ausgehen, dass x und n g\u00fcltige Bruchzahlen sind und keinen Nenner von Null haben.\n * simplify(\"1/5\", \"5/1\") = True\n * simplify(\"1/6\", \"2/1\") = False\n * simplify(\"7/10\", \"10/2\") = False\n *\n */\nfun simplify(x : String, n : String) : Boolean {\n    val firstFraction = x.split(\"/\")\n    val secondFraction = n.split(\"/\")\n\n    return firstFraction[0].toInt() * secondFraction[0].toInt() % firstFraction[1].toInt() == 0\n}"}
{"task_id": "kotlin/67", "language": "kotlin", "completion": "/**\n * Du bist ein erfahrener Kotlin-Programmierer und hier ist deine Aufgabe.\n * * Schreiben Sie eine Funktion, die die gegebene Liste von Ganzzahlen\n *     in aufsteigender Reihenfolge nach der Summe ihrer Ziffern sortiert.\n *     Hinweis: Wenn es mehrere Elemente mit \u00e4hnlicher Summe ihrer Ziffern gibt,\n *     ordnen Sie sie basierend auf ihrem Index in der Originalliste.\n * \n *     Zum Beispiel:\n * >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n * >>> order_by_points([]) == []\n *\n */\nfun orderByPoints(nums : List<Any>) : List<Any> {\n    val list = mutableListOf<Any>()\n\n    for (i in nums.indices) {\n        var num = nums[i]\n\n        if (num is Int)\n            list += num\n        else if (num is Long)\n            list += num\n        else if (num is Short)\n            list += num\n        else if (num is Byte)\n            list += num\n    }\n\n    return list.sortedBy { it.toString().map { c -> c - '0' }.sum() }.toList()\n}"}
{"task_id": "kotlin/68", "language": "kotlin", "completion": "/**\n * Du bist ein erfahrener Kotlin-Programmierer und hier ist deine Aufgabe.\n * Schreiben Sie eine Funktion, die ein Array von Zahlen als Eingabe erh\u00e4lt und die Anzahl der Elemente im Array zur\u00fcckgibt, die gr\u00f6\u00dfer als 10 sind und bei denen sowohl die erste als auch die letzte Ziffer der Zahl ungerade sind (1, 3, 5, 7, 9). Zum Beispiel:\n * \n * specialFilter([15, -73, 14, -15]) => 1 \n * specialFilter([33, -2, -3, 45, 21, 109]) => 2\n *\n */\nfun specialfilter(nums : List<Any>) : Int {\n    var count = 0\n    for (i in nums) {\n        if (i is Int && i > 10) {\n            val str = i.toString()\n            if ((str[0].toInt() % 2 == 1 || str[str.length - 1].toInt() % 2 == 1))\n                count++\n        }\n    }\n    return count\n}"}
{"task_id": "kotlin/69", "language": "kotlin", "completion": "/**\n *Du bist ein erfahrener Kotlin-Programmierer und hier ist deine Aufgabe.\n * * Sie erhalten eine positive ganze Zahl n. Sie m\u00fcssen ein Integer-Array a der L\u00e4nge n erstellen.\n *         F\u00fcr jedes i (1 \u2264 i \u2264 n) gilt: a[i] = i * i - i + 1.\n *         Geben Sie die Anzahl der Tripel (a[i], a[j], a[k]) von a zur\u00fcck, bei denen i < j < k gilt und a[i] + a[j] + a[k] ein Vielfaches von 3 ist.\n * \n *     Beispiel:\n *         Eingabe: n = 5\n *         Ausgabe: 1\n *         Erkl\u00e4rung:\n *         a = [1, 3, 7, 13, 21]\n *         Das einzige g\u00fcltige Tripel ist (1, 7, 13).\n * \n *\n */\nfun getMaxTriples(n : Int) : Int {\n    if (n <= 2) return 0\n\n    val a = Array<Int>(n){it*it-it+1}\n    var counter = 0\n\n    for (i in 0 until n-2) {\n        for (j in i+1 until n-1) {\n            if (a[i] + a[j] > a[n-1]) break //da ist der Rest kleiner als der erste Teil, da n>2\n            var k = j+1\n            while (k < n && a[i] + a[j] + a[k] != 3*(a[i] + a[j])) {\n                if (a[i] + a[j] + a[k] > 3*(a[i] + a[j])) break\n                k++\n            }\n\n            counter += Math.max(0, k-j-1)\n        }\n    }\n\n    return counter\n}"}
{"task_id": "kotlin/70", "language": "kotlin", "completion": "/**\n *Du bist ein erfahrener Kotlin-Programmierer und hier ist deine Aufgabe.\n * * Es gibt acht Planeten in unserem Sonnensystem: Der Sonne am n\u00e4chsten ist Merkur, dann folgen Venus, die Erde, Mars, Jupiter, Saturn, Uranus und Neptun. Schreiben Sie eine Funktion, die zwei Planetennamen als Zeichenketten planet1 und planet2 annimmt. Die Funktion sollte ein Tupel zur\u00fcckgeben, das alle Planeten enth\u00e4lt, deren Umlaufbahnen zwischen der Umlaufbahn von Planet1 und der Umlaufbahn von Planet2 liegen und nach N\u00e4he zur Sonne sortiert sind. Die Funktion sollte ein leeres Tupel zur\u00fcckgeben, wenn planet1 oder planet2 keine korrekten Planetennamen sind. Beispiele:\n * \n * bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n * bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n * bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n *\n */\nfun bf(planet1 : String, planet2 : String) : List<Any> {\n    var first = when (planet1) {\n        \"Mercury\" -> 1\n        \"Venus\" -> 2\n        \"Earth\" -> 3\n        \"Mars\" -> 4\n        \"Jupiter\" -> 5\n        \"Saturn\" -> 6\n        \"Uranus\" -> 7\n        \"Neptun\" -> 8\n        else -> return emptyList()\n    }\n\n    var second = when (planet2) {\n        \"Mercury\" -> 1\n        \"Venus\" -> 2\n        \"Earth\" -> 3\n        \"Mars\" -> 4\n        \"Jupiter\" -> 5\n        \"Saturn\" -> 6\n        \"Uranus\" -> 7\n        \"Neptun\" -> 8\n        else -> return emptyList()\n    }\n\n    var planets = listOf(\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptun\")\n    val res = mutableListOf<Any>()\n    for (i in first..second) {\n        if (planets.size > i-1)\n            res += planets[i-1]\n    }\n\n    return res\n}"}
{"task_id": "kotlin/71", "language": "kotlin", "completion": "package com.kotlin.inaction.chapter_3\n\n/**\n * Du bist ein erfahrener Kotlin-Programmierer und hier ist deine Aufgabe.\n * Ein einfaches Programm, das den Wert von x zur\u00fcckgeben sollte, wenn n eine Primzahl ist, und den Wert von y zur\u00fcckgeben sollte, wenn nicht.\n * \n * Beispiele:\n * \n * for x_or_y(7, 34, 12) == 34\n * for x_or_y(15, 8, 5) == 5\n * \n */\nfun xOrY(n : Int, x : Int, y : Int) : Int {\n    return if (n in 2..99) {\n        x\n    } else {\n        y\n    }\n}"}
{"task_id": "kotlin/72", "language": "kotlin", "completion": "/**\n * Du bist ein erfahrener Kotlin-Programmierer und hier ist deine Aufgabe.\n * * Gegeben eine Liste von Zahlen, gib die Summe der Quadrate der Zahlen in der Liste zur\u00fcck, die ungerade sind. Ignoriere Zahlen, die negativ oder keine ganzen Zahlen sind.\n * \n *     double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n *     double_the_difference([-1, -2, 0]) == 0\n *     double_the_difference([9, -2]) == 81\n *     double_the_difference([0]) == 0  \n *     \n *     Wenn die Eingangsliste leer ist, gib 0 zur\u00fcck.\n * \n *\n */\nfun doubleTheDifference(lst : List<Any>) : Int {\n    var summe = 0\n    for (x in lst) {\n        if ((x as? Int)?.rem(2) != 0 && x is Int && x > 0) {\n            summe += Math.pow((x as Int).toDouble(), 2.0) .toInt()\n        }\n    }\n    return summe\n}"}
{"task_id": "kotlin/73", "language": "kotlin", "completion": "/**\n * Du bist ein erfahrener Kotlin-Programmierer und hier ist deine Aufgabe.\n * Sie erhalten den Namen einer Klasse (einen String) und eine Liste von Erweiterungen. Die Erweiterungen sollen verwendet werden, um zus\u00e4tzliche Klassen zur KKSGE zu laden. Die St\u00e4rke der Erweiterung wird wie folgt definiert: Sei CAP die Anzahl der Gro\u00dfbuchstaben im Namen der Erweiterung und SM die Anzahl der Kleinbuchstaben im Namen der Erweiterung. Die St\u00e4rke wird durch den Bruch CAP - SM gegeben. Sie sollten die st\u00e4rkste Erweiterung finden und einen String in diesem Format zur\u00fcckgeben: ClassName.StrongestExtensionName. Wenn es zwei oder mehr Erweiterungen mit der gleichen St\u00e4rke gibt, sollten Sie die w\u00e4hlen, die zuerst in der Liste steht. Zum Beispiel, wenn Sie \"Slices\" als KKSGE und eine Liste von Erweiterungen erhalten: ['SErviNGSliCes', 'Cheese', 'StuFfed'], sollten Sie 'Slices.SErviNGSliCes' zur\u00fcckgeben, da 'SErviNGSliCes' die st\u00e4rkste Erweiterung ist (ihre St\u00e4rke ist -1). Beispiel:\n * \n * for strongestExtension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n *\n */\nfun strongestExtension(className : String, extensions : List<String>) : String {\n    var strength = 0\n    var extName = \"\"\n    extensions.forEach {\n        val cap = it.count { c -> c.isUpperCase() }\n        val sm = it.count { c -> c.isLowerCase() }\n        if (cap > sm && cap - sm > strength) {\n            strength = cap - sm\n            extName = it\n        }\n    }\n\n    return \"$className.$extName\"\n}"}
{"task_id": "kotlin/74", "language": "kotlin", "completion": "/**\n * Du bist ein erfahrener Kotlin-Programmierer und hier ist deine Aufgabe.\n * Du bekommst 2 W\u00f6rter. Du musst True zur\u00fcckgeben, wenn das zweite Wort oder eine seiner Rotationen ein Teilstring im ersten Wort ist.\n * cycpattern_check(\"abcd\",\"abd\") => False\n * cycpattern_check(\"hello\",\"ell\") => True\n * cycpattern_check(\"whassup\",\"psus\") => False\n * cycpattern_check(\"abab\",\"baa\") => True\n * cycpattern_check(\"efef\",\"eeff\") => False\n * cycpattern_check(\"himenss\",\"simen\") => True\n\n */\nfun cycpatternCheck(a : String, b : String) : Boolean {\n    var firstWord = a.substring(0,b.length)\n    for (i in 1..firstWord.length){\n        if (firstWord == b || firstWord == b.reversed())\n            return true\n        firstWord = firstWord.substring(1)+firstWord[0]\n    }\n\n    return false\n}"}
{"task_id": "kotlin/75", "language": "kotlin", "completion": "/**\n *Du bist ein erfahrener Kotlin-Programmierer und hier ist deine Aufgabe.\n * Gegeben eine positive Ganzzahl, erhalte ihre r\u00f6mische Numeral-\u00c4quivalenz als Zeichenkette und gib sie in Kleinbuchstaben zur\u00fcck.\n * Einschr\u00e4nkungen: 1 <= num <= 1000\n * \n * Beispiele:\n * >>> int_to_mini_roman(19) == 'xix'\n * >>> int_to_mini_roman(152) == 'clii'\n * >>> int_to_mini_roman(426) == 'cdxxvi'\n *\n */\nfun intToMiniRoman(number : Int) : String {\n    if (number <= 0 || number > 3999) throw IllegalArgumentException(\"Input must be between 1 and 3999\")\n\n    val values = listOf('M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I')\n    val numbers = listOf(1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1)\n\n    var result = \"\"\n    var currentNumber = number\n\n    for ((index, value) in values.withIndex()) {\n        while (currentNumber >= numbers[index]) {\n            result += value\n            currentNumber -= numbers[index]\n        }\n    }\n\n    return result\n}"}
{"task_id": "kotlin/76", "language": "kotlin", "completion": "/**\n * Du bist ein erfahrener Kotlin-Programmierer und hier ist deine Aufgabe.\n * * Gegeben sind die L\u00e4ngen der drei Seiten eines Dreiecks. Gib True zur\u00fcck, wenn die drei Seiten ein rechtwinkliges Dreieck bilden, ansonsten False. Ein rechtwinkliges Dreieck ist ein Dreieck, bei dem ein Winkel ein rechter Winkel oder 90 Grad ist. Beispiel:\n * \n * right_angle_triangle(3, 4, 5) == True\n * right_angle_triangle(1, 2, 3) == False\n *\n */\nfun rightAngleTriangle(a : Int, b : Int, c : Int) : Boolean {\n    if (a + b > c && a + c > b && b + c > a)\n        return true;\n    else\n        return false;\n}"}
{"task_id": "kotlin/77", "language": "kotlin", "completion": "/**\n *Du bist ein erfahrener Kotlin-Programmierer und hier ist deine Aufgabe.\n * Du erh\u00e4ltst einen String s.\n *     Wenn s[i] ein Buchstabe ist, kehre seine Gro\u00df- und Kleinschreibung um, oder umgekehrt,\n *     ansonsten belasse es so wie es ist.\n *     Wenn der String keine Buchstaben enth\u00e4lt, kehre den String um.\n *     Die Funktion sollte den resultierenden String zur\u00fcckgeben.\n *     Beispiele\n * \n * solve(\"1234\") = \"4321\"\n * solve(\"ab\") = \"AB\"\n * solve(\"#a@C\") = \"#A@c\"\n *\n */\nfun solve(s : String) : String {\n    var resultString: StringBuilder = StringBuilder(\"\")\n\n    for (i in s.indices){\n        val c : Char = s[i]\n\n        if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')){\n            if((c >= 'a' && c <= 'z')){\n                resultString.append(Character.toUpperCase(c))\n            }else{\n                resultString.append(Character.toLowerCase(c))\n            }\n        }else {\n            resultString.append(c)\n        }\n\n    }\n\n    return resultString.reverse().toString()\n}"}
{"task_id": "kotlin/78", "language": "kotlin", "completion": "/**\n * Du bist ein erfahrener Kotlin-Programmierer und hier ist deine Aufgabe.\n * * Gegeben eine Zeichenkette 'text', gibt seine md5-Hash-\u00c4quivalent-Zeichenkette zur\u00fcck.\n *     Wenn 'text' eine leere Zeichenkette ist, gib null zur\u00fcck.\n * >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n *\n */\nfun stringToMd5(text : String) : String? {\n    if (text.isBlank())\n        return null\n\n    val md = MessageDigest.getInstance(\"MD5\")\n    md.update(text.toByteArray(), 0, text.length)\n    val digest = md.digest()\n\n    return digest.map { \"%02x\".format(it) }.joinToString(\"\")\n}"}
{"task_id": "kotlin/79", "language": "kotlin", "completion": "/**\n * Du bist ein erfahrener Kotlin-Programmierer und hier ist deine Aufgabe.\n * \n * Gegeben sind zwei positive ganze Zahlen a und b. Gib die geraden Ziffern zwischen a und b in aufsteigender Reihenfolge zur\u00fcck.\n * \n * Zum Beispiel:\n * \n * generate_integers(2, 8) => [2, 4, 6, 8]\n * generate_integers(8, 2) => [2, 4, 6, 8]\n * generate_integers(10, 14) => []\n */\nfun generateIntegers(a : Int, b : Int) = (if (a < b) a..b else b..a).filter { it % 2 == 0 }.toList()"}
