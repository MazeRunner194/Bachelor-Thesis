{"task_id": "typescript/0", "language": "typescript", "completion": "/**\n * Du bist ein erfahrener TypeScript-Programmierer.\n * Sie erhalten eine Liste von Einzahlungs- und Abhebungsvorg\u00e4ngen auf einem Bankkonto, das mit einem Nullsaldo beginnt. Ihre Aufgabe besteht darin, festzustellen, ob zu irgendeinem Zeitpunkt das Guthaben des Kontos unter Null f\u00e4llt, und an diesem Punkt sollte die Funktion True zur\u00fcckgeben. Andernfalls sollte sie False zur\u00fcckgeben.\n * >>> below_zero([1, 2, 3])\n * False\n * >>> below_zero([1, 2, -4, 5])\n * True\n * \n */\nconst below_zero = function (operations: Array<number>) : boolean  {\n    let saldo = 0;\n    for (let i = 0; i < operations.length; i++) {\n        saldo += operations[i];\n        if(saldo < 0) return true;\n    }\n    return false;\n}"}
{"task_id": "typescript/1", "language": "typescript", "completion": "/**\n * Du bist ein erfahrener TypeScript-Programmierer.\n * F\u00fcr eine gegebene Liste von ganzen Zahlen soll ein Tupel zur\u00fcckgegeben werden, das aus der Summe und dem Produkt aller Zahlen in der Liste besteht.\n * Eine leere Summe soll gleich 0 und ein leeres Produkt gleich 1 sein.\n * >>> sum_product([])\n * (0, 1)\n * >>> sum_product([1, 2, 3, 4])\n * (10, 24)\n * \n */\nconst sum_product = function (numbers: Array<number>) : Array<number> {\n  let product = 1;\n  let sum = 0;\n\n  for(let number of numbers) {\n    product *= number;\n    sum += number;\n  }\n  \n  return [sum, product];\n}"}
{"task_id": "typescript/2", "language": "typescript", "completion": "/**\n * Du bist ein erfahrener TypeScript-Programmierer.\n * Die Eingabe sind zwei Zeichenketten a und b, die nur aus 1en und 0en bestehen.\n * F\u00fchren Sie eine bin\u00e4re XOR-Operation auf diesen Eingaben aus und geben Sie das Ergebnis ebenfalls als Zeichenkette zur\u00fcck.\n * >>> string_xor('010', '110')\n * '100'\n * \n */\nconst string_xor = function (a: string, b: string) : string  {\n    let result: number[] = [];\n\n    for(let i=0;i<a.length;i++){\n        if((Number)(a[i])^(Number)(b[i])){\n            result.push(1);\n        }else{\n            result.push(0);\n        }\n    }\n    return String.fromCharCode(...result);\n}"}
{"task_id": "typescript/3", "language": "typescript", "completion": "/**\n * Du bist ein erfahrener TypeScript-Programmierer.\n * Aus einer Liste von Zeichenketten soll die l\u00e4ngste zur\u00fcckgegeben werden. Im Falle von mehreren Zeichenketten mit gleicher L\u00e4nge soll die erste zur\u00fcckgegeben werden. Falls die Eingabeliste leer ist, soll null zur\u00fcckgegeben werden.\n * >>> longest([])\n * \n * >>> longest(['a', 'b', 'c'])\n * 'a'\n * >>> longest(['a', 'bb', 'ccc'])\n * 'ccc'\n */\nconst longest = function (strings: Array<string>) : any  {\n  if (strings.length === 0) return null;\n\n  let longestString: string = strings[0];\n  for (let i = 1; i < strings.length; i++) {\n    if (strings[i].length > longestString.length)\n      longestString = strings[i];\n  }\n  return longestString;\n}"}
{"task_id": "typescript/4", "language": "typescript", "completion": "/**\n * Du bist ein erfahrener TypeScript-Programmierer.\n * Gib den gr\u00f6\u00dften gemeinsamen Teiler von zwei ganzen Zahlen a und b zur\u00fcck.\n * >>> greatest_common_divisor(3, 5)\n * 1\n * >>> greatest_common_divisor(25, 15)\n * 5\n * \n */\nconst greatest_common_divisor = function (a: number, b: number) : number  {\n    // Schreibe deinen Code hier...\n};"}
{"task_id": "typescript/5", "language": "typescript", "completion": "/**\n * Du bist ein erfahrener TypeScript-Programmierer.\n * Die Eingabe ist ein durch Leerzeichen getrennter String von Ziffern von 'null' bis 'neun'.\n *     G\u00fcltige Optionen sind 'null', 'eins', 'zwei', 'drei', 'vier', 'f\u00fcnf', 'sechs', 'sieben', 'acht' und 'neun'.\n *     Gib den String mit den Zahlen sortiert von klein nach gro\u00df zur\u00fcck.\n * >>> sort_numbers('three one five')\n * 'one three five'\n */\nconst sort_numbers = function (numbers: string) : string  {\n    return \"TEST\";\n}"}
{"task_id": "typescript/6", "language": "typescript", "completion": "/**\n * Du bist ein erfahrener TypeScript-Programmierer.\n * Gegeben sei eine Liste von Zahlen (mit mindestens zwei Elementen). Wenden Sie eine lineare Transformation auf diese Liste an, so dass die kleinste Zahl zu 0 und die gr\u00f6\u00dfte zu 1 wird.\n * >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n * [0.0, 0.25, 0.5, 0.75, 1.0]\n */\nconst rescale_to_unit = function (numbers: Array<number>) : Array<number>  {\n    if (numbers.length < 2) return [];\n\n    const min = Math.min(...numbers);\n    const max = Math.max(...numbers);\n\n    let diff = max - min;\n\n    if (diff == 0) {\n        diff = 1;\n    }\n\n    return numbers.map((x: number) => {\n        return (x - min) / diff;\n    });\n}"}
{"task_id": "typescript/7", "language": "typescript", "completion": "/**\n * Du bist ein erfahrener TypeScript-Programmierer.\n * F\u00fcr einen gegebenen String, tausche Kleinbuchstaben in Gro\u00dfbuchstaben und Gro\u00dfbuchstaben in Kleinbuchstaben um.\n * >>> flip_case('Hello')\n * 'hELLO'\n */\nconst flip_case = function (string0: string) : string  {"}
{"task_id": "typescript/8", "language": "typescript", "completion": "/**\n * Du bist ein erfahrener TypeScript-Programmierer.\n * Gib nur positive Zahlen in der Liste zur\u00fcck.\n * >>> get_positive([-1, 2, -4, 5, 6])\n * [2, 5, 6]\n * >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n * [5, 3, 2, 3, 9, 123, 1]\n * \n */\nconst get_positive = function (l: Array<number>) : Array<number>  {\n    return l.filter(e => e > 0);\n}"}
{"task_id": "typescript/9", "language": "typescript", "completion": "/**\n * Du bist ein erfahrener TypeScript-Programmierer.\n * Gib \"true\" zur\u00fcck, wenn eine gegebene Zahl eine Primzahl ist, andernfalls gib \"false\" zur\u00fcck.\n * >>> is_prime(6)\n * False\n * >>> is_prime(101)\n * True\n * >>> is_prime(11)\n * True\n * >>> is_prime(13441)\n * True\n * >>> is_prime(61)\n * True\n * >>> is_prime(4)\n * False\n * >>> is_prime(1)\n * False\n */\nconst is_prime = function (n: number): boolean {\n    if (n <= 1)\n        return false;\n    if (n === 2)\n        return true;\n    if (n % 2 === 0)\n        return false;\n\n    let sqrtN : number = Math.sqrt(n);\n    for (let i: number = 3; i <= sqrtN; i += 2) {\n        if (n % i === 0)\n            return false;\n    }\n\n    return true;\n};"}
{"task_id": "typescript/10", "language": "typescript", "completion": "/**\n * Du bist ein erfahrener TypeScript-Programmierer.\n * Gib sortierte eindeutige Elemente in einer Liste zur\u00fcck.\n * >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n * [0, 2, 3, 5, 9, 123]\n * \n */\nconst unique = function (l: Array<number>) : Array<number>  {\n    let s = new Set(l);\n    return [...s.values()];\n}"}
{"task_id": "typescript/11", "language": "typescript", "completion": "import * as math from 'mathjs'\n\n/**\n * Du bist ein erfahrener TypeScript-Programmierer.\n * \n * prime_fib gibt die n-te Zahl zur\u00fcck, die sowohl eine Fibonacci-Zahl als auch eine Primzahl ist.\n * >>> prime_fib(1)\n * 2\n * >>> prime_fib(2)\n * 3\n * >>> prime_fib(3)\n * 5\n * >>> prime_fib(4)\n * 13\n * >>> prime_fib(5)\n * 89\n */\nconst prime_fib = function (n: number) : number {\n    return 0\n}"}
{"task_id": "typescript/12", "language": "typescript", "completion": "/**\n * Du bist ein erfahrener TypeScript-Programmierer.\n * \n * triples_sum_to_zero nimmt eine Liste von ganzen Zahlen als Eingabe.\n * Es gibt True zur\u00fcck, wenn es drei verschiedene Elemente in der Liste gibt, die zu Null addieren, andernfalls gibt es False zur\u00fcck.\n * >>> triples_sum_to_zero([1, 3, 5, 0])\n * False\n * >>> triples_sum_to_zero([1, 3, -2, 1])\n * True\n * >>> triples_sum_to_zero([1, 2, 3, 7])\n * False\n * >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n * True\n * >>> triples_sum_to_zero([1])\n * False\n * \n */\nconst triples_sum_to_zero = function (l: Array<number>) : boolean  {\n    for(let i=0; i< l.length-2; i++){\n        let sublist = [l[i],l[i+1],l[i+2]]\n        if(sublist.includes(0) || sublist.reduce((a,b)=>a+b,0) === 0){\n            return true\n        }\n    }\n    return false\n}"}
{"task_id": "typescript/13", "language": "typescript", "completion": "/**\n * Du bist ein erfahrener TypeScript-Programmierer.\n * \n * pairs_sum_to_zero nimmt eine Liste von ganzen Zahlen als Eingabe.\n * Es gibt True zur\u00fcck, wenn es zwei unterschiedliche Elemente in der Liste gibt, die sich zu Null addieren, andernfalls gibt es False zur\u00fcck.\n * >>> pairs_sum_to_zero([1, 3, 5, 0])\n * False\n * >>> pairs_sum_to_zero([1, 3, -2, 1])\n * False\n * >>> pairs_sum_to_zero([1, 2, 3, 7])\n * False\n * >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n * True\n * >>> pairs_sum_to_zero([1])\n * False\n * \n */\nconst pairs_sum_to_zero = function (l: Array<number>) : boolean  {\n    l.sort();\n    for(let i=0;i<l.length-1;i++){\n        if(l[i]!=-l[i+1]){\n            return true;\n        }\n    }\n    \n    return false;\n}\n\nconsole.log(pairs_sum_to_zero([1, 3, 5, 0]));\nconsole.log(pairs_sum_to_zero([1, 3, -2, 1]));\nconsole.log(pairs_sum_to_zero([1, 2, 3, 7]));\nconsole.log(pairs_sum_to_zero([2, 4, -5, 3, 5, 7]));\nconsole.log(pairs_sum_to_zero([1]));"}
{"task_id": "typescript/14", "language": "typescript", "completion": "/**\n * Du bist ein erfahrener TypeScript-Programmierer.\n * Die Fib4-Zahlenfolge ist eine Folge \u00e4hnlich der Fibonacci-Folge, die wie folgt definiert ist:\n *     fib4(0) -> 0\n *     fib4(1) -> 0\n *     fib4(2) -> 2\n *     fib4(3) -> 0\n *     fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n *     Bitte schreiben Sie eine Funktion, um das n-te Element der Fib4-Zahlenfolge effizient zu berechnen. Verwenden Sie keine Rekursion.\n * >>> fib4(5)\n * 4\n * >>> fib4(6)\n * 8\n * >>> fib4(7)\n * 14\n */\nconst fib4 = function (n: number) : number  {\n  const m = n % 4;\n\n  if(m == 0) return 0;\n  else if(m == 1) return 0;\n  else if(m == 2) return 2;\n  else return 0;\n};"}
{"task_id": "typescript/15", "language": "typescript", "completion": "/**\n * Du bist ein erfahrener TypeScript-Programmierer.\n * Gib den Median der Elemente in der Liste l zur\u00fcck.\n * >>> median([3, 1, 2, 4, 5])\n * 3\n * >>> median([-10, 4, 6, 1000, 10, 20])\n * 15.0\n */\nconst median = function (l: Array<number>) : number  {\n    if( l.length % 2 === 0 ) {\n        let index = Math.floor(l.length / 2);\n        return (l[index - 1] + l[index]) / 2;\n    } else {\n        let index = Math.floor(l.length / 2);\n        return l[index];\n    }\n}"}
{"task_id": "typescript/16", "language": "typescript", "completion": "/**\n * Du bist ein erfahrener TypeScript-Programmierer.\n * \n * \u00dcberpr\u00fcft, ob der gegebene String ein Palindrom ist.\n * >>> is_palindrome('')\n * True\n * >>> is_palindrome('aba')\n * True\n * >>> is_palindrome('aaaaa')\n * True\n * >>> is_palindrome('zbcd')\n * False\n * \n */\nconst is_palindrome = function (text: string) : boolean  {\n\n    return text.split('').reverse().join('') === text;\n}"}
{"task_id": "typescript/17", "language": "typescript", "completion": "/**\n * Du bist ein erfahrener TypeScript-Programmierer.\n * \n * remove_vowels ist eine Funktion, die einen String entgegennimmt und einen String ohne Vokale zur\u00fcckgibt.\n * >>> remove_vowels('')\n * ''\n * >>> remove_vowels(\"abcdef\\nghijklm\")\n * 'bcdf\\nghjklm'\n * >>> remove_vowels('abcdef')\n * 'bcdf'\n * >>> remove_vowels('aaaaa')\n * ''\n * >>> remove_vowels('aaBAA')\n * 'B'\n * >>> remove_vowels('zbcd')\n * 'zbcd'\n */\nconst remove_vowels = function (text: string) : string  {\n  // Your solution here\n  const vowels = ['a', 'e', 'i', 'o', 'u'];\n\n  let result = '';\n\n  for(let i=0; i < text.length; i++) {\n    if (!vowels.includes(text[i])) {\n      result += text[i];\n    }\n  }\n\n  return result;\n}"}
{"task_id": "typescript/18", "language": "typescript", "completion": "/**\n * Du bist ein erfahrener TypeScript-Programmierer.\n * Gib True zur\u00fcck, wenn alle Zahlen in der Liste l unterhalb des Schwellenwerts t liegen.\n * >>> below_threshold([1, 2, 4, 10], 100)\n * True\n * >>> below_threshold([1, 20, 4, 10], 5)\n * False\n * \n */\nconst below_threshold = function (l: Array<number>, t: number) : boolean  {\n    return l.every(function (e) {\n        return e < t;\n    });\n};"}
{"task_id": "typescript/19", "language": "typescript", "completion": "/**\n *Du bist ein erfahrener TypeScript-Programmierer.\n * Addiere zwei Zahlen x und y.\n * >>> add(2, 3)\n * 5\n * >>> add(5, 7)\n * 12\n */\nconst add = function (x: number, y: number): number {\n    return x + y;\n};"}
{"task_id": "typescript/20", "language": "typescript", "completion": "/**\n * Du bist ein erfahrener TypeScript-Programmierer.\n * \n * \u00dcberpr\u00fcfen Sie, ob zwei W\u00f6rter dieselben Zeichen enthalten.\n * >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n * True\n * >>> same_chars('abcd', 'dddddddabc')\n * True\n * >>> same_chars('dddddddabc', 'abcd')\n * True\n * >>> same_chars('eabcd', 'dddddddabc')\n * False\n * >>> same_chars('abcd', 'dddddddabce')\n * False\n * >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n * False\n */\nconst same_chars = function (s0: string, s1: string) : boolean  {\n    if (s0.length != s1.length) return false;\n\n    const c0 : Map<string,number> = new Map();\n    for (let i=0 ; i < s0.length ; ++i) {\n        let c = s0[i];\n        if (!c0.has(c)) {\n            c0.set(c, 1);\n        } else {\n            let v = c0.get(c);\n            c0.set(c, v+1);\n        }\n    }\n\n    for (let i=0 ; i < s1.length ; ++i) {\n        let c = s1[i];\n        if (!c0.has(c)) {\n            return false;\n        } else {\n            let v = c0.get(c);\n            if (v <= 0) {\n                return false;\n            }\n            c0.set(c, v-1);\n        }\n    }\n\n    return true;\n}"}
{"task_id": "typescript/21", "language": "typescript", "completion": "/**\n * Du bist ein erfahrener TypeScript-Programmierer.\n * Gib die n-te Fibonacci-Zahl zur\u00fcck.\n * >>> fib(10)\n * 55\n * >>> fib(1)\n * 1\n * >>> fib(8)\n * 21\n */\nconst fib = function (n: number) : number  {\n  if ( n <= 1 ) return n;\n  else return fib(n - 1) + fib(n - 2);\n}"}
{"task_id": "typescript/22", "language": "typescript", "completion": "/**\n * Du bist ein erfahrener TypeScript-Programmierer.\n * Gib sortierte eindeutige gemeinsame Elemente f\u00fcr zwei Listen zur\u00fcck.\n * >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n * [1, 5, 653]\n * >>> common([5, 3, 2, 8], [3, 2])\n * [2, 3]\n */\nconst common = function (l1: Array<number>, l2: Array<number>) : Array<number>  {\n\n    let set1 = new Set(l1);\n    let set2 = new Set(l2);\n    \n    return [...set1].filter(x => set2.has(x));\n}"}
{"task_id": "typescript/23", "language": "typescript", "completion": "/**\n * Du bist ein erfahrener TypeScript-Programmierer.\n * Gib den gr\u00f6\u00dften Primfaktor von n zur\u00fcck. Gehe davon aus, dass n > 1 und keine Primzahl ist.\n * >>> largest_prime_factor(13195)\n * 29\n * >>> largest_prime_factor(2048)\n * 2\n */\nconst largest_prime_factor = function (n: number): number {\n  let largestFactor = 0;\n\n  for (let i = 2; i < n; i++) {\n    if (n % i === 0 && isPrime(i)) {\n      largestFactor = i;\n    }\n  }\n\n  return largestFactor;\n};"}
{"task_id": "typescript/24", "language": "typescript", "completion": "/**\n * Du bist ein erfahrener TypeScript-Programmierer.\n * sum_to_n ist eine Funktion, die Zahlen von 1 bis n summiert.\n * >>> sum_to_n(30)\n * 465\n * >>> sum_to_n(100)\n * 5050\n * >>> sum_to_n(5)\n * 15\n * >>> sum_to_n(10)\n * 55\n * >>> sum_to_n(1)\n * 1\n */\nconst sum_to_n = function (n: number): number {\n  return Math.floor((n + 1) / 2) * n;\n};"}
{"task_id": "typescript/25", "language": "typescript", "completion": "/**\n * Du bist ein erfahrener TypeScript-Programmierer.\n * xs repr\u00e4sentieren die Koeffizienten eines Polynoms.\n *     xs[0] + xs[1] * x + xs[2] * x^2 + ....\n *     Gib die Ableitung dieses Polynoms in derselben Form zur\u00fcck.\n * >>> derivative([3, 1, 2, 4, 5])\n * [1, 4, 12, 20]\n * >>> derivative([1, 2, 3])\n * [2, 6]\n * \n */\nconst derivative = function (xs: number[]) : number[]  {\n    let ys:number[] = [];\n    for(let i = 0; i < xs.length-1 ;i++) {\n        ys[i] = xs[i+1]*(i+1);\n    }\n    return ys;\n}"}
{"task_id": "typescript/26", "language": "typescript", "completion": "/**\n * Du bist ein erfahrener TypeScript-Programmierer.\n * Die FibFib-Zahlenfolge ist eine Folge \u00e4hnlich der Fibonacci-Folge, die wie folgt definiert ist:\n *     fibfib(0) == 0\n *     fibfib(1) == 0\n *     fibfib(2) == 1\n *     fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n *     Bitte schreiben Sie eine Funktion, um das n-te Element der FibFib-Zahlenfolge effizient zu berechnen.\n * >>> fibfib(1)\n * 0\n * >>> fibfib(5)\n * 4\n * >>> fibfib(8)\n * 24\n */\nconst fibfib = function (n: number) : number  {\n    if (n <= 2)\n        return n - 1;\n\n    let prev_prev = 0;\n    let prev = 0;\n    let current = 1;\n    for (let i = 3; i <= n; ++i) {\n        const next = prev_prev + prev + current;\n        prev_prev = prev;\n        prev = current;\n        current = next;\n    }\n\n    return current;\n};"}
{"task_id": "typescript/27", "language": "typescript", "completion": "/**\n * Du bist ein erfahrener TypeScript-Programmierer.\n * Schreiben Sie eine Funktion vowels_count, die einen String, der ein Wort repr\u00e4sentiert, als Eingabe erh\u00e4lt und die Anzahl der Vokale im String zur\u00fcckgibt. Vokale sind in diesem Fall 'a', 'e', 'i', 'o', 'u'. Hierbei ist 'y' auch ein Vokal, aber nur wenn es am Ende des gegebenen Wortes steht.\n * \n * Beispiel:\n * >>> vowels_count(\"abcde\")\n * 2\n * >>> vowels_count(\"ACEDY\")\n * 3\n * \n */\nconst vowels_count = function (s: string) : number {\n  let count = 0;\n\n  for (let i=0; i<s.length; i++) {\n    if ((s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u') && \n        (i+1 >= s.length || !s.includes(' ', i+1))) {\n      count++;\n    }\n  }\n\n  return count;\n}"}
{"task_id": "typescript/28", "language": "typescript", "completion": "/**\n * Du bist ein erfahrener TypeScript-Programmierer.\n * \n * Sie erhalten eine nicht-leere Liste von positiven Ganzzahlen. Geben Sie die gr\u00f6\u00dfte Ganzzahl zur\u00fcck, die gr\u00f6\u00dfer als Null ist und eine H\u00e4ufigkeit hat, die gr\u00f6\u00dfer oder gleich dem Wert der Ganzzahl selbst ist. Die H\u00e4ufigkeit einer Ganzzahl ist die Anzahl der Male, die sie in der Liste vorkommt. Wenn kein solcher Wert existiert, geben Sie -1 zur\u00fcck. Beispiele:\n * \n * search([4, 1, 2, 2, 3, 1]) == 2\n * search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n * search([5, 5, 4, 4, 4]) == -1\n * \n */\nconst search = function (lst: Array<number>) : number  {\n\n    let value : number;\n    let highest : number = 0;\n\n    for (let i = 0; i < lst.length; i++) {\n        if(lst[i] > 0) {\n            if (!value || lst[i] > value) {\n                value = lst[i];\n            }\n        }\n    }\n\n    for (let j = 0; j < lst.length; j++) {\n        if(lst[j] == value) {\n            highest++;\n        }\n    }\n    \n    return (highest >= value) ? value : -1;\n}"}
{"task_id": "typescript/29", "language": "typescript", "completion": "/**\n * Du bist ein erfahrener TypeScript-Programmierer.\n * \n * Gegeben sind die L\u00e4ngen der drei Seiten eines Dreiecks. Gib die Fl\u00e4che des Dreiecks auf 2 Dezimalstellen gerundet zur\u00fcck, wenn die drei Seiten ein g\u00fcltiges Dreieck bilden. Andernfalls gib -1 zur\u00fcck. Drei Seiten bilden einNuDreieck, wenn die Summe von zwei Seiten gr\u00f6\u00dfer ist als die dritte Seite. Beispiel:\n * \n * triangle_area(3, 4, 5) == 6.00\n * triangle_area(1, 2, 10) == -1\n * \n */\nconst triangle_area = function (a: number, b: number, c: number) : number  {\n    if((a+b>c) && (b+c>a) && (c+a>b)){\n        return Math.round(Number((0.5*(a+b-c)).toFixed(2)));\n    }else{\n        return -1;\n    }\n}"}
{"task_id": "typescript/30", "language": "typescript", "completion": "/**\n * Du bist ein erfahrener TypeScript-Programmierer.\n * \n * Schreiben Sie eine Funktion, die True zur\u00fcckgibt, wenn das Objekt q fliegen wird, und False sonst. Das Objekt q wird fliegen, wenn es ausbalanciert ist (es ist eine palindromische Liste) und die Summe seiner Elemente kleiner oder gleich dem maximal m\u00f6glichen Gewicht w ist.\n * \n *     Beispiel:\n *     will_it_fly([1, 2], 5) \u279e False \n *     # 1+2 ist kleiner als das maximal m\u00f6gliche Gewicht, aber es ist unausgeglichen.\n * \n *     will_it_fly([3, 2, 3], 1) \u279e False\n *     # es ist ausbalanciert, aber 3+2+3 ist mehr als das maximal m\u00f6gliche Gewicht.\n * \n *     will_it_fly([3, 2, 3], 9) \u279e True\n *     # 3+2+3 ist kleiner als das maximal m\u00f6gliche Gewicht, und es ist ausbalanciert.\n * \n *     will_it_fly([3], 5) \u279e True\n *     # 3 ist kleiner als das maximal m\u00f6gliche Gewicht, und es ist ausbalanciert.\n */\nconst will_it_fly = function (q: Array<number>, w: number) : boolean  {\n    let summe = q.reduce((a: number, b: number) => a+b);\n    if (summe <= w && q.reverse().join() == q.join())\n        return true;\n    else\n        return false;\n}"}
{"task_id": "typescript/31", "language": "typescript", "completion": "/**\n * Du bist ein erfahrener TypeScript-Programmierer.\n * Schreiben Sie eine Funktion, die true zur\u00fcckgibt, wenn die gegebene Zahl das Produkt von 3 Primzahlen ist, und false sonst. Dabei ist bekannt, dass (a) kleiner als 100 ist. Beispiel:\n * \n * is_multiply_prime(30) == True\n * 30 = 2 * 3 * 5\n * \n */\nconst is_multiply_prime = function (a: number) : boolean  {\n    let i:number=2;\n    if (a<6){\n        return false; \n    }\n    while(i*i<=a){\n        if (a%i ==0 && isPrime(i)){\n            a = a/i;\n            continue;\n        }\n        i++;\n    }\n    if (isPrime(a)&& a!=1 ){\n        return true;\n    }\n    else{\n        return false;\n    }\n}\nfunction isPrime(n:number): boolean {\n    for (let i = 2; i < n; i++) {\n      if (n % i === 0) {\n        return false;\n      }\n    }\n    return n > 1;\n  }"}
{"task_id": "typescript/32", "language": "typescript", "completion": "/**\n * Du bist ein erfahrener TypeScript-Programmierer.\n * Sie erhalten eine Zahl in Dezimalform und Ihre Aufgabe besteht darin, sie in das Bin\u00e4rformat umzuwandeln. Die Funktion sollte einen String zur\u00fcckgeben, wobei jedes Zeichen eine Bin\u00e4rzahl darstellt. Jedes Zeichen im String wird '0' oder '1' sein.\n * \n * Es wird ein zus\u00e4tzliches Paar von Zeichen 'db' am Anfang und am Ende des Strings geben. Die zus\u00e4tzlichen Zeichen dienen zur Formatierungshilfe.\n * \n * Beispiele:\n * \n * decimal_to_binary(15)   # returns \"db1111db\"\n * decimal_to_binary(32)   # returns \"db100000db\"\n * \n */\nconst decimal_to_binary = function (decimal: number) : string  {\n\t// your solution here\n}"}
{"task_id": "typescript/33", "language": "typescript", "completion": "/**\n * Du bist ein erfahrener TypeScript-Programmierer.\n * Du erh\u00e4ltst einen String s.\n * Deine Aufgabe ist es zu \u00fcberpr\u00fcfen, ob der String gl\u00fccklich ist oder nicht.\n * Ein String ist gl\u00fccklich, wenn seine L\u00e4nge mindestens 3 betr\u00e4gt und jede Gruppe von 3 aufeinanderfolgenden Buchstaben unterschiedlich ist.\n * Zum Beispiel:\n * \n * is_happy(a) => False\n * is_happy(aa) => False\n * is_happy(abcd) => True\n * is_happy(aabb) => False\n * is_happy(adb) => True\n * is_happy(xyy) => False\n * \n */\nconst is_happy = function (s: string): boolean {\n    if(s.length < 3){\n        return false;\n    }\n    let lastThreeChars:string = s.slice(-3);\n    for(let i=0; i<=(s.length-3); i++){\n        if(s[i] === s[i+1] && s[i+1]=== s[i+2]){\n            return false;\n        }\n        lastThreeChars = s.slice(i,i+3)\n    }\n    return true;\n};"}
{"task_id": "typescript/34", "language": "typescript", "completion": "/**\n * Du bist ein erfahrener TypeScript-Programmierer.\n * Es ist die letzte Woche des Semesters und der Lehrer muss die Noten an die Sch\u00fcler verteilen. Der Lehrer hat seinen eigenen Algorithmus zur Bewertung entwickelt. Das einzige Problem ist, dass er den Code, den er zur Bewertung verwendet hat, verloren hat. Er hat Ihnen eine Liste von GPAs f\u00fcr einige Sch\u00fcler gegeben und Sie m\u00fcssen eine Funktion schreiben, die eine Liste von Buchstabennoten gem\u00e4\u00df der folgenden Tabelle ausgeben kann:\n * \n *              GPA       |    Buchstaben Note\n *               4.0                A+\n *             > 3.7                A \n *             > 3.3                A- \n *             > 3.0                B+\n *             > 2.7                B \n *             > 2.3                B-\n *             > 2.0                C+\n *             > 1.7                C\n *             > 1.3                C-\n *             > 1.0                D+ \n *             > 0.7                D \n *             > 0.0                D-\n *               0.0                E\n *     \n * \n *     Beispiel:\n * \n * grade_equation([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n * \n */\nconst numerical_letter_grade = function (grades: Array<number>) : Array<string>  {\n    const letter_grades : Array<string> = [\"A+\", \"A\", \"A-\", \"B+\", \"B\", \"B-\", \"C+\", \"C\", \"C-\", \"D+\", \"D\", \"D-\"];\n    \n    let grade_array: Array<string> = [];\n    for (let i = 0; i < grades.length; i++) {\n        if(grades[i] >= 4.0) {\n            grade_array.push(\"A+\");\n        } else if (grades[i] > 3.7 && grades[i] <= 4.0) {\n            grade_array.push(\"A\");\n        } else if (grades[i] > 3.3 && grades[i] <= 3.7) {\n            grade_array.push(\"A-\");\n        } else if (grades[i] > 3.0 && grades[i] <= 3.3) {\n            grade_array.push(\"B+\");\n        } else if (grades[i] > 2.7 && grades[i] <= 3.0) {\n            grade_array.push(\"B\");\n        } else if (grades[i] > 2.3 && grades[i] <= 2.7) {\n            grade_array.push(\"B-\");\n        } else if (grades[i] > 2.0 && grades[i] <= 2.3) {\n            grade_array.push(\"C+\");\n        } else if (grades[i] > 1.7 && grades[i] <= 2.0) {\n            grade_array.push(\"C\");\n        } else if (grades[i] > 1.3 && grades[i] <= 1.7) {\n            grade_array.push(\"C-\");\n        } else if (grades[i] > 1.0 && grades[i] <= 1.3) {\n            grade_array.push(\"D+\");\n        } else if (grades[i] > 0.7 && grades[i] <= 1.0) {\n            grade_array.push(\"D\");\n        } else if (grades[i] >= 0.0 && grades[i] <= 0.7) {\n            grade_array.push(\"D-\");\n        } else if (grades[i] == 0.0) {\n            grade_array.push(\"E\");\n        } else {\n            console.log(`Error: invalid GPA ${grades[i]}`);\n            return [];\n        }\n    }\n    return grade_array;\n}"}
{"task_id": "typescript/35", "language": "typescript", "completion": "/**\n *Du bist ein erfahrener TypeScript-Programmierer.\n * Schreiben Sie eine Funktion, die einen String entgegennimmt und True zur\u00fcckgibt, wenn die L\u00e4nge des Strings eine Primzahl ist, andernfalls False.\n *     Beispiele\n * \n * prime_length('Hello') == True\n * prime_length('abcdcba') == True\n * prime_length('kittens') == True\n * prime_length('orange') == False\n * \n */\nconst prime_length = function (string0: string) : boolean  {\n\n    if (string0.length < 2){\n        return false;\n    } else{\n        let prime = true;\n        for(let i = 2, s = Math.sqrt(string0.length); i <= s; i ++){\n            if (string0.length % i === 0){\n                prime = false;\n                break;\n            }\n        }\n        return prime;\n    }\n};"}
{"task_id": "typescript/36", "language": "typescript", "completion": "/**\n * Du bist ein erfahrener TypeScript-Programmierer.\n * Gegeben eine positive Ganzzahl N, gib die Gesamtsumme ihrer Ziffern in bin\u00e4rer Form zur\u00fcck.\n * \n *     Beispiel\n *         F\u00fcr N = 1000 ist die Summe der Ziffern 1, die Ausgabe sollte \"1\" sein.\n *         F\u00fcr N = 150 ist die Summe der Ziffern 6, die Ausgabe sollte \"110\" sein.\n *         F\u00fcr N = 147 ist die Summe der Ziffern 12, die Ausgabe sollte \"1100\" sein.\n *     \n *     Variablen:\n *         @N Ganzzahl\n *              Einschr\u00e4nkungen: 0 \u2264 N \u2264 10000.\n *     Ausgabe:\n *          eine Zeichenkette mit der bin\u00e4ren Zahl.\n * \n */\nconst solve = function (N: number) : string  {\n    const binaryArray = N.toString(2).split(''); // convert the number to a binary array\n    \n    let totalSum = 0;\n    \n    for (let i = 0; i < binaryArray.length; i++) {\n        if (binaryArray[i] === '1') {\n            totalSum++;\n        }\n    }\n\n    return totalSum.toString();\n}"}
{"task_id": "typescript/37", "language": "typescript", "completion": "/**\n * Du bist ein erfahrener TypeScript-Programmierer.\n * \n * Sie erhalten eine zweidimensionale Datenstruktur als verschachtelte Listen, die einer Matrix \u00e4hnelt, jedoch k\u00f6nnen im Gegensatz zu Matrizen unterschiedlich viele Spalten in jeder Zeile vorhanden sein. Gegeben sei eine Liste \"lst\" und eine ganze Zahl \"x\". Finden Sie die Zahlen \"x\" in der Liste und geben Sie eine Liste von Tupeln zur\u00fcck, [(x1, y1), (x2, y2) ...], wobei jedes Tupel eine Koordinate (Zeile, Spalte) darstellt, beginnend bei 0. Sortieren Sie die Koordinaten zun\u00e4chst nach Zeilen in aufsteigender Reihenfolge. Sortieren Sie auch die Koordinaten der Zeile nach Spalten in absteigender Reihenfolge.\n * \n * Beispiele:\n * \n * get_row([\n * [1,2,3,4,5,6],\n * [1,2,3,4,1,6],\n * [1,2,3,4,5,1]\n * ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n * get_row([], 1) == []\n * get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n * \n */\nconst get_row = function (lst: Array<Array<number>>, x: number) : Array<Array<number>>  {\n    let coordinateList: Array<Array<number>> = []\n\n    for (let i = 0; i < lst.length; i++) {\n        for (let j = 0; j < lst[i].length; j++) {\n            if (lst[i][j] == x) {\n                coordinateList.push([i, j])\n            }\n        }\n    }\n\n    coordinateList.sort(function(a, b) {\n        return a[0] - b[0]; // sort by row first\n    })\n    \n    for (let i = 0; i < coordinateList.length; i++) {\n        let innerArray: Array<number> = coordinateList[i]\n        innerArray.sort(function(a, b) {\n            return b - a; // sort by column in descending order\n        })\n        coordinateList[i] = innerArray\n    }\n\n    return coordinateList\n}"}
{"task_id": "typescript/38", "language": "typescript", "completion": "/**\n * Du bist ein erfahrener TypeScript-Programmierer.\n * \n * Sie erhalten eine Liste von ganzen Zahlen.\n * Schreiben Sie eine Funktion next_smallest(), die das zweitkleinste Element der Liste zur\u00fcckgibt.\n * Geben Sie null zur\u00fcck, wenn es kein solches Element gibt.\n * next_smallest([1, 2, 3, 4, 5]) == 2\n * next_smallest([5, 1, 4, 3, 2]) == 2\n * next_smallest([]) == None\n * next_smallest([1, 1]) == None\n * \n */\nconst next_smallest = function (lst: Array<number>) : any  {\n  if( lst.length < 2 ) return null;\n\n  let smallest = lst[0];\n  for(let i=1;i<lst.length;i++) {\n    if( lst[i] < smallest ) {\n      smallest = lst[i];\n    }\n  }\n  \n  let secondSmallest:any = null;\n  for(let i=0;i<lst.length;i++) {\n    if( lst[i] != smallest && (secondSmallest == null || lst[i] < secondSmallest)) {\n      secondSmallest = lst[i];\n    }\n  }\n  \n  return secondSmallest;\n}"}
{"task_id": "typescript/39", "language": "typescript", "completion": "/**\n * Du bist ein erfahrener TypeScript-Programmierer.\n * \n * Du bekommst einen String von W\u00f6rtern und deine Aufgabe ist es, die Anzahl der Langeweilen zu z\u00e4hlen. Eine Langeweile ist ein Satz, der mit dem Wort \"Ich\" beginnt. S\u00e4tze werden durch '.', '?' oder '!' begrenzt.\n * \n * Zum Beispiel:\n * >>> is_bored(\"Hello world\")\n * 0\n * >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n * 1\n * \n */\nconst is_bored = function (S: string) : number  {\n    let count:number = 0;\n    let sentences:string[] = S.split(/[.!?]+/g);\n    \n    for(let sentence of sentences){\n        if(sentence.includes(\"Ich\") == true){\n            count += 1;\n        }\n    }\n    \n    return count;\n}"}
{"task_id": "typescript/40", "language": "typescript", "completion": "const gr\u00f6\u00dfterPrimzahlwertFinde = function(lst: Array<number>) {\n    // your code here\n    return 0;\n}"}
{"task_id": "typescript/41", "language": "typescript", "completion": "/**\n * Du bist ein erfahrener TypeScript-Programmierer.\n * \n * Gegeben ein W\u00f6rterbuch, gibt True zur\u00fcck, wenn alle Schl\u00fcssel Strings in Kleinbuchstaben oder alle Schl\u00fcssel Strings in Gro\u00dfbuchstaben sind, sonst gibt es False zur\u00fcck. Die Funktion sollte False zur\u00fcckgeben, wenn das gegebene W\u00f6rterbuch leer ist. Beispiele:\n * \n * check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) should return True.\n * check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n * check_dict_case({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return False.\n * check_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n * check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n * \n */\nconst check_dict_case = function (dict: Map<any, string>) : boolean  {\n\tif(dict.size == 0)\n\t\treturn false;\n\n\tlet result = true;\n\tfor (let [key, value] of dict) {\n\t\t\n\t\tif ((typeof key === \"string\" || key instanceof String) && isNaN(+key)) {\n\t\t\tif (!/^[a-z]+$/.test(key))\n\t\t\t\tresult = false\n\t\t} else if (!isNaN(+key)) {\n\t\t\tconsole.log(\"Key is a number\");\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tconsole.log(\"Key is of an invalid type\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((typeof value === \"string\" || value instanceof String) && isNaN(+value)) {\n\t\t\tif (!/^[A-Z]+$/.test(value))\n\t\t\t\tresult = false\n\t\t} else if (!isNaN(+value)) {\n\t\t\tconsole.log(\"Value is a number\");\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tconsole.log(\"Value is of an invalid type\");\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\treturn result;\n};"}
{"task_id": "typescript/42", "language": "typescript", "completion": "import * as math from 'mathjs'\n\n/**\n * Du bist ein erfahrener TypeScript-Programmierer.\n * \n * Erstellen Sie eine Funktion, die einen Wert (String) annimmt, der eine Zahl darstellt, und gibt die n\u00e4chstgelegene Ganzzahl zur\u00fcck. Wenn die Zahl gleich weit von zwei Ganzzahlen entfernt ist, runden Sie sie weg von Null.\n * \n *     Beispiele\n * >>> closest_integer(\"10\")\n * 10\n * >>> closest_integer(\"15.3\")\n * 15\n * \n * Note:\n * Rounding away from zero means that if the given number is equidistant\n * from two integers, the one you should return is the one that is the\n * farthest from zero. For example closest_integer(\"14.5\") should\n * return 15 and closest_integer(\"-14.5\") should return -15.\n * \n */\nconst closest_integer = function (value: string) : number  {\n  const number = math.evaluate(value);\n  if (number % 1 === 0)\n    return number;\n\n  let integer_part = Math.floor(number);\n  let decimal_part = number - integer_part;\n\n  if (decimal_part >= 0.5)\n    return ++integer_part;\n  \n  return --integer_part;\n}"}
{"task_id": "typescript/43", "language": "typescript", "completion": "/**\n *Du bist ein erfahrener TypeScript-Programmierer.\n * \n * Gegeben eine positive ganze Zahl n, m\u00fcssen Sie einen Haufen von n Ebenen von Steinen machen.\n *     Die erste Ebene hat n Steine.\n *     Die Anzahl der Steine in der n\u00e4chsten Ebene ist:\n *         - die n\u00e4chste ungerade Zahl, wenn n ungerade ist.\n *         - die n\u00e4chste gerade Zahl, wenn n gerade ist.\n *     Geben Sie die Anzahl der Steine in jeder Ebene in einer Liste zur\u00fcck, wobei das Element an Index\n *     i die Anzahl der Steine in der Ebene (i+1) darstellt.\n * \n *     Beispiele:\n * >>> make_a_pile(3)\n * [3, 5, 7]\n */\nconst make_a_pile = function (n: number) : Array<number>  {\n    if(n < 1) return [];\n    \n    const result:Array<number> = new Array(n);\n\n    //first element is easy\n    result[0] = n;\n\n    let current = n;\n\n    for(let i=1;i<result.length;++i){\n        current += (current % 2 == 0 ) ? 2 : 1;\n        result[i] = current;\n    }\n\n    return result;\n}"}
{"task_id": "typescript/44", "language": "typescript", "completion": "/**\n *Du bist ein erfahrener TypeScript-Programmierer.\n * \n * Sie erhalten einen String von W\u00f6rtern, die durch Kommas oder Leerzeichen getrennt sind. Ihre Aufgabe ist es, den String in W\u00f6rter aufzuteilen und ein Array der W\u00f6rter zur\u00fcckzugeben.\n * \n * Zum Beispiel:\n * \n * words_string(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n * words_string(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n * \n */\nconst words_string = function (s: string) : Array<string>  {\n\n    let splittedString = s.split(/[,\\s]+/);\n\n    return splittedString;\n}"}
{"task_id": "typescript/45", "language": "typescript", "completion": "/**\n * Du bist ein erfahrener TypeScript-Programmierer.\n * Diese Funktion nimmt zwei positive Zahlen x und y entgegen und gibt die gr\u00f6\u00dfte gerade Zahl zur\u00fcck, die im Bereich [x, y] enthalten ist. Wenn es keine solche Zahl gibt, sollte die Funktion -1 zur\u00fcckgeben.\n * \n * Zum Beispiel:\n * \n * choose_num(12, 15) = 14\n * choose_num(13, 12) = -1\n * \n */\nconst choose_num = function (x: number, y: number): number  {\n\tlet range:number[] = [];\n\n\t// range from x to y with step of 2\n\tfor (let i=x;i<=y;i+=2)\n\t{\n\t\trange.push(i);\n\t}\n\t\n\tif (range.length > 0) {\n\t\treturn Math.max(...range);\n\t} else {\n\t\treturn -1;\n\t}\n};"}
{"task_id": "typescript/46", "language": "typescript", "completion": "/**\n * Du bist ein erfahrener TypeScript-Programmierer.\n * Sie erhalten zwei positive Ganzzahlen n und m. Ihre Aufgabe besteht darin, den Durchschnitt der Ganzzahlen von n bis m (einschlie\u00dflich n und m) zu berechnen. Runden Sie die Antwort auf die n\u00e4chste Ganzzahl und konvertieren Sie diese in bin\u00e4r. Wenn n gr\u00f6\u00dfer als m ist, geben Sie -1 zur\u00fcck. Beispiel:\n * \n * rounded_avg(1, 5) => \"0b11\"\n * rounded_avg(7, 5) => -1\n * rounded_avg(10, 20) => \"0b1111\"\n * rounded_avg(20, 33) => \"0b11010\"\n * \n */\nconst rounded_avg = function (n: number, m: number): any {\n    if (n > m) return -1;\n\n    const avg = Math.ceil((n + m) / 2);\n    return Number(avg).toString(2);\n};"}
{"task_id": "typescript/47", "language": "typescript", "completion": "/**\n * Du bist ein erfahrener TypeScript-Programmierer.\n * Implementieren Sie die Funktion f, die n als Parameter annimmt und eine Liste der Gr\u00f6\u00dfe n zur\u00fcckgibt, wobei der Wert des Element an der Stelle i das Fakult\u00e4t von i ist, wenn i gerade ist, oder die Summe der Zahlen von 1 bis i, wenn i ungerade ist. i beginnt bei 1. Die Fakult\u00e4t von i ist das Produkt der Zahlen von 1 bis i (1 * 2 * ... * i). Beispiel:\n * \n * f(5) == [1, 2, 6, 24, 15]\n * \n */\nconst f = function (n: number): Array<number> {\n\n    let arr = [];\n    for(let i = 0; i < n; i++) {\n        if (i % 2 === 0) {\n            arr.push(factorial(i + 1));\n        } else {\n            let sum = 0;\n            for(let j = 0; j <= i; j++) {\n                sum += j;\n            }\n            arr.push(sum);\n        }\n    }\n\n    return arr;\n}\n\n// calculate the factorial of a number\nconst factorial = function (num: number): number {\n    let result = 1;\n    for(let i = num; i > 0; i--) {\n        result *= i;\n    }\n    return result;\n};"}
{"task_id": "typescript/48", "language": "typescript", "completion": "/**\n * Du bist ein erfahrener TypeScript-Programmierer.\n * \n * Gegeben eine positive ganze Zahl n, gibt eine Tupel zur\u00fcck, das die Anzahl der geraden und ungeraden ganzen Palindrome enth\u00e4lt, die im Bereich (1, n) einschlie\u00dflich liegen.\n * \n *     Beispiel 1:\n * \n *         Eingabe: 3\n *         Ausgabe: [1, 2]\n *         Erkl\u00e4rung:\n *         Ganze Palindrome sind 1, 2, 3. Eines davon ist gerade und zwei davon sind ungerade.\n * \n *     Beispiel 2:\n * \n *         Eingabe: 12\n *         Ausgabe: [4, 6]\n *         Erkl\u00e4rung:\n *         Ganze Palindrome sind 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. Vier davon sind gerade und sechs davon sind ungerade.\n * \n *     Hinweis:\n *         1. 1 <= n <= 10^3\n *         2. Das zur\u00fcckgegebene Tupel enth\u00e4lt die Anzahl der geraden und ungeraden ganzen Palindrome.\n * \n * \n */\nconst even_odd_palindrome = function (n: number) : Array<number>  {"}
{"task_id": "typescript/49", "language": "typescript", "completion": "/**\n * Du bist ein erfahrener TypeScript-Programmierer.\n * Wir haben ein Array 'arr' mit N ganzen Zahlen arr[1], arr[2], ..., arr[N]. Die Zahlen im Array werden zuf\u00e4llig angeordnet sein. Deine Aufgabe besteht darin zu bestimmen, ob es m\u00f6glich ist, ein Array in nicht abnehmender Reihenfolge zu sortieren, indem du die folgende Operation auf das gegebene Array anwendest:\n * Du darfst beliebig oft eine Rechtsschiebeoperation durchf\u00fchren.\n * Eine Rechtsschiebeoperation bedeutet, dass alle Elemente des Arrays um eine Position in Richtung rechts verschoben werden. Das letzte Element des Arrays wird an die Startposition im Array verschoben, d.h. an den Index 0.\n * \n * Wenn es m\u00f6glich ist, das sortierte Array durch Ausf\u00fchren der oben genannten Operation zu erhalten, gib True zur\u00fcck, sonst gib False zur\u00fcck.\n * Wenn das gegebene Array leer ist, gib True zur\u00fcck.\n * \n * Hinweis: Die gegebene Liste hat garantiert eindeutige Elemente.\n * \n * Zum Beispiel:\n * \n * move_one_ball([3, 4, 5, 1, 2])==>True\n * Erkl\u00e4rung: Durch Ausf\u00fchren von 2 Rechtsschiebeoperationen kann die nicht abnehmende Reihenfolge f\u00fcr das gegebene Array erreicht werden.\n * move_one_ball([3, 5, 4, 1, 2])==>False\n * Erkl\u00e4rung: Es ist nicht m\u00f6glich, die nicht abnehmende Reihenfolge f\u00fcr das gegebene Array durch Ausf\u00fchren beliebiger Anzahl von Rechtsschiebeoperationen zu erhalten.\n * \n */\nconst move_one_ball = function (arr: Array<number>) : boolean  {\n    return arr.length === 0;\n};"}
{"task_id": "typescript/50", "language": "typescript", "completion": "/**\n * Du bist ein erfahrener TypeScript-Programmierer.\n * In diesem Problem implementieren Sie eine Funktion, die zwei Listen von Zahlen entgegennimmt und bestimmt, ob es m\u00f6glich ist, einen Austausch von Elementen zwischen ihnen durchzuf\u00fchren, um lst1 zu einer Liste nur mit geraden Zahlen zu machen. Es gibt keine Begrenzung f\u00fcr die Anzahl der ausgetauschten Elemente zwischen lst1 und lst2. Wenn es m\u00f6glich ist, Elemente zwischen lst1 und lst2 auszutauschen, um alle Elemente von lst1 gerade zu machen, geben Sie \"YES\" zur\u00fcck. Andernfalls geben Sie \"NO\" zur\u00fcck. Zum Beispiel: exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\" exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\". Es wird angenommen, dass die Eingabelisten nicht leer sein werden.\n * \n * Hier ist eine m\u00f6gliche L\u00f6sung:\n */\n\n const exchange = function (lst1: Array<number>, lst2: Array<number>) : string  {\n\n    // Initialisierung der Variablen\n    let lst1Copy = lst1.slice();\n    let lst2Copy = lst2.slice();\n    let exchangedElements = 0;\n\n    // Schleife, um alle Elemente von lst1 zu durchsuchen und zu testen, ob sie in lst2 vorkommen\n    for (let i = 0; i < lst1Copy.length; i++) {\n        if (lst1Copy[i] % 2 !== 0) {\n            // Schleife, um alle Elemente von lst2 zu durchsuchen und zu testen, ob sie gleich lst1Copy[i] sind\n            for (let j = 0; j < lst2Copy.length; j++) {\n                if (lst2Copy[j] === lst1Copy[i]) {\n                    // Wenn ein passendes Element in lst2 gefunden wurde, tauschen Sie es mit lst1Copy[i] aus und ziehen sie von lst2 entfernen\n                    let temp = lst2Copy[j];\n                    lst2Copy.splice(j, 1);\n                    lst1Copy.splice(i, 1);\n                    lst1Copy.push(temp);\n                    exchangedElements++;\n                    break;\n                }\n            }\n        }\n    }\n\n    // \u00dcberpr\u00fcfen Sie, ob alle Elemente von lst1 gerade sind und ob alle Elemente von lst2 gerade sind\n    for (let i = 0; i < lst1Copy.length; i++) {\n        if (lst1Copy[i] % 2 !== 0) {\n            return \"NO\";\n        }\n    }\n\n    for (let i = 0; i < lst2Copy.length; i++) {\n        if (lst2Copy[i] % 2 !== 0) {\n            return \"NO\";\n        }\n    }\n\n    // Wenn alle Elemente von lst1 und lst2 gerade sind, geben Sie \"YES\" zur\u00fcck\n    if (exchangedElements === 0) {\n        return \"YES\";\n    } else {\n        return \"YES\";\n    }\n}"}
{"task_id": "typescript/51", "language": "typescript", "completion": "/**\n * Du bist ein erfahrener TypeScript-Programmierer.\n * Aufgabe\n *     Wir haben zwei Zeichenketten s und c. Du musst alle Zeichen in s l\u00f6schen, die einem Zeichen in c entsprechen.\n *     Dann musst du \u00fcberpr\u00fcfen, ob die resultierende Zeichenkette ein Palindrom ist.\n *     Eine Zeichenkette ist ein Palindrom, wenn sie r\u00fcckw\u00e4rts gelesen genauso aussieht wie vorw\u00e4rts.\n *     Du solltest ein Tupel zur\u00fcckgeben, das die resultierende Zeichenkette und True/False f\u00fcr die \u00dcberpr\u00fcfung enth\u00e4lt.\n *     Beispiel\n *     F\u00fcr s = \"abcde\", c = \"ae\" sollte das Ergebnis ('bcd',False) sein.\n *     F\u00fcr s = \"abcdef\", c = \"b\" sollte das Ergebnis ('acdef',False) sein.\n *     F\u00fcr s = \"abcdedcba\", c = \"ab\" sollte das Ergebnis ('cdedc',True) sein.\n * \n */\nconst reverse_delete = function (s: string, c: string): Array<any> {\n    let result_string : string = \"\";\n    for (let i=0; i < s.length; i++){\n        if (!c.includes(s[i])){\n            result_string += s[i];\n        }\n    }\n    let palindrome : boolean = true;\n    for (let i = 0; i< Math.floor(result_string.length/2); i++) {\n        if (result_string[i] !== result_string[result_string.length-1-i]) {\n            palindrome = false;\n        }\n    }\n    return [result_string,palindrome];\n};"}
{"task_id": "typescript/52", "language": "typescript", "completion": "import * as math from 'mathjs'\n\n/**\n * Du bist ein erfahrener TypeScript-Programmierer.\n * \n * Sie erhalten ein rechteckiges Gitter von Brunnen. Jede Zeile repr\u00e4sentiert einen einzelnen Brunnen, und jede 1 in einer Zeile repr\u00e4sentiert eine einzelne Einheit Wasser. Jeder Brunnen hat einen entsprechenden Eimer, der verwendet werden kann, um Wasser daraus zu extrahieren, und alle Eimer haben die gleiche Kapazit\u00e4t. Ihre Aufgabe ist es, die Eimer zu verwenden, um die Brunnen zu leeren. Geben Sie die Anzahl der Male aus, die Sie die Eimer senken m\u00fcssen.\n * \n * Beispiel 1:\n *     Eingabe:\n *         grid: [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n *         Eimerkapazit\u00e4t: 1\n *     Ausgabe: 6\n * \n * Beispiel 2:\n *     Eingabe:\n *         grid: [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n *         Eimerkapazit\u00e4t: 2\n *     Ausgabe: 5\n * \n * Beispiel 3:\n *     Eingabe:\n *         grid: [[0,0,0], [0,0,0]]\n *         Eimerkapazit\u00e4t: 5\n *     Ausgabe: 0\n * \n * Einschr\u00e4nkungen:\n *     * alle Brunnen haben die gleiche L\u00e4nge\n *     * 1 <= grid.length <= 10^2\n *     * 1 <= grid[:,1].length <= 10^2\n *     * grid[i][j] -> 0 | 1\n *     * 1 <= Kapazit\u00e4t <= 10\n * \n */\nconst max_fill = function (grid: Array<Array<number>>, capacity: number) : number  {\n    let count = 0;\n\n    while(grid.length > 0) {\n        for(let i = grid.length - 1 ; i >= 0; i--) {\n            if (grid[i].includes(1)) {\n                if (grid[i].reduce((acc, x) => acc + x) <= capacity ) {\n                    count += grid[i].reduce((acc, x) => acc + x);\n                    grid.splice(i, 1);\n                } else {\n                    break;\n                }\n            }\n        }\n    }\n\n    return count;\n}"}
{"task_id": "typescript/53", "language": "typescript", "completion": "/**\n *Du bist ein erfahrener TypeScript-Programmierer.\n * Gegeben eine Zeichenkette s und eine nat\u00fcrliche Zahl n, wurde Ihnen die Aufgabe zugewiesen, eine Funktion zu implementieren, die eine Liste aller W\u00f6rter aus der Zeichenkette s zur\u00fcckgibt, die genau n Konsonanten enthalten, in der Reihenfolge, in der diese W\u00f6rter in der Zeichenkette s erscheinen. Wenn die Zeichenkette s leer ist, sollte die Funktion eine leere Liste zur\u00fcckgeben. Hinweis: Sie k\u00f6nnen davon ausgehen, dass die Eingabezeichenkette nur Buchstaben und Leerzeichen enth\u00e4lt. Beispiele:\n * \n * select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n * select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n * select_words(\"simple white space\", 2) ==> []\n * select_words(\"Hello world\", 4) ==> [\"world\"]\n * select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\n * \n */\nconst select_words = function (s: string, n: number) : Array<string>  {\n\n  if(n <= 0){\n    return [];\n  }\n  \n  const wordsList: Array<string> = s.split(\" \");\n\n  let result: Array<string> = new Array();\n\n\n  wordsList.forEach(function (element) {\n\n    if(!element.includes(' ')){\n      let consonantsCount: number = element.length - element.replace(/[aeiou]/gi,\"\").length;\n\n      if(consonantsCount == n){\n        result.push(element);\n      }\n    }else{\n      const wordsInSubList: Array<string> = element.split(\" \");\n\n      for (let i = 0; i < wordsInSubList.length; i++) {\n        let consonantsCount: number = wordsInSubList[i].length - wordsInSubList[i].replace(/[aeiou]/gi,\"\").length;\n\n        if(consonantsCount == n){\n          result.push(wordsInSubList[i]);\n        }\n      }\n    }\n    \n  });\n\n  return result;\n}"}
{"task_id": "typescript/54", "language": "typescript", "completion": "/**\n * Du bist ein erfahrener TypeScript-Programmierer.\n * \n * Gegeben sei ein Array arr von ganzen Zahlen und eine positive ganze Zahl k. Gib eine sortierte Liste der L\u00e4nge k zur\u00fcck, die die k gr\u00f6\u00dften Zahlen in arr enth\u00e4lt.\n * \n *     Beispiel 1:\n * \n *         Eingabe: arr = [-3, -4, 5], k = 3\n *         Ausgabe: [-4, -3, 5]\n * \n *     Beispiel 2:\n * \n *         Eingabe: arr = [4, -4, 4], k = 2\n *         Ausgabe: [4, 4]\n * \n *     Beispiel 3:\n * \n *         Eingabe: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n *         Ausgabe: [2]\n * \n *     Hinweis:\n *         1. Die L\u00e4nge des Arrays wird im Bereich von [1, 1000] liegen.\n *         2. Die Elemente im Array werden im Bereich von [-1000, 1000] liegen.\n *         3. 0 <= k <= len(arr)\n * \n */\nconst maximum = function (arr: Array<number>, k: number) : Array<number>  {\n  return arr.sort((a, b) => a - b).slice(-k);\n};"}
{"task_id": "typescript/55", "language": "typescript", "completion": "/**\n *Du bist ein erfahrener TypeScript-Programmierer.\n * \n * Gegeben sei ein nicht-leeres Array von ganzen Zahlen arr und eine ganze Zahl k. Gib die Summe der Elemente mit h\u00f6chstens zwei Ziffern aus den ersten k Elementen von arr zur\u00fcck.\n * \n *     Beispiel:\n * \n *         Eingabe: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n *         Ausgabe: 24 # Summe von 21 + 3\n * \n *     Einschr\u00e4nkungen:\n *         1. 1 <= len(arr) <= 100\n *         2. 1 <= k <= len(arr)\n * \n */\nconst add_elements = function (arr: Array<number>, k: number) : number  {\n    let sum: number = 0;\n    for(let i = 0;i < k && i < arr.length; i++) {\n        if(arr[i].toString().length <= 2) {\n            sum += arr[i];\n        }\n    }\n    return sum;\n}"}
{"task_id": "typescript/56", "language": "typescript", "completion": "/**\n * Du bist ein erfahrener TypeScript-Programmierer.\n * Sie erhalten zwei Intervalle,\n *     wobei jedes Intervall ein Paar von ganzen Zahlen ist. Zum Beispiel, Intervall = (start, end) = (1, 2).\n *     Die gegebenen Intervalle sind geschlossen, was bedeutet, dass das Intervall (start, end)\n *     sowohl start als auch end einschlie\u00dft.\n *     F\u00fcr jedes gegebene Intervall wird angenommen, dass sein Start kleiner oder gleich seinem Ende ist.\n *     Ihre Aufgabe ist es zu bestimmen, ob die L\u00e4nge des Schnitts dieser beiden\n *     Intervalle eine Primzahl ist.\n *     Zum Beispiel ist der Schnitt der Intervalle (1, 3), (2, 4) (2, 3),\n *     dessen L\u00e4nge 1 ist, was keine Primzahl ist.\n *     Wenn die L\u00e4nge des Schnitts eine Primzahl ist, geben Sie \"YES\" zur\u00fcck,\n *     andernfalls geben Sie \"NO\" zur\u00fcck.\n *     Wenn sich die beiden Intervalle nicht \u00fcberschneiden, geben Sie \"NO\" zur\u00fcck.\n * \n * \n *     [Eingabe/Ausgabe] Beispiele:\n * \n * intersection((1, 2), (2, 3)) ==> \"NO\"\n * intersection((-1, 1), (0, 4)) ==> \"NO\"\n * intersection((-3, -1), (-5, 5)) ==> \"YES\"\n * \n */\nconst intersection = function (interval1: Array<number>, interval2: Array<number>) : string  {\n    const start = Math.max(interval1[0], interval2[0]);\n    const end = Math.min(interval1[1], interval2[1]);\n    \n    //console.log(`start=${start}, end=${end}`);\n\n    if (end < start) {\n        return \"NO\";\n    } else {\n        let length = end - start + 1;\n\n        for (let i=2; i<length; ++i) {\n            if (length % i === 0) {\n                //console.log(`length=${length}, i=${i}`);\n                return \"NO\";\n            }\n        }\n        return \"YES\";\n    }\n}\n\nconst test1 = intersection([1, 2], [2, 3]);\nconst test2 = intersection([-1, 1], [0, 4]);\nconst test3 = intersection([-3, -1], [-5, 5]);\nconsole.log(`test1=${test1}`);\nconsole.log(`test2=${test2}`);\nconsole.log(`test3=${test3}`);"}
{"task_id": "typescript/57", "language": "typescript", "completion": "/**\n * Du bist ein erfahrener TypeScript-Programmierer.\n * Jeder kennt die Fibonacci-Folge, die in den letzten Jahrhunderten von Mathematikern tiefgehend untersucht wurde. Was die meisten Menschen jedoch nicht wissen, ist die Tribonacci-Folge. Die Tribonacci-Folge wird durch die Rekursion definiert: tri(1) = 3 tri(n) = 1 + n / 2, wenn n gerade ist. tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), wenn n ungerade ist. Zum Beispiel: tri(2) = 1 + (2 / 2) = 2 tri(4) = 3 tri(3) = tri(2) + tri(1) + tri(4) = 2 + 3 + 3 = 8 Sie erhalten eine nicht-negative ganze Zahl n und m\u00fcssen eine Liste der ersten n + 1 Zahlen der Tribonacci-Folge zur\u00fcckgeben. Beispiele: tri(3) = [1, 3, 2, 8]\n * \n */\nconst tri = function (n: number) : Array<number>  {\n  const resultArray = [];\n  if (n === 0 || n === 1) return [1];\n  \n  let counter = 1;\n  while(counter <= n) {\n    if(counter % 2 !== 0) {\n      resultArray.push(counter);\n    } else {\n      resultArray.push(Math.floor(counter / 2));\n    }\n    counter++;\n  }\n\n  return resultArray;\n}"}
{"task_id": "typescript/58", "language": "typescript", "completion": "/**\n * Du bist ein erfahrener TypeScript-Programmierer.\n * Gegeben eine positive ganze Zahl n, gib das Produkt der ungeraden Ziffern zur\u00fcck.\n *     Gib 0 zur\u00fcck, wenn alle Ziffern gerade sind.\n *     Zum Beispiel:\n * \n * digits(1)  == 1\n * digits(4)  == 0\n * digits(235) == 15\n * \n */\nconst digits = function (n: number) : number  {\n    let product = 1;\n    while (n > 0) {\n        const digit = n % 10;\n        if (digit % 2 === 1) {\n            product *= digit;\n        }\n        n = Math.floor(n / 10);\n    }\n\n    return product;\n};"}
{"task_id": "typescript/59", "language": "typescript", "completion": "/**\n * Du bist ein erfahrener TypeScript-Programmierer.\n * \n * Erstellen Sie eine Funktion, die einen String als Eingabe erh\u00e4lt, der nur eckige Klammern enth\u00e4lt. Die Funktion sollte True zur\u00fcckgeben, wenn und nur wenn es eine g\u00fcltige Teilfolge von Klammern gibt, bei der mindestens eine Klammer in der Teilfolge verschachtelt ist.\n * is_nested('[[]]')\ufffd\ufffdTrue\n * is_nested('[]]]]]]][[[[[]')\ufffd\ufffdFalse\n * is_nested('[][]')\ufffd\ufffdFalse\n * is_nested('[]')\ufffd\ufffdFalse\n * is_nested('[[][]]')\ufffd\ufffdTrue\n * is_nested('[[]][[')\ufffd\ufffdTrue\n * \n */\nconst is_nested = function (string0: string) : boolean  {\n    const stack = [];\n    let balance = 0;\n\n    for(let i=0;i<string0.length;i++) {\n        if(string0[i] == '[') {\n            stack.push(balance);\n            balance++;\n        } else if(string0[i] == ']') {\n            balance--;\n            if(stack.pop() != balance) return false;\n        }\n    }\n    return balance === 0;\n};"}
{"task_id": "typescript/60", "language": "typescript", "completion": "import * as math from 'mathjs'\n\n/**\n * Du bist ein erfahrener TypeScript-Programmierer.\n * Sie erhalten eine Liste von Zahlen.\n * Sie m\u00fcssen die Summe der quadrierten Zahlen in der gegebenen Liste zur\u00fcckgeben,\n * runden Sie jedes Element in der Liste zuerst auf die n\u00e4chste Ganzzahl (Ceiling).\n * Beispiele:\n * F\u00fcr lst = [1,2,3] sollte die Ausgabe 14 sein\n * F\u00fcr lst = [1,4,9] sollte die Ausgabe 98 sein\n * F\u00fcr lst = [1,3,5,7] sollte die Ausgabe 84 sein\n * F\u00fcr lst = [1.4,4.2,0] sollte die Ausgabe 29 sein\n * F\u00fcr lst = [-2.4,1,1] sollte die Ausgabe 6 sein\n * \n * \n * \n */\nconst sum_squares = function (lst: Array<number>) : number  {\n    let squares: Array<number> = lst.map(x => Math.pow(Math.ceil(x),2))\n    return math.sum(squares)\n}"}
{"task_id": "typescript/61", "language": "typescript", "completion": "/**\n * Du bist ein erfahrener TypeScript-Programmierer.\n * \n * Erstellen Sie eine Funktion, die True zur\u00fcckgibt, wenn das letzte Zeichen eines gegebenen Strings ein alphabetisches Zeichen ist und nicht Teil eines Wortes ist, und False sonst.\n * Hinweis: \"Wort\" ist eine Gruppe von Zeichen, die durch Leerzeichen getrennt sind.\n * \n * Beispiele:\n * \n * check_if_last_char_is_a_letter(\"apple pie\") \u279e False\n * check_if_last_char_is_a_letter(\"apple pi e\") \u279e True\n * check_if_last_char_is_a_letter(\"apple pi e \") \u279e False\n * check_if_last_char_is_a_letter(\"\") \u279e False \n * \n */\nconst check_if_last_char_is_a_letter = function (txt: string) : boolean {\n    return txt.length === 0 ? false : /[a-zA-Z]$/.test(txt);\n}"}
{"task_id": "typescript/62", "language": "typescript", "completion": "/**\n * Du bist ein erfahrener TypeScript-Programmierer.\n * Erstellen Sie eine Funktion, die den gr\u00f6\u00dften Index eines Elements zur\u00fcckgibt, das nicht gr\u00f6\u00dfer oder gleich dem unmittelbar vorhergehenden Element ist. Wenn kein solches Element vorhanden ist, geben Sie -1 zur\u00fcck. Das gegebene Array enth\u00e4lt keine doppelten Werte.\n * \n * Beispiele:\n * \n * can_arrange([1,2,4,3,5]) = 3\n * can_arrange([1,2,3]) = -1\n */\nconst can_arrange = function (arr: Array<number>) : number  {\n  for(let i=0;i<arr.length-1;i++) {\n    if(arr[i+1] <= arr[i]) return i;\n  }\n  return -1;\n}"}
{"task_id": "typescript/63", "language": "typescript", "completion": "/**\n * Du bist ein erfahrener TypeScript-Programmierer.\n * \n * Erstellen Sie eine Funktion, die ein Tupel (a, b) zur\u00fcckgibt, wobei 'a' die gr\u00f6\u00dfte negative Ganzzahl und 'b' die kleinste positive Ganzzahl in einer Liste ist. Wenn es keine negativen oder positiven Ganzzahlen gibt, geben Sie sie als None zur\u00fcck.\n * \n * Beispiele:\n * \n * largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n * largest_smallest_integers([]) == (None, None)\n * largest_smallest_integers([0]) == (None, None)\n * \n */\nconst largest_smallest_integers = function (lst: Array<number>) : Array<any> {\n    let max = lst.reduce((acc, curr) => acc < curr ? curr : acc, -Infinity);\n    let min = lst.reduce((acc, curr) => acc > curr ? curr : acc, Infinity);\n    \n    if (max === -Infinity || min === Infinity) {\n        return [null, null];\n    } else {\n        return [max, min];\n    }\n};"}
{"task_id": "typescript/64", "language": "typescript", "completion": "/**\n * Du bist ein erfahrener TypeScript-Programmierer.\n * Das brasilianische Fakult\u00e4t ist definiert als:\n *     brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n *     wobei n > 0\n * \n *     Zum Beispiel:\n * >>> special_factorial(4)\n * 288\n * \n * The function will receive an integer as input and should return the special\n * factorial of this integer.\n * \n */\nconst special_factorial = function (n: number) : number {\n    if ( n == 0 ) {\n        return 1;\n    } else {\n        let result : number = 1; \n        for(let i : number = n; i > 0; --i) {\n            result *= factorial(i);\n        }\n\n        return result;\n    }\n}\n\nconst factorial = function (n: number) : number {\n    if ( n == 0 ) {\n        return 1;\n    } else {\n        let result : number = 1; \n        for(let i : number = n; i > 0; --i) {\n            result *= i;\n        }\n\n        return result;\n    }\n}"}
{"task_id": "typescript/65", "language": "typescript", "completion": "/**\n * Du bist ein erfahrener TypeScript-Programmierer.\n * \n * Du erh\u00e4ltst einen String, der einen Satz repr\u00e4sentiert. Der Satz enth\u00e4lt einige W\u00f6rter, die durch ein Leerzeichen getrennt sind. Du musst einen String zur\u00fcckgeben, der die W\u00f6rter aus dem urspr\u00fcnglichen Satz enth\u00e4lt, deren L\u00e4ngen Primzahlen sind. Die Reihenfolge der W\u00f6rter im neuen String sollte dieselbe wie im Original sein.\n * \n *     Beispiel 1:\n *         Eingabe: sentence = \"This is a test\"\n *         Ausgabe: \"is\"\n * \n *     Beispiel 2:\n *         Eingabe: sentence = \"lets go for swimming\"\n *         Ausgabe: \"go for\"\n * \n *     Einschr\u00e4nkungen:\n *         * 1 <= len(sentence) <= 100\n *         * Der Satz enth\u00e4lt nur Buchstaben.\n * \n * \n */\nconst words_in_sentence = function (sentence: string): string {\n  const primes = [2, 3, 5, 7];\n  return sentence\n    .split(' ')\n    .filter((word) => primes.includes(word.length))\n    .join(' ');\n};"}
{"task_id": "typescript/66", "language": "typescript", "completion": "/**\n * Du bist ein erfahrener TypeScript-Programmierer.\n * Deine Aufgabe ist es, eine Funktion zu implementieren, die den Ausdruck x * n vereinfacht. Die Funktion gibt True zur\u00fcck, wenn x * n zu einer ganzen Zahl ausgewertet wird, andernfalls False. Sowohl x als auch n sind Zeichenketten, die eine Bruchzahl darstellen und das folgende Format haben: <Z\u00e4hler>/<Nenner>, wobei sowohl Z\u00e4hler als auch Nenner positive ganze Zahlen sind.\n * \n * Du kannst davon ausgehen, dass x und n g\u00fcltige Bruchzahlen sind und keinen Nenner von Null haben.\n * simplify(\"1/5\", \"5/1\") = True\n * simplify(\"1/6\", \"2/1\") = False\n * simplify(\"7/10\", \"10/2\") = False\n * \n */\nconst simplify = function (x: string, n: string) : boolean  {\n    \n    const arrX : number[] = x.split('/').map(Number);\n    const arrN : number[] = n.split('/').map(Number);\n\n    return (arrX[0]*arrN[0]) % arrX[1] === 0;\n}"}
{"task_id": "typescript/67", "language": "typescript", "completion": "/**\n * Du bist ein erfahrener TypeScript-Programmierer.\n * \n * Schreiben Sie eine Funktion, die die gegebene Liste von Ganzzahlen\n *     in aufsteigender Reihenfolge nach der Summe ihrer Ziffern sortiert.\n *     Hinweis: Wenn es mehrere Elemente mit \u00e4hnlicher Summe ihrer Ziffern gibt,\n *     ordnen Sie sie basierend auf ihrem Index in der Originalliste.\n * \n *     Zum Beispiel:\n * >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n * >>> order_by_points([]) == []\n * \n */\nconst order_by_points = function (nums: Array<number>) : Array<number>  {\n    const points = nums.map((n) => getPoints(Math.abs(n)));\n\n    return nums.sort((a, b) => {\n        if (getPoints(Math.abs(a)) < getPoints(Math.abs(b)))\n            return -1;\n\n        if (getPoints(Math.abs(a)) > getPoints(Math.abs(b)))\n            return 1;\n\n        return a - b;\n    });\n};\n\nconst getPoints = function (n: number) : number {\n    const strN = n.toString();\n\n    let points = 0;\n\n    for (let i = 0; i < strN.length; i++)\n        points += Number(strN[i]);\n\n    return points;\n};"}
{"task_id": "typescript/68", "language": "typescript", "completion": "/**\n * Du bist ein erfahrener TypeScript-Programmierer.\n * Schreiben Sie eine Funktion, die ein Array von Zahlen als Eingabe erh\u00e4lt und die Anzahl der Elemente im Array zur\u00fcckgibt, die gr\u00f6\u00dfer als 10 sind und bei denen sowohl die erste als auch die letzte Ziffer der Zahl ungerade sind (1, 3, 5, 7, 9). Zum Beispiel:\n * \n * specialFilter([15, -73, 14, -15]) => 1 \n * specialFilter([33, -2, -3, 45, 21, 109]) => 2\n */\nconst specialFilter = function (nums: Array<number>) : number {\n\n    var result = 0;\n    for(let i=0;i<nums.length;i++){\n        if(nums[i]>10){\n            if((nums[i]%10==1) || (nums[i]%10==3) || (nums[i]%10==5) || (nums[i]%10==7) || (nums[i]%10==9)){\n                result++; \n            }\n        }\n    }\n\n    return result;\n}"}
{"task_id": "typescript/69", "language": "typescript", "completion": "/**\n *Du bist ein erfahrener TypeScript-Programmierer.\n * \n * Sie erhalten eine positive ganze Zahl n. Sie m\u00fcssen ein Integer-Array a der L\u00e4nge n erstellen.\n *         F\u00fcr jedes i (1 \u2264 i \u2264 n) gilt: a[i] = i * i - i + 1.\n *         Geben Sie die Anzahl der Tripel (a[i], a[j], a[k]) von a zur\u00fcck, bei denen i < j < k gilt und a[i] + a[j] + a[k] ein Vielfaches von 3 ist.\n * \n *     Beispiel:\n *         Eingabe: n = 5\n *         Ausgabe: 1\n *         Erkl\u00e4rung:\n *         a = [1, 3, 7, 13, 21]\n *         Das einzige g\u00fcltige Tripel ist (1, 7, 13).\n * \n * \n */\nconst get_max_triples = function (n: number) : number  {\n\n    let a = new Array<number>();\n    for (let i = 1; i <= n; i++) {\n        const e = (i*i)-i+1;\n        if(e % 3 === 0){\n            a.push(e);\n        }\n    }\n    console.log('a', a);\n    let count_of_triplets: number = 0;\n\n    for (let i = 0; i < a.length; i++) {\n\n        for (let j = i+1; j < a.length; j++) {\n\n            for (let k = j+1; k < a.length; k++) {\n                console.log('i',i, 'j', j, 'k', k);\n                if(a[i] + a[j] + a[k] % 3 === 0)\n                    count_of_triplets++;\n            }\n        }\n    }\n\n    return count_of_triplets;\n};"}
{"task_id": "typescript/70", "language": "typescript", "completion": "/**\n * Du bist ein erfahrener TypeScript-Programmierer.\n * \n * Es gibt acht Planeten in unserem Sonnensystem: Der Sonne am n\u00e4chsten ist Merkur, dann folgen Venus, die Erde, Mars, Jupiter, Saturn, Uranus und Neptun. Schreiben Sie eine Funktion, die zwei Planetennamen als Zeichenketten planet1 und planet2 annimmt. Die Funktion sollte ein Tupel zur\u00fcckgeben, das alle Planeten enth\u00e4lt, deren Umlaufbahnen zwischen der Umlaufbahn von Planet1 und der Umlaufbahn von Planet2 liegen und nach N\u00e4he zur Sonne sortiert sind. Die Funktion sollte ein leeres Tupel zur\u00fcckgeben, wenn planet1 oder planet2 keine korrekten Planetennamen sind. Beispiele:\n * \n * bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n * bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n * bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n * \n */\nconst bf = function (planet1: string, planet2: string) : Array<string>  {\n  // Implementierungs-Teil"}
{"task_id": "typescript/71", "language": "typescript", "completion": "/**\n *Du bist ein erfahrener TypeScript-Programmierer.\n * Ein einfaches Programm, das den Wert von x zur\u00fcckgeben sollte, wenn n eine Primzahl ist, und den Wert von y zur\u00fcckgeben sollte, wenn nicht.\n * \n * Beispiele:\n * \n * for x_or_y(7, 34, 12) == 34\n * for x_or_y(15, 8, 5) == 5\n */\nconst isPrime = (number: number): boolean => {\n    let divisors : number[] = [];\n    \n    if (number < 2)\n        return false;\n\n    for (let i = 2; i < number + 1; i++)\n        if (number % i === 0 && number !== i)\n            divisors.push(i);\n\n    return divisors.length === 0;\n}\n\nconst x_or_y = function (n: number, x: number, y: number) : number  {\n    const isPrimeNumber = isPrime(n);\n    return isPrimeNumber ? x : y;\n};"}
{"task_id": "typescript/72", "language": "typescript", "completion": "/**\n * Du bist ein erfahrener TypeScript-Programmierer.\n * \n * Gegeben eine Liste von Zahlen, gib die Summe der Quadrate der Zahlen in der Liste zur\u00fcck, die ungerade sind. Ignoriere Zahlen, die negativ oder keine ganzen Zahlen sind.\n * \n *     double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n *     double_the_difference([-1, -2, 0]) == 0\n *     double_the_difference([9, -2]) == 81\n *     double_the_difference([0]) == 0  \n *     \n *     Wenn die Eingangsliste leer ist, gib 0 zur\u00fcck.\n * \n */\nconst double_the_difference = function (lst: Array<number>) : number  {\n    return lst.map( x => {\n        if(typeof x !== \"number\" || x < 0)\n            return 0;\n        else\n            return Math.pow(x,2);})\n    .filter(x => x % 2 == 1).reduce((a,b)=> a + b , 0 );\n}"}
{"task_id": "typescript/73", "language": "typescript", "completion": "/**\n * Du bist ein erfahrener TypeScript-Programmierer.\n * Sie erhalten den Namen einer Klasse (einen String) und eine Liste von Erweiterungen. Die Erweiterungen sollen verwendet werden, um zus\u00e4tzliche Klassen zur Kiante zu laden. Die St\u00e4rke der Erweiterung wird wie folgt definiert: Sei CAP die Anzahl der Gro\u00dfbuchstaben im Namen der Erweiterung und SM die Anzahl der Kleinbuchstaben im Namen der Erweiterung. Die St\u00e4rke wird durch den Bruch CAP - SM gegeben. Sie sollten die st\u00e4rkste Erweiterung finden und einen String in diesem Format zur\u00fcckgeben: ClassName.StrongestExtensionName. Wenn es zwei oder mehr Erweiterungen mit der gleichen St\u00e4rke gibt, sollten Sie die w\u00e4hlen, die zuerst in der Liste steht. Zum Beispiel, wenn Sie \"Slices\" als Klasse und eine Liste von Erweiterungen erhalten: ['SErviNGSliCes', 'Cheese', 'StUfFed'], sollten Sie 'Slices.SErviNGSliCes' zur\u00fcckgeben, da 'SErviNGSliCes' die st\u00e4rkste Erweiterung ist (ihre St\u00e4rke ist -1). Beispiel:\n * \n * for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n */\nconst strongestExtension = function (class_name: string, extensions: Array<string>) : string {\n  return class_name + '.' + Math.min(...extensions.map((ext) => ext.length - ext.replace(/[a-z]/gi,\"\").length));\n};"}
{"task_id": "typescript/74", "language": "typescript", "completion": "/**\n * Du bist ein erfahrener TypeScript-Programmierer.\n * Du bekommst 2 W\u00f6rter. Du musst True zur\u00fcckgeben, wenn das zweite Wort oder eine seiner Rotationen ein Teilstring im ersten Wort ist.\n * cycpattern_check(\"abcd\",\"abd\") => False\n * cycpattern_check(\"hello\",\"ell\") => True\n * cycpattern_check(\"whassup\",\"psus\") => False\n * cycpattern_check(\"abab\",\"baa\") => True\n * cycpattern_check(\"efef\",\"eeff\") => False\n * cycpattern_check(\"himenss\",\"simen\") => True\n * \n */\nconst cycpattern_check = function (a: string, b: string) : boolean  {\n    return b+b.slice(0,b.length-1).split('').reverse().join('')==a;\n};"}
{"task_id": "typescript/75", "language": "typescript", "completion": "/**\n * Du bist ein erfahrener TypeScript-Programmierer.\n * \n * Gegeben eine positive Ganzzahl, erhalte ihre r\u00f6mische Numeral-\u00c4quivalenz als Zeichenkette und gib sie in Kleinbuchstaben zur\u00fcck.\n * Einschr\u00e4nkungen: 1 <= num <= 1000\n * \n * Beispiele:\n * >>> int_to_mini_roman(19) == 'xix'\n * >>> int_to_mini_roman(152) == 'clii'\n * >>> int_to_mini_roman(426) == 'cdxxvi'\n * \n */\nconst int_to_mini_roman = function (number0: number): string  {\n    const numeralMap = [\n        [\"\", \"I\"],\n        [\"X\", \"II\"],\n        [\"XX\", \"III\"],\n        [\"XXX\", \"IV\"],\n        [\"XL\", \"V\"],\n        [\"L\", \"VI\"],\n        [\"LX\", \"VII\"],\n        [\"LXX\", \"VIII\"],\n        [\"LXXX\", \"IX\"],\n        [\"XC\", \"X\"],\n    ];\n    let number = number0;\n    let result = \"\";\n    for (let i = 0; i < numeralMap.length && number > 0; i++) {\n        const [numerals, value] = numeralMap[i];\n        if (value * Math.floor(number / value) <= number) {\n            result += numerals;\n            number -= value * Math.floor(number / value);\n        }\n    }\n    return result;\n}"}
{"task_id": "typescript/76", "language": "typescript", "completion": "/**\n * Du bist ein erfahrener TypeScript-Programmierer.\n * \n * Gegeben sind die L\u00e4ngen der drei Seiten eines Dreiecks. Gib True zur\u00fcck, wenn die drei Seiten ein rechtwinkliges Dreieck bilden, ansonsten False. Ein rechtwinkliges Dreieck ist ein Dreieck, bei dem ein Winkel ein rechter Winkel oder 90 Grad ist. Beispiel:\n * \n * right_angle_triangle(3, 4, 5) == True\n * right_angle_triangle(1, 2, 3) == False\n * \n */\nconst right_angle_triangle = function (a: number, b: number, c: number) : boolean  {\n    let max:number =0;\n    if (a >b && a>c){\n        max=a\n    }else if(b > a && b>c){\n        max=b\n    } else{\n        max=c\n    }\nreturn a+b+c ==2*max\n    \n}"}
{"task_id": "typescript/77", "language": "typescript", "completion": "/**\n * Du bist ein erfahrener TypeScript-Programmierer.\n * Du erh\u00e4ltst einen String s.\n *     Wenn s[i] ein Buchstabe ist, kehre seine Gro\u00df- und Kleinschreibung um, oder umgekehrt,\n *     ansonsten belasse es so wie es ist.\n *     Wenn der String keine Buchstaben enth\u00e4lt, kehre den String um.\n *     Die Funktion sollte den resultierenden String zur\u00fcckgeben.\n *     Beispiele\n * \n * solve(\"1234\") = \"4321\"\n * solve(\"ab\") = \"AB\"\n * solve(\"#a@C\") = \"#A@c\"\n * \n */\nconst solve = function (s: string) : string  {\n    let lowerCaseString = s.toLowerCase();\n    if (!/^[a-z]*$/i.test(lowerCaseString)) return s.split('').reverse().join('');\n\n    let result = '';\n    for (let i = 0; i < lowerCaseString.length; i++) {\n        const charCode = lowerCaseString.charCodeAt(i);\n        if ((charCode >= 97 && charCode <= 122) || (charCode >= 65 && charCode <= 90)) result += String.fromCharCode((charCode - 97 + 26) % 26 + 97);\n        else result += lowerCaseString[i];\n    }\n\n    return result;\n}\n\nconsole.log(solve('aB#C@1'));"}
{"task_id": "typescript/78", "language": "typescript", "completion": "/**\n *Du bist ein erfahrener TypeScript-Programmierer.\n * \n * Gegeben eine Zeichenkette 'text', gibt seine md5-Hash-\u00c4quivalent-Zeichenkette zur\u00fcck.\n *     Wenn 'text' eine leere Zeichenkette ist, gib null zur\u00fcck.\n * >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n * \n */\nconst string_to_md5 = function (text: string) : string  {\n\n    return \"hash\"\n}"}
{"task_id": "typescript/79", "language": "typescript", "completion": "/**\n * Du bist ein erfahrener TypeScript-Programmierer.\n * \n * Gegeben sind zwei positive ganze Zahlen a und b. Gib die geraden Ziffern zwischen a und b in aufsteigender Reihenfolge zur\u00fcck.\n * \n * Zum Beispiel:\n * \n * generate_integers(2, 8) => [2, 4, 6, 8]\n * generate_integers(8, 2) => [2, 4, 6, 8]\n * generate_integers(10, 14) => []\n * \n */\nconst generate_integers = function (a: number, b: number) : Array<number>  {\n    let result:Array<number> = [];\n\n    for (let i = a; i <=b ; i++) {\n        if(i%2 === 0){\n            result.push(i);\n        }\n    }\n\n    return result\n}"}
