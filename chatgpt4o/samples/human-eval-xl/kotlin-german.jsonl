{"task_id": "kotlin/0", "language": "kotlin", "completion": "fun belowZero(operations: List<Int>): Boolean {\n    var balance = 0\n\n    for (operation in operations) {\n        balance += operation\n        if (balance < 0) {\n            return true\n        }\n    }\n\n    return false\n}\n\n// Testf\u00e4lle\nfun main() {\n    println(belowZero(listOf(1, 2, 3))) // Erwartet: False\n    println(belowZero(listOf(1, 2, -4, 5))) // Erwartet: True\n}"}
{"task_id": "kotlin/1", "language": "kotlin", "completion": "fun sumProduct(numbers: List<Int>): Pair<Int, Int> {\n    if (numbers.isEmpty()) {\n        return Pair(0, 1)\n    }\n\n    var sum = 0\n    var product = 1\n\n    for (number in numbers) {\n        sum += number\n        product *= number\n    }\n\n    return Pair(sum, product)\n}\n\nfun main() {\n    println(sumProduct(emptyList())) // Ausgabe: (0, 1)\n    println(sumProduct(listOf(1, 2, 3, 4))) // Ausgabe: (10, 24)\n}"}
{"task_id": "kotlin/2", "language": "kotlin", "completion": "fun stringXor(a: String, b: String): String {\n    // \u00dcberpr\u00fcfen, ob beide Zeichenketten die gleiche L\u00e4nge haben\n    if (a.length != b.length) {\n        throw IllegalArgumentException(\"Both strings must have the same length\")\n    }\n\n    // Erzeugen eines StringBuilders, um das Ergebnis zu speichern\n    val result = StringBuilder()\n\n    // Durchlaufen der Zeichenketten und XOR-Operation durchf\u00fchren\n    for (i in a.indices) {\n        val charA = a[i]\n        val charB = b[i]\n        \n        // XOR-Operation: 1 wenn charA != charB, sonst 0\n        val xorChar = if (charA != charB) '1' else '0'\n\n        // F\u00fcgen Sie das Ergebniszeichen zum StringBuilder hinzu\n        result.append(xorChar)\n    }\n\n    // Konvertieren und R\u00fcckgabe des Ergebnisses als Zeichenkette\n    return result.toString()\n}\n\nfun main() {\n    // Beispielaufruf der Funktion\n    println(stringXor(\"010\", \"110\"))  // Ausgabe: \"100\"\n}"}
{"task_id": "kotlin/3", "language": "kotlin", "completion": "fun longest(strings: List<String>): String? {\n    if (strings.isEmpty()) {\n        return null\n    }\n\n    return strings.maxByOrNull { it.length }\n}\n\n// Beispielaufrufe:\nfun main() {\n    println(longest(listOf())) // null\n    println(longest(listOf(\"a\", \"b\", \"c\"))) // 'a'\n    println(longest(listOf(\"a\", \"bb\", \"ccc\"))) // 'ccc'\n}"}
{"task_id": "kotlin/4", "language": "kotlin", "completion": "fun greatestCommonDivisor(a: Int, b: Int): Int {\n    var num1 = a\n    var num2 = b\n    \n    while (num2 != 0) {\n        val temp = num2\n        num2 = num1 % num2\n        num1 = temp\n    }\n    \n    return num1\n}\n\nfun main() {\n    println(greatestCommonDivisor(3, 5))  // Ausgabe: 1\n    println(greatestCommonDivisor(25, 15)) // Ausgabe: 5\n}"}
{"task_id": "kotlin/5", "language": "kotlin", "completion": "fun sortNumbers(numbers: String): String {\n    // Map von deutschen W\u00f6rtern zu Ganzzahlen\n    val numberMap = mapOf(\n        \"null\" to 0,\n        \"eins\" to 1,\n        \"zwei\" to 2,\n        \"drei\" to 3,\n        \"vier\" to 4,\n        \"f\u00fcnf\" to 5,\n        \"sechs\" to 6,\n        \"sieben\" to 7,\n        \"acht\" to 8,\n        \"neun\" to 9\n    )\n\n    // Zerlegen des Eingabestrings in eine Liste von W\u00f6rtern\n    val words = numbers.split(\" \")\n\n    // Sortieren der W\u00f6rter anhand ihrer Ganzzahlwerte\n    val sortedWords = words.sortedBy { numberMap[it] }\n\n    // Zusammenf\u00fcgen der sortierten W\u00f6rter zu einem String\n    return sortedWords.joinToString(\" \")\n}\n\n// Test der Funktion\nfun main() {\n    println(sortNumbers(\"drei eins f\u00fcnf\"))  // Ausgabe: \"eins drei f\u00fcnf\"\n}"}
{"task_id": "kotlin/6", "language": "kotlin", "completion": "fun rescaleToUnit(numbers: List<Double>): List<Double> {\n    if (numbers.size < 2) {\n        throw IllegalArgumentException(\"Die Liste muss mindestens zwei Elemente enthalten.\")\n    }\n\n    val min = numbers.minOrNull() ?: throw IllegalArgumentException(\"Die Liste darf keine null Elemente enthalten.\")\n    val max = numbers.maxOrNull() ?: throw IllegalArgumentException(\"Die Liste darf keine null Elemente enthalten.\")\n\n    if (min == max) {\n        throw IllegalArgumentException(\"Alle Elemente der Liste sind gleich.\")\n    }\n\n    return numbers.map { (it - min) / (max - min) }\n}\n\n// Beispielaufruf\nfun main() {\n    val numbers = listOf(1.0, 2.0, 3.0, 4.0, 5.0)\n    val rescaledNumbers = rescaleToUnit(numbers)\n    println(rescaledNumbers)  // Ausgabe: [0.0, 0.25, 0.5, 0.75, 1.0]\n}"}
{"task_id": "kotlin/7", "language": "kotlin", "completion": "fun flipCase(string: String): String {\n    return string.map { \n        when {\n            it.isLowerCase() -> it.toUpperCase()\n            it.isUpperCase() -> it.toLowerCase()\n            else -> it\n        }\n    }.joinToString(\"\")\n}\n\n// Testf\u00e4lle\nfun main() {\n    println(flipCase(\"Hello\")) // 'hELLO'\n    println(flipCase(\"WORLD\")) // 'world'\n    println(flipCase(\"kOtLiN\")) // 'KoTlIn'\n    println(flipCase(\"123ABCabc\")) // '123abcABC'\n}"}
{"task_id": "kotlin/8", "language": "kotlin", "completion": "fun getPositive(l: List<Any>): List<Any> {\n    return l.filter { it is Int && it > 0 }\n}\n\n// Testf\u00e4lle\nfun main() {\n    println(getPositive(listOf(-1, 2, -4, 5, 6))) // [2, 5, 6]\n    println(getPositive(listOf(5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10))) // [5, 3, 2, 3, 9, 123, 1]\n}"}
{"task_id": "kotlin/9", "language": "kotlin", "completion": "fun isPrime(n: Int): Boolean {\n    if (n <= 1) return false\n    if (n == 2) return true\n    if (n % 2 == 0) return false\n    for (i in 3..Math.sqrt(n.toDouble()).toInt() step 2) {\n        if (n % i == 0) return false\n    }\n    return true\n}\n\n// Testf\u00e4lle\nfun main() {\n    println(isPrime(6))    // False\n    println(isPrime(101))  // True\n    println(isPrime(11))   // True\n    println(isPrime(13441))// True\n    println(isPrime(61))   // True\n    println(isPrime(4))    // False\n    println(isPrime(1))    // False\n}"}
{"task_id": "kotlin/10", "language": "kotlin", "completion": "fun unique(l: List<Int>): List<Int> {\n    // Entferne Duplikate durch Konvertierung der Liste in ein Set\n    val uniqueElements = l.toSet()\n    // Sortiere die eindeutigen Elemente und konvertiere sie zur\u00fcck in eine Liste\n    return uniqueElements.sorted()\n}\n\n// Testen der Funktion\nfun main() {\n    val result = unique(listOf(5, 3, 5, 2, 3, 3, 9, 0, 123))\n    println(result)  // Ausgabe: [0, 2, 3, 5, 9, 123]\n}"}
{"task_id": "kotlin/11", "language": "kotlin", "completion": "fun isPrime(num: Int): Boolean {\n    if (num <= 1) return false\n    if (num == 2) return true\n    if (num % 2 == 0) return false\n    for (i in 3..Math.sqrt(num.toDouble()).toInt() step 2) {\n        if (num % i == 0) return false\n    }\n    return true\n}\n\nfun generateFibonacci(): Sequence<Int> = sequence {\n    var a = 0\n    var b = 1\n    while (true) {\n        yield(b)\n        val temp = a + b\n        a = b\n        b = temp\n    }\n}\n\nfun primeFib(n: Int): Int {\n    val fibonacciSequence = generateFibonacci()\n    return fibonacciSequence.filter { isPrime(it) }.take(n).last()\n}\n\n// Test the function\nfun main() {\n    println(primeFib(1)) // Output: 2\n    println(primeFib(2)) // Output: 3\n    println(primeFib(3)) // Output: 5\n    println(primeFib(4)) // Output: 13\n    println(primeFib(5)) // Output: 89\n}"}
{"task_id": "kotlin/12", "language": "kotlin", "completion": "fun triplesSumToZero(l: List<Int>): Boolean {\n    // Wenn die Liste weniger als 3 Elemente hat, kann es keine drei Elemente geben, die zu Null addieren\n    if (l.size < 3) return false\n\n    // Sortiere die Liste\n    val sortedList = l.sorted()\n\n    // Durchlaufen jedes Element in der Liste\n    for (i in 0 until sortedList.size - 2) {\n        // Zwei Zeiger setzen\n        var left = i + 1\n        var right = sortedList.size - 1\n\n        while (left < right) {\n            val sum = sortedList[i] + sortedList[left] + sortedList[right]\n            when {\n                sum == 0 -> return true\n                sum < 0 -> left++\n                else -> right--\n            }\n        }\n    }\n\n    // Wenn keine drei Elemente gefunden wurden, die zu Null addieren\n    return false\n}\n\n// Testf\u00e4lle\nfun main() {\n    println(triplesSumToZero(listOf(1, 3, 5, 0))) // False\n    println(triplesSumToZero(listOf(1, 3, -2, 1))) // True\n    println(triplesSumToZero(listOf(1, 2, 3, 7))) // False\n    println(triplesSumToZero(listOf(2, 4, -5, 3, 9, 7))) // True\n    println(triplesSumToZero(listOf(1))) // False\n}"}
{"task_id": "kotlin/13", "language": "kotlin", "completion": "fun pairsSumToZero(l: List<Int>): Boolean {\n    val seenNumbers = mutableSetOf<Int>()\n\n    for (number in l) {\n        if (-number in seenNumbers) {\n            return true\n        }\n        seenNumbers.add(number)\n    }\n    return false\n}\n\n// Test cases\nfun main() {\n    println(pairsSumToZero(listOf(1, 3, 5, 0))) // False\n    println(pairsSumToZero(listOf(1, 3, -2, 1))) // False\n    println(pairsSumToZero(listOf(1, 2, 3, 7))) // False\n    println(pairsSumToZero(listOf(2, 4, -5, 3, 5, 7))) // True\n    println(pairsSumToZero(listOf(1))) // False\n}"}
{"task_id": "kotlin/14", "language": "kotlin", "completion": "fun fib4(n: Int): Int {\n    // Basisf\u00e4lle\n    if (n == 0) return 0\n    if (n == 1) return 0\n    if (n == 2) return 2\n    if (n == 3) return 0\n\n    // Array zur Speicherung der letzten vier Werte\n    val fib4Values = IntArray(4)\n    fib4Values[2] = 2  // fib4(2)\n    fib4Values[3] = 0  // fib4(3)\n\n    var currentIndex = 3\n\n    for (i in 4..n) {\n        val nextValue = fib4Values[0] + fib4Values[1] + fib4Values[2] + fib4Values[3]\n        // Verschieben der Werte um einen Platz\n        fib4Values[0] = fib4Values[1]\n        fib4Values[1] = fib4Values[2]\n        fib4Values[2] = fib4Values[3]\n        fib4Values[3] = nextValue\n        currentIndex = (currentIndex + 1) % 4\n    }\n\n    return fib4Values[currentIndex]\n}\n\n// Testf\u00e4lle\nfun main() {\n    println(fib4(5))  // Ausgabe: 4\n    println(fib4(6))  // Ausgabe: 8\n    println(fib4(7))  // Ausgabe: 14\n}"}
{"task_id": "kotlin/15", "language": "kotlin", "completion": "fun median(l: List<Int>): Any {\n    if (l.isEmpty()) throw IllegalArgumentException(\"List must not be empty\")\n\n    val sortedList = l.sorted()\n    val size = sortedList.size\n\n    return if (size % 2 == 1) {\n        // Ungerade Anzahl von Elementen - Mittleres Element zur\u00fcckgeben\n        sortedList[size / 2]\n    } else {\n        // Gerade Anzahl von Elementen - Durchschnitt der beiden mittleren Elemente zur\u00fcckgeben\n        val middle1 = sortedList[size / 2 - 1]\n        val middle2 = sortedList[size / 2]\n        (middle1 + middle2) / 2.0\n    }\n}\n\n// Beispielaufrufe:\nfun main() {\n    println(median(listOf(3, 1, 2, 4, 5))) // Ausgabe: 3\n    println(median(listOf(-10, 4, 6, 1000, 10, 20))) // Ausgabe: 15.0\n}"}
{"task_id": "kotlin/16", "language": "kotlin", "completion": "fun isPalindrome(text: String): Boolean {\n    // Ein leerer String oder ein String mit einem Zeichen ist immer ein Palindrom\n    if (text.length <= 1) return true\n    \n    // Konvertiere den String in Kleinbuchstaben, um Gro\u00df-/Kleinschreibung zu ignorieren\n    val sanitizedText = text.toLowerCase()\n\n    // \u00dcberpr\u00fcfe, ob der String vorw\u00e4rts und r\u00fcckw\u00e4rts gleich ist\n    return sanitizedText == sanitizedText.reversed()\n}\n\n// Beispielhafte Verwendung und Testf\u00e4lle\nfun main() {\n    println(isPalindrome(\"\"))        // True\n    println(isPalindrome(\"aba\"))     // True\n    println(isPalindrome(\"aaaaa\"))   // True\n    println(isPalindrome(\"zbcd\"))    // False\n}"}
{"task_id": "kotlin/17", "language": "kotlin", "completion": "fun removeVowels(text: String): String {\n    // Definiere eine Menge von Vokalen, die sowohl Kleinbuchstaben als auch Gro\u00dfbuchstaben umfasst\n    val vowels = setOf('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U')\n    \n    // Filtere die Zeichen des Eingabestrings, indem nur die Zeichen behalten werden, die keine Vokale sind\n    return text.filter { it !in vowels }\n}\n\n// Testf\u00e4lle\nfun main() {\n    println(removeVowels(\"\")) // ''\n    println(removeVowels(\"abcdef\\nghijklm\")) // 'bcdf\\nghjklm'\n    println(removeVowels(\"abcdef\")) // 'bcdf'\n    println(removeVowels(\"aaaaa\")) // ''\n    println(removeVowels(\"aaBAA\")) // 'B'\n    println(removeVowels(\"zbcd\")) // 'zbcd'\n}"}
{"task_id": "kotlin/18", "language": "kotlin", "completion": "fun belowThreshold(l: List<Int>, t: Int): Boolean {\n    return l.all { it < t }\n}"}
{"task_id": "kotlin/19", "language": "kotlin", "completion": "fun add(x: Int, y: Int): Int {\n    return x + y\n}\n\n// Beispielaufrufe\nfun main() {\n    println(add(2, 3))  // Ausgabe: 5\n    println(add(5, 7))  // Ausgabe: 12\n}"}
{"task_id": "kotlin/20", "language": "kotlin", "completion": "fun sameChars(s0: String, s1: String): Boolean {\n    // Wandelt die Zeichen der beiden Strings in Sets um und vergleicht die Sets\n    return s0.toSet() == s1.toSet()\n}\n\n// Testf\u00e4lle\nfun main() {\n    println(sameChars(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\"))  // True\n    println(sameChars(\"abcd\", \"dddddddabc\"))             // True\n    println(sameChars(\"dddddddabc\", \"abcd\"))             // True\n    println(sameChars(\"eabcd\", \"dddddddabc\"))            // False\n    println(sameChars(\"abcd\", \"dddddddabce\"))            // False\n    println(sameChars(\"eabcdzzzz\", \"dddzzzzzzzddddabc\")) // False\n}"}
{"task_id": "kotlin/21", "language": "kotlin", "completion": "fun fib(n: Int): Int {\n    if (n <= 0) {\n        throw IllegalArgumentException(\"n must be a positive integer\")\n    }\n    \n    if (n == 1 || n == 2) {\n        return 1\n    }\n\n    var a = 1\n    var b = 1\n    var c = 0\n\n    for (i in 3..n) {\n        c = a + b\n        a = b\n        b = c\n    }\n\n    return c\n}\n\nfun main() {\n    println(fib(10))  // 55\n    println(fib(1))   // 1\n    println(fib(8))   // 21\n}"}
{"task_id": "kotlin/22", "language": "kotlin", "completion": "fun common(l1: List<Int>, l2: List<Int>): List<Int> {\n    // Schritt 1: Konvertiere beide Listen in Sets, um doppelte Elemente zu entfernen\n    val set1 = l1.toSet()\n    val set2 = l2.toSet()\n\n    // Schritt 2: Finde die gemeinsamen Elemente (Schnittmenge) der beiden Sets\n    val commonElements = set1.intersect(set2)\n\n    // Schritt 3: Sortiere das Ergebnis\n    val sortedCommonElements = commonElements.sorted()\n\n    // Schritt 4: Konvertiere das Ergebnis wieder in eine Liste und gib es zur\u00fcck\n    return sortedCommonElements\n}\n\nfun main() {\n    // Beispielaufrufe\n    println(common(listOf(1, 4, 3, 34, 653, 2, 5), listOf(5, 7, 1, 5, 9, 653, 121))) // [1, 5, 653]\n    println(common(listOf(5, 3, 2, 8), listOf(3, 2))) // [2, 3]\n}"}
{"task_id": "kotlin/23", "language": "kotlin", "completion": "fun largestPrimeFactor(n: Int): Int {\n    var num = n\n    var largestFactor = 1\n    \n    // Entferne alle Faktoren von 2\n    while (num % 2 == 0) {\n        largestFactor = 2\n        num /= 2\n    }\n    \n    // \u00dcberpr\u00fcfe ungerade Zahlen von 3 an\n    var factor = 3\n    while (factor * factor <= num) {\n        while (num % factor == 0) {\n            largestFactor = factor\n            num /= factor\n        }\n        factor += 2\n    }\n    \n    // Wenn num immer noch gr\u00f6\u00dfer als 2 ist, dann ist es ein Primfaktor\n    if (num > 2) {\n        largestFactor = num\n    }\n    \n    return largestFactor\n}\n\n// Beispiele\nfun main() {\n    println(largestPrimeFactor(13195)) // 29\n    println(largestPrimeFactor(2048))  // 2\n}"}
{"task_id": "kotlin/24", "language": "kotlin", "completion": "fun sumToN(n: Int): Int {\n    return n * (n + 1) / 2\n}\n\n// Beispiele zur Veranschaulichung\nfun main() {\n    println(sumToN(30))  // 465\n    println(sumToN(100)) // 5050\n    println(sumToN(5))   // 15\n    println(sumToN(10))  // 55\n    println(sumToN(1))   // 1\n}"}
{"task_id": "kotlin/25", "language": "kotlin", "completion": "fun derivative(xs: List<Int>): List<Int> {\n    if (xs.isEmpty()) return emptyList()\n    \n    val result = mutableListOf<Int>()\n    for (i in 1 until xs.size) {\n        result.add(xs[i] * i)\n    }\n    return result\n}\n\nfun main() {\n    // Test cases\n    println(derivative(listOf(3, 1, 2, 4, 5)))  // [1, 4, 12, 20]\n    println(derivative(listOf(1, 2, 3)))        // [2, 6]\n    println(derivative(listOf(0, 0, 0)))        // [0, 0]\n    println(derivative(listOf(5)))              // []\n    println(derivative(listOf()))               // []\n}"}
{"task_id": "kotlin/26", "language": "kotlin", "completion": "fun fibfib(n: Int): Int {\n    if (n == 0 || n == 1) return 0\n    if (n == 2) return 1\n\n    val dp = IntArray(n + 1)\n    dp[0] = 0\n    dp[1] = 0\n    dp[2] = 1\n\n    for (i in 3..n) {\n        dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3]\n    }\n\n    return dp[n]\n}\n\n// Testf\u00e4lle\nfun main() {\n    println(fibfib(1))  // Ausgabe: 0\n    println(fibfib(5))  // Ausgabe: 4\n    println(fibfib(8))  // Ausgabe: 24\n}"}
{"task_id": "kotlin/27", "language": "kotlin", "completion": "fun vowelsCount(s: String): Int {\n    // Definiere die Menge der Vokale\n    val vowels = setOf('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U')\n    \n    // Initialisiere den Z\u00e4hler f\u00fcr die Vokale\n    var count = 0\n    \n    // Iteriere \u00fcber jeden Buchstaben im String\n    for (i in s.indices) {\n        val char = s[i]\n        // Pr\u00fcfe, ob der Buchstabe ein Vokal ist\n        if (char in vowels) {\n            count++\n        } else if (char == 'y' || char == 'Y') {\n            // Pr\u00fcfe, ob der Buchstabe 'y' am Ende des Strings steht\n            if (i == s.length - 1) {\n                count++\n            }\n        }\n    }\n    \n    // Gib die Gesamtanzahl der Vokale zur\u00fcck\n    return count\n}\n\n// Testf\u00e4lle\nfun main() {\n    println(vowelsCount(\"abcde\")) // 2\n    println(vowelsCount(\"ACEDY\")) // 3\n    println(vowelsCount(\"Yummy\")) // 2\n    println(vowelsCount(\"sky\")) // 1\n    println(vowelsCount(\"rhythm\")) // 0\n}"}
{"task_id": "kotlin/28", "language": "kotlin", "completion": "fun search(lst: List<Int>): Int {\n    // Schritt 1: Z\u00e4hlen der H\u00e4ufigkeit jeder Ganzzahl in der Liste\n    val frequencyMap = lst.groupingBy { it }.eachCount()\n    \n    // Schritt 2: Filtern der Ganzzahlen, deren H\u00e4ufigkeit gr\u00f6\u00dfer oder gleich ihrem Wert ist\n    val validNumbers = frequencyMap.filter { (number, count) -> count >= number }.keys\n    \n    // Schritt 3: Finden der gr\u00f6\u00dften g\u00fcltigen Ganzzahl oder -1 zur\u00fcckgeben\n    return validNumbers.maxOrNull() ?: -1\n}\n\n// Beispielaufrufe zur \u00dcberpr\u00fcfung\nfun main() {\n    println(search(listOf(4, 1, 2, 2, 3, 1)))  // Ausgabe: 2\n    println(search(listOf(1, 2, 2, 3, 3, 3, 4, 4, 4)))  // Ausgabe: 3\n    println(search(listOf(5, 5, 4, 4, 4)))  // Ausgabe: -1\n}"}
{"task_id": "kotlin/29", "language": "kotlin", "completion": "import kotlin.math.sqrt\n\nfun triangleArea(a: Int, b: Int, c: Int): Any {\n    // Pr\u00fcfe, ob die drei Seiten ein g\u00fcltiges Dreieck bilden\n    if (a + b <= c || a + c <= b || b + c <= a) {\n        return -1\n    }\n\n    // Berechne den Halb-Umfang\n    val s = (a + b + c) / 2.0\n\n    // Berechne die Fl\u00e4che mit der Heron'schen Formel\n    val area = sqrt(s * (s - a) * (s - b) * (s - c))\n\n    // Runde die Fl\u00e4che auf 2 Dezimalstellen und gib sie zur\u00fcck\n    return String.format(\"%.2f\", area).toDouble()\n}\n\n// Testf\u00e4lle\nfun main() {\n    println(triangleArea(3, 4, 5)) // Ausgabe: 6.00\n    println(triangleArea(1, 2, 10)) // Ausgabe: -1\n}"}
{"task_id": "kotlin/30", "language": "kotlin", "completion": "fun willItFly(q: List<Int>, w: Int): Boolean {\n    // \u00dcberpr\u00fcft, ob die Liste q palindromisch ist\n    val isPalindrome = q == q.reversed()\n\n    // Berechnet die Summe der Elemente in der Liste q\n    val sumOfElements = q.sum()\n\n    // \u00dcberpr\u00fcft beide Bedingungen\n    return isPalindrome && sumOfElements <= w\n}\n\n// Testf\u00e4lle\nfun main() {\n    println(willItFly(listOf(1, 2), 5)) // \u279e False\n    println(willItFly(listOf(3, 2, 3), 1)) // \u279e False\n    println(willItFly(listOf(3, 2, 3), 9)) // \u279e True\n    println(willItFly(listOf(3), 5)) // \u279e True\n}"}
{"task_id": "kotlin/31", "language": "kotlin", "completion": "fun isMultiplyPrime(a: Int): Boolean {\n    // Liste der Primzahlen kleiner als 100\n    val primes = listOf(2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97)\n\n    // Durchlaufe alle Kombinationen von drei verschiedenen Primzahlen\n    for (i in primes.indices) {\n        for (j in i + 1 until primes.size) {\n            for (k in j + 1 until primes.size) {\n                if (primes[i] * primes[j] * primes[k] == a) {\n                    return true\n                }\n            }\n        }\n    }\n\n    return false\n}\n\n// Testbeispiele\nfun main() {\n    println(isMultiplyPrime(30))  // True, weil 30 = 2 * 3 * 5\n    println(isMultiplyPrime(60))  // False, weil 60 = 2 * 2 * 3 * 5 (4 Primzahlen)\n    println(isMultiplyPrime(105)) // True, weil 105 = 3 * 5 * 7\n    println(isMultiplyPrime(1))   // False, weil 1 kein Produkt von 3 Primzahlen ist\n}"}
{"task_id": "kotlin/32", "language": "kotlin", "completion": "fun decimalToBinary(decimal: Int): String {\n    // Umwandlung der Dezimalzahl in eine Bin\u00e4rzahl\n    val binaryString = decimal.toString(2)\n    // Hinzuf\u00fcgen der Formatierungszeichen 'db' am Anfang und Ende\n    return \"db$binaryStringdb\"\n}\n\n// Testf\u00e4lle\nfun main() {\n    println(decimalToBinary(15))   // sollte \"db1111db\" ausgeben\n    println(decimalToBinary(32))   // sollte \"db100000db\" ausgeben\n    println(decimalToBinary(5))    // sollte \"db101db\" ausgeben\n}"}
{"task_id": "kotlin/33", "language": "kotlin", "completion": "fun isHappy(s: String): Boolean {\n    // \u00dcberpr\u00fcfen, ob die L\u00e4nge des Strings kleiner als 3 ist\n    if (s.length < 3) return false\n\n    // Iterieren \u00fcber den String, um jede Gruppe von 3 aufeinanderfolgenden Buchstaben zu \u00fcberpr\u00fcfen\n    for (i in 0 until s.length - 2) {\n        // Extrahiere eine Gruppe von 3 aufeinanderfolgenden Buchstaben\n        val group = s.substring(i, i + 3)\n        \n        // \u00dcberpr\u00fcfen, ob alle Buchstaben in der Gruppe gleich sind\n        if (group[0] == group[1] && group[1] == group[2]) {\n            return false\n        }\n    }\n    \n    // Wenn keine Gruppe von 3 gleichen Buchstaben gefunden wurde, ist der String gl\u00fccklich\n    return true\n}\n\n// Testf\u00e4lle\nfun main() {\n    println(isHappy(\"a\")) // False\n    println(isHappy(\"aa\")) // False\n    println(isHappy(\"abcd\")) // True\n    println(isHappy(\"aabb\")) // False\n    println(isHappy(\"adb\")) // True\n    println(isHappy(\"xyy\")) // False\n}"}
{"task_id": "kotlin/34", "language": "kotlin", "completion": "fun numericalLetterGrade(grades: List<Double>): List<String> {\n    return grades.map { gpa ->\n        when {\n            gpa == 4.0 -> \"A+\"\n            gpa > 3.7 -> \"A\"\n            gpa > 3.3 -> \"A-\"\n            gpa > 3.0 -> \"B+\"\n            gpa > 2.7 -> \"B\"\n            gpa > 2.3 -> \"B-\"\n            gpa > 2.0 -> \"C+\"\n            gpa > 1.7 -> \"C\"\n            gpa > 1.3 -> \"C-\"\n            gpa > 1.0 -> \"D+\"\n            gpa > 0.7 -> \"D\"\n            gpa > 0.0 -> \"D-\"\n            else -> \"E\"\n        }\n    }\n}\n\n// Beispielaufruf der Funktion\nfun main() {\n    val gpas = listOf(4.0, 3.0, 1.7, 2.0, 3.5)\n    val letterGrades = numericalLetterGrade(gpas)\n    println(letterGrades)  // Ausgabe: [A+, B, C-, C, A-]\n}"}
{"task_id": "kotlin/35", "language": "kotlin", "completion": "fun isPrime(n: Int): Boolean {\n    if (n < 2) return false\n    for (i in 2..Math.sqrt(n.toDouble()).toInt()) {\n        if (n % i == 0) return false\n    }\n    return true\n}\n\nfun primeLength(string: String): Boolean {\n    return isPrime(string.length)\n}\n\n// Testbeispiele\nfun main() {\n    println(primeLength(\"Hello\"))    // True, L\u00e4nge ist 5\n    println(primeLength(\"abcdcba\"))  // True, L\u00e4nge ist 7\n    println(primeLength(\"kittens\"))  // True, L\u00e4nge ist 7\n    println(primeLength(\"orange\"))   // False, L\u00e4nge ist 6\n}"}
{"task_id": "kotlin/36", "language": "kotlin", "completion": "fun solve(n: Int): String {\n    // Schritt 1: Zerlegen der Zahl in ihre Ziffern und Berechnung der Summe\n    val sumOfDigits = n.toString().map { it.toString().toInt() }.sum()\n    \n    // Schritt 2: Umwandlung der Summe in eine bin\u00e4re Zeichenkette\n    return Integer.toBinaryString(sumOfDigits)\n}\n\n// Testf\u00e4lle\nfun main() {\n    println(solve(1000))  // Ausgabe: \"1\"\n    println(solve(150))   // Ausgabe: \"110\"\n    println(solve(147))   // Ausgabe: \"1100\"\n}"}
{"task_id": "kotlin/37", "language": "kotlin", "completion": "fun getRow(lst: List<List<Int>>, x: Int): List<Pair<Int, Int>> {\n    val coordinates = mutableListOf<Pair<Int, Int>>()\n\n    // Durchlaufen der verschachtelten Listen\n    for (i in lst.indices) {\n        for (j in lst[i].indices) {\n            if (lst[i][j] == x) {\n                coordinates.add(Pair(i, j))\n            }\n        }\n    }\n\n    // Sortieren der Koordinaten: nach Zeilen in aufsteigender Reihenfolge und innerhalb der Zeile nach Spalten in absteigender Reihenfolge\n    return coordinates.sortedWith(compareBy({ it.first }, { -it.second }))\n}\n\n// Testf\u00e4lle\nfun main() {\n    println(getRow(listOf(\n        listOf(1, 2, 3, 4, 5, 6),\n        listOf(1, 2, 3, 4, 1, 6),\n        listOf(1, 2, 3, 4, 5, 1)\n    ), 1))  // Output: [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n\n    println(getRow(emptyList(), 1))  // Output: []\n\n    println(getRow(listOf(\n        emptyList(),\n        listOf(1),\n        listOf(1, 2, 3)\n    ), 3))  // Output: [(2, 2)]\n}"}
{"task_id": "kotlin/38", "language": "kotlin", "completion": "fun nextSmallest(lst: List<Int>): Int? {\n    // \u00dcberpr\u00fcfen, ob die Liste weniger als 2 verschiedene Elemente hat\n    if (lst.distinct().size < 2) return null\n\n    // Sortieren der Liste und R\u00fcckgabe des zweitkleinsten Elements\n    val sortedList = lst.sorted()\n    return sortedList[1]\n}\n\n// Testf\u00e4lle\nfun main() {\n    println(nextSmallest(listOf(1, 2, 3, 4, 5)))  // Output: 2\n    println(nextSmallest(listOf(5, 1, 4, 3, 2)))  // Output: 2\n    println(nextSmallest(emptyList()))            // Output: null\n    println(nextSmallest(listOf(1, 1)))           // Output: null\n}"}
{"task_id": "kotlin/39", "language": "kotlin", "completion": "fun isBored(s: String): Int {\n    // Split the string into sentences based on '.', '?' or '!'\n    val sentences = s.split('.', '?', '!')\n    \n    // Initialize a counter for the number of sentences that start with \"Ich\"\n    var count = 0\n    \n    // Iterate over each sentence\n    for (sentence in sentences) {\n        // Trim any leading or trailing whitespace\n        val trimmedSentence = sentence.trim()\n        \n        // Check if the sentence starts with \"Ich\"\n        if (trimmedSentence.startsWith(\"Ich\")) {\n            count++ // Increment the counter if it does\n        }\n    }\n    \n    // Return the count of sentences that start with \"Ich\"\n    return count\n}\n\n// Example usage\nfun main() {\n    println(isBored(\"Hello world\")) // Output: 0\n    println(isBored(\"The sky is blue. The sun is shining. I love this weather\")) // Output: 1\n    println(isBored(\"Ich bin m\u00fcde. Ich m\u00f6chte schlafen. Was ist los?\")) // Output: 2\n}"}
{"task_id": "kotlin/40", "language": "kotlin", "completion": "fun isPrime(n: Int): Boolean {\n    if (n <= 1) return false\n    if (n == 2) return true\n    if (n % 2 == 0) return false\n    for (i in 3..Math.sqrt(n.toDouble()).toInt() step 2) {\n        if (n % i == 0) return false\n    }\n    return true\n}\n\nfun sumOfDigits(n: Int): Int {\n    return n.toString().map { it.toString().toInt() }.sum()\n}\n\nfun findLargestPrime(lst: List<Int>): Int? {\n    return lst.filter { isPrime(it) }.maxOrNull()\n}\n\nfun skjkasdkd(lst: List<Int>): Int {\n    val largestPrime = findLargestPrime(lst)\n    return largestPrime?.let { sumOfDigits(it) } ?: 0\n}\n\n// Beispielaufrufe:\nfun main() {\n    println(skjkasdkd(listOf(0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3))) // Output: 10\n    println(skjkasdkd(listOf(1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1))) // Output: 25\n    println(skjkasdkd(listOf(1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3))) // Output: 13\n    println(skjkasdkd(listOf(0,724,32,71,99,32,6,0,5,91,83,0,5,6))) // Output: 11\n    println(skjkasdkd(listOf(0,81,12,3,1,21))) // Output: 3\n    println(skjkasdkd(listOf(0,8,1,2,1,7))) // Output: 7\n}"}
{"task_id": "kotlin/41", "language": "kotlin", "completion": "fun checkDictCase(dict: Map<Any?, Any?>): Boolean {\n    // Schritt 1: \u00dcberpr\u00fcfen, ob das W\u00f6rterbuch leer ist\n    if (dict.isEmpty()) {\n        return false\n    }\n\n    // Schritt 2: Filtern der Schl\u00fcssel, die keine Strings sind\n    val stringKeys = dict.keys.filterIsInstance<String>()\n\n    // Wenn nicht alle Schl\u00fcssel Strings sind, geben wir False zur\u00fcck\n    if (stringKeys.size != dict.keys.size) {\n        return false\n    }\n\n    // Schritt 3: \u00dcberpr\u00fcfen, ob alle Schl\u00fcssel entweder in Kleinbuchstaben oder in Gro\u00dfbuchstaben sind\n    val allLowerCase = stringKeys.all { it == it.lowercase() }\n    val allUpperCase = stringKeys.all { it == it.uppercase() }\n\n    return allLowerCase || allUpperCase\n}\n\n// Testf\u00e4lle\nfun main() {\n    println(checkDictCase(mapOf(\"a\" to \"apple\", \"b\" to \"banana\"))) // sollte True zur\u00fcckgeben\n    println(checkDictCase(mapOf(\"a\" to \"apple\", \"A\" to \"banana\", \"B\" to \"banana\"))) // sollte False zur\u00fcckgeben\n    println(checkDictCase(mapOf(\"a\" to \"apple\", 8 to \"banana\", \"a\" to \"apple\"))) // sollte False zur\u00fcckgeben\n    println(checkDictCase(mapOf(\"Name\" to \"John\", \"Age\" to \"36\", \"City\" to \"Houston\"))) // sollte False zur\u00fcckgeben\n    println(checkDictCase(mapOf(\"STATE\" to \"NC\", \"ZIP\" to \"12345\"))) // sollte True zur\u00fcckgeben\n}"}
{"task_id": "kotlin/42", "language": "kotlin", "completion": "import kotlin.math.roundToInt\n\nfun closestInteger(value: String): Int {\n    // Konvertiere den String in eine Gleitkommazahl\n    val number = value.toDouble()\n\n    // Runde die Zahl ab und gebe das Ergebnis zur\u00fcck\n    return if (number > 0) {\n        (number + 0.5).toInt()\n    } else {\n        (number - 0.5).toInt()\n    }\n}\n\n// Testf\u00e4lle\nfun main() {\n    println(closestInteger(\"10\"))    // 10\n    println(closestInteger(\"15.3\"))  // 15\n    println(closestInteger(\"14.5\"))  // 15\n    println(closestInteger(\"-14.5\")) // -15\n}"}
{"task_id": "kotlin/43", "language": "kotlin", "completion": "fun makeAPile(n: Int): List<Int> {\n    val pile = mutableListOf(n)\n    var currentStones = n\n    \n    while (pile.size < n) {\n        currentStones = if (currentStones % 2 == 0) {\n            currentStones + 2  // n\u00e4chste gerade Zahl\n        } else {\n            currentStones + 2  // n\u00e4chste ungerade Zahl\n        }\n        pile.add(currentStones)\n    }\n    \n    return pile\n}\n\n// Test\nfun main() {\n    println(makeAPile(3))  // Output: [3, 5, 7]\n    println(makeAPile(2))  // Output: [2, 4]\n    println(makeAPile(5))  // Output: [5, 7, 9, 11, 13]\n}"}
{"task_id": "kotlin/44", "language": "kotlin", "completion": "fun wordsString(s: String): List<String> {\n    // Split the string by commas or spaces using a regular expression\n    return s.split(Regex(\"[,\\\\s]+\")).filter { it.isNotEmpty() }\n}\n\nfun main() {\n    println(wordsString(\"Hi, my name is John\")) // Output: [Hi, my, name, is, John]\n    println(wordsString(\"One, two, three, four, five, six\")) // Output: [One, two, three, four, five, six]\n}"}
{"task_id": "kotlin/45", "language": "kotlin", "completion": "fun chooseNum(x: Int, y: Int): Int {\n    // Wenn x gr\u00f6\u00dfer als y ist, gibt es keinen g\u00fcltigen Bereich\n    if (x > y) return -1\n\n    // Finde die gr\u00f6\u00dfte gerade Zahl <= y\n    val largestEven = if (y % 2 == 0) y else y - 1\n\n    // \u00dcberpr\u00fcfe, ob die gr\u00f6\u00dfte gerade Zahl im Bereich liegt\n    return if (largestEven >= x) largestEven else -1\n}\n\n// Testbeispiele\nfun main() {\n    println(chooseNum(12, 15)) // Ausgabe: 14\n    println(chooseNum(13, 12)) // Ausgabe: -1\n    println(chooseNum(10, 20)) // Ausgabe: 20\n    println(chooseNum(11, 19)) // Ausgabe: 18\n    println(chooseNum(5, 5))   // Ausgabe: -1\n    println(chooseNum(6, 6))   // Ausgabe: 6\n}"}
{"task_id": "kotlin/46", "language": "kotlin", "completion": "fun roundedAvg(n: Int, m: Int): Any {\n    if (n > m) return -1\n    \n    val sum = (n..m).sum()\n    val count = m - n + 1\n    val average = sum.toDouble() / count\n    val roundedAverage = kotlin.math.round(average).toInt()\n    \n    return \"0b\" + Integer.toBinaryString(roundedAverage)\n}\n\n// Testf\u00e4lle\nfun main() {\n    println(roundedAvg(1, 5))   // Output: \"0b11\"\n    println(roundedAvg(7, 5))   // Output: -1\n    println(roundedAvg(10, 20)) // Output: \"0b1111\"\n    println(roundedAvg(20, 33)) // Output: \"0b11010\"\n}"}
{"task_id": "kotlin/47", "language": "kotlin", "completion": "fun f(n: Int): List<Int> {\n    fun factorial(num: Int): Int {\n        return if (num <= 1) 1 else num * factorial(num - 1)\n    }\n\n    fun sumUpTo(num: Int): Int {\n        return (1..num).sum()\n    }\n\n    return (1..n).map { i ->\n        if (i % 2 == 0) {\n            factorial(i)\n        } else {\n            sumUpTo(i)\n        }\n    }\n}\n\n// Test\nfun main() {\n    println(f(5)) // Output should be [1, 2, 6, 24, 15]\n}"}
{"task_id": "kotlin/48", "language": "kotlin", "completion": "fun evenOddPalindrome(n: Int): List<Int> {\n    // Hilfsfunktion, um zu \u00fcberpr\u00fcfen, ob eine Zahl ein Palindrom ist\n    fun isPalindrome(num: Int): Boolean {\n        val str = num.toString()\n        return str == str.reversed()\n    }\n\n    var evenCount = 0\n    var oddCount = 0\n\n    // Durchlaufen Sie alle Zahlen von 1 bis n\n    for (i in 1..n) {\n        if (isPalindrome(i)) {\n            if (i % 2 == 0) {\n                evenCount++\n            } else {\n                oddCount++\n            }\n        }\n    }\n\n    // R\u00fcckgabe der Z\u00e4hler als Liste\n    return listOf(evenCount, oddCount)\n}\n\n// Beispieleingaben\nfun main() {\n    println(evenOddPalindrome(3))  // Ausgabe: [1, 2]\n    println(evenOddPalindrome(12)) // Ausgabe: [4, 6]\n}"}
{"task_id": "kotlin/49", "language": "kotlin", "completion": "fun moveOneBall(arr: List<Int>): Boolean {\n    if (arr.isEmpty()) return true\n\n    var countDecreases = 0\n    val n = arr.size\n\n    for (i in 1 until n) {\n        if (arr[i] < arr[i - 1]) {\n            countDecreases++\n        }\n    }\n\n    // Check the boundary condition between the last and first element\n    if (arr[n - 1] > arr[0]) {\n        countDecreases++\n    }\n\n    return countDecreases <= 1\n}\n\n// Test cases\nfun main() {\n    println(moveOneBall(listOf(3, 4, 5, 1, 2))) // True\n    println(moveOneBall(listOf(3, 5, 4, 1, 2))) // False\n    println(moveOneBall(listOf())) // True\n    println(moveOneBall(listOf(1, 2, 3, 4, 5))) // True\n    println(moveOneBall(listOf(2, 3, 4, 5, 1))) // True\n}"}
{"task_id": "kotlin/50", "language": "kotlin", "completion": "fun exchange(lst1: List<Int>, lst2: List<Int>): String {\n    // Z\u00e4hle die ungeraden Zahlen in lst1\n    val oddCountInLst1 = lst1.count { it % 2 != 0 }\n    \n    // Z\u00e4hle die geraden Zahlen in lst2\n    val evenCountInLst2 = lst2.count { it % 2 == 0 }\n    \n    // \u00dcberpr\u00fcfe, ob gen\u00fcgend gerade Zahlen in lst2 vorhanden sind\n    return if (evenCountInLst2 >= oddCountInLst1) \"YES\" else \"NO\"\n}\n\n// Beispielaufrufe\nfun main() {\n    println(exchange(listOf(1, 2, 3, 4), listOf(1, 2, 3, 4))) // \"YES\"\n    println(exchange(listOf(1, 2, 3, 4), listOf(1, 5, 3, 4))) // \"NO\"\n}"}
{"task_id": "kotlin/51", "language": "kotlin", "completion": "fun reverseDelete(s: String, c: String): List<Any> {\n    // Erstelle eine Menge von Zeichen aus der Zeichenkette c zur schnellen \u00dcberpr\u00fcfung\n    val charsToDelete = c.toSet()\n    \n    // Filtere alle Zeichen aus s, die nicht in charsToDelete enthalten sind\n    val filteredString = s.filter { it !in charsToDelete }\n    \n    // \u00dcberpr\u00fcfe, ob die gefilterte Zeichenkette ein Palindrom ist\n    val isPalindrome = filteredString == filteredString.reversed()\n    \n    // Gib die resultierende Zeichenkette und das Ergebnis der Palindrom\u00fcberpr\u00fcfung zur\u00fcck\n    return listOf(filteredString, isPalindrome)\n}\n\n// Beispielaufrufe zur \u00dcberpr\u00fcfung der Funktion\nfun main() {\n    println(reverseDelete(\"abcde\", \"ae\")) // soll ['bcd', false] ausgeben\n    println(reverseDelete(\"abcdef\", \"b\")) // soll ['acdef', false] ausgeben\n    println(reverseDelete(\"abcdedcba\", \"ab\")) // soll ['cdedc', true] ausgeben\n}"}
{"task_id": "kotlin/52", "language": "kotlin", "completion": "fun maxFill(grid: List<List<Int>>, capacity: Int): Int {\n    // Berechne die Gesamtanzahl der 1er im Gitter\n    var totalWaterUnits = 0\n    for (row in grid) {\n        for (cell in row) {\n            if (cell == 1) {\n                totalWaterUnits++\n            }\n        }\n    }\n\n    // Berechne die Anzahl der notwendigen Eimersenkungen\n    return if (totalWaterUnits % capacity == 0) {\n        totalWaterUnits / capacity\n    } else {\n        totalWaterUnits / capacity + 1\n    }\n}\n\n// Testf\u00e4lle\nfun main() {\n    val grid1 = listOf(listOf(0, 0, 1, 0), listOf(0, 1, 0, 0), listOf(1, 1, 1, 1))\n    val capacity1 = 1\n    println(maxFill(grid1, capacity1)) // Erwartete Ausgabe: 6\n\n    val grid2 = listOf(listOf(0, 0, 1, 1), listOf(0, 0, 0, 0), listOf(1, 1, 1, 1), listOf(0, 1, 1, 1))\n    val capacity2 = 2\n    println(maxFill(grid2, capacity2)) // Erwartete Ausgabe: 5\n\n    val grid3 = listOf(listOf(0, 0, 0), listOf(0, 0, 0))\n    val capacity3 = 5\n    println(maxFill(grid3, capacity3)) // Erwartete Ausgabe: 0\n}"}
{"task_id": "kotlin/53", "language": "kotlin", "completion": "fun selectWords(s: String, n: Int): List<String> {\n    if (s.isEmpty()) return emptyList()\n    \n    val vowels = setOf('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U')\n    \n    return s.split(\" \")\n        .filter { word -> word.count { !vowels.contains(it) } == n }\n}\n\n// Testcases\nfun main() {\n    println(selectWords(\"Mary had a little lamb\", 4))  // [\"little\"]\n    println(selectWords(\"Mary had a little lamb\", 3))  // [\"Mary\", \"lamb\"]\n    println(selectWords(\"simple white space\", 2))      // []\n    println(selectWords(\"Hello world\", 4))             // [\"world\"]\n    println(selectWords(\"Uncle sam\", 3))               // [\"Uncle\"]\n}"}
{"task_id": "kotlin/54", "language": "kotlin", "completion": "fun maximum(arr: List<Int>, k: Int): List<Int> {\n    // Sortiere das Array in absteigender Reihenfolge\n    val sortedDescending = arr.sortedDescending()\n    \n    // Nimm die ersten k Elemente und sortiere sie in aufsteigender Reihenfolge\n    return sortedDescending.take(k).sorted()\n}\n\n// Testf\u00e4lle\nfun main() {\n    println(maximum(listOf(-3, -4, 5), 3)) // Output: [-4, -3, 5]\n    println(maximum(listOf(4, -4, 4), 2)) // Output: [4, 4]\n    println(maximum(listOf(-3, 2, 1, 2, -1, -2, 1), 1)) // Output: [2]\n}"}
{"task_id": "kotlin/55", "language": "kotlin", "completion": "fun addElements(arr: List<Int>, k: Int): Int {\n    var sum = 0\n    for (i in 0 until k) {\n        if (arr[i] in -99..99) {\n            sum += arr[i]\n        }\n    }\n    return sum\n}\n\n// Beispielaufruf\nfun main() {\n    val arr = listOf(111, 21, 3, 4000, 5, 6, 7, 8, 9)\n    val k = 4\n    println(addElements(arr, k))  // Ausgabe: 24\n}"}
{"task_id": "kotlin/56", "language": "kotlin", "completion": "fun intersection(interval1: List<Int>, interval2: List<Int>): String {\n    // Berechne den Startpunkt und den Endpunkt des Schnitts\n    val start = maxOf(interval1[0], interval2[0])\n    val end = minOf(interval1[1], interval2[1])\n    \n    // Berechne die L\u00e4nge des Schnitts\n    val length = end - start + 1\n    \n    // Wenn sich die Intervalle nicht \u00fcberschneiden, ist die L\u00e4nge <= 0\n    if (length <= 0) return \"NO\"\n    \n    // Funktion zur Pr\u00fcfung, ob eine Zahl eine Primzahl ist\n    fun isPrime(num: Int): Boolean {\n        if (num <= 1) return false\n        if (num == 2) return true\n        if (num % 2 == 0) return false\n        for (i in 3..Math.sqrt(num.toDouble()).toInt() step 2) {\n            if (num % i == 0) return false\n        }\n        return true\n    }\n    \n    // Pr\u00fcfe, ob die L\u00e4nge des Schnitts eine Primzahl ist\n    return if (isPrime(length)) \"YES\" else \"NO\"\n}\n\n// Beispieleingaben und ihre erwarteten Ausgaben\nfun main() {\n    println(intersection(listOf(1, 2), listOf(2, 3)))  // ==> \"NO\"\n    println(intersection(listOf(-1, 1), listOf(0, 4))) // ==> \"NO\"\n    println(intersection(listOf(-3, -1), listOf(-5, 5))) // ==> \"YES\"\n}"}
{"task_id": "kotlin/57", "language": "kotlin", "completion": "fun tri(n: Int): List<Int> {\n    // Memoization to store already computed values\n    val memo = mutableMapOf<Int, Int>()\n\n    // Helper function to compute the tribonacci value\n    fun triHelper(x: Int): Int {\n        if (memo.containsKey(x)) return memo[x]!!\n        val result = when {\n            x == 1 -> 3\n            x % 2 == 0 -> 1 + x / 2\n            else -> triHelper(x - 1) + triHelper(x - 2) + triHelper(x + 1)\n        }\n        memo[x] = result\n        return result\n    }\n\n    // Generate the sequence from 0 to n\n    return (0..n).map { i -> triHelper(i) }\n}\n\n// Test the function\nfun main() {\n    val n = 3\n    println(tri(n))  // Output: [1, 3, 2, 8]\n}"}
{"task_id": "kotlin/58", "language": "kotlin", "completion": "fun digits(n: Int): Int {\n    // Konvertiere die Zahl in eine Liste von Ziffern\n    val digits = n.toString().map { it.toString().toInt() }\n    \n    // Filtern von ungeraden Ziffern\n    val oddDigits = digits.filter { it % 2 != 0 }\n    \n    // Wenn es keine ungeraden Ziffern gibt, gib 0 zur\u00fcck\n    if (oddDigits.isEmpty()) return 0\n    \n    // Multipliziere alle ungeraden Ziffern\n    return oddDigits.reduce { acc, digit -> acc * digit }\n}\n\n// Testf\u00e4lle\nfun main() {\n    println(digits(1))   // 1\n    println(digits(4))   // 0\n    println(digits(235)) // 15\n}"}
{"task_id": "kotlin/59", "language": "kotlin", "completion": "fun isNested(string: String): Boolean {\n    val stack = mutableListOf<Char>()\n    var hasNested = false\n\n    for (char in string) {\n        when (char) {\n            '[' -> stack.add(char)\n            ']' -> {\n                if (stack.isEmpty()) return false\n                stack.removeAt(stack.size - 1)\n                if (stack.isNotEmpty()) hasNested = true\n            }\n        }\n    }\n\n    return hasNested\n}\n\nfun main() {\n    println(isNested(\"[[]]\")) // \u279e True\n    println(isNested(\"[]]]]]]][[[[[]\")) // \u279e False\n    println(isNested(\"[][]\")) // \u279e False\n    println(isNested(\"[]\")) // \u279e False\n    println(isNested(\"[[][]]\")) // \u279e True\n    println(isNested(\"[[]][[\")) // \u279e True\n}"}
{"task_id": "kotlin/60", "language": "kotlin", "completion": "import kotlin.math.ceil\n\nfun sumSquares(lst: List<Any>): Int {\n    return lst.map {\n        when (it) {\n            is Number -> ceil(it.toDouble()).toInt() // Runde auf die n\u00e4chste Ganzzahl auf\n            else -> throw IllegalArgumentException(\"List contains non-numeric elements\")\n        }\n    }.map { it * it } // Quadriere die gerundeten Zahlen\n     .sum() // Summiere alle quadrierten Zahlen\n}\n\n// Testf\u00e4lle\nfun main() {\n    println(sumSquares(listOf(1, 2, 3))) // Sollte 14 sein\n    println(sumSquares(listOf(1, 4, 9))) // Sollte 98 sein\n    println(sumSquares(listOf(1, 3, 5, 7))) // Sollte 84 sein\n    println(sumSquares(listOf(1.4, 4.2, 0))) // Sollte 29 sein\n    println(sumSquares(listOf(-2.4, 1, 1))) // Sollte 6 sein\n}"}
{"task_id": "kotlin/61", "language": "kotlin", "completion": "fun checkIfLastCharIsALetter(txt: String): Boolean {\n    val trimmedTxt = txt.trim()\n    \n    if (trimmedTxt.isEmpty()) {\n        return false\n    }\n    \n    val lastChar = trimmedTxt.last()\n    \n    if (!lastChar.isLetter()) {\n        return false\n    }\n    \n    val words = trimmedTxt.split(\" \")\n    \n    if (words.isNotEmpty() && words.last().length == 1) {\n        return true\n    }\n    \n    return false\n}\n\n// Testf\u00e4lle\nfun main() {\n    println(checkIfLastCharIsALetter(\"apple pie\"))  // \u279e False\n    println(checkIfLastCharIsALetter(\"apple pi e\")) // \u279e True\n    println(checkIfLastCharIsALetter(\"apple pi e \")) // \u279e False\n    println(checkIfLastCharIsALetter(\"\")) // \u279e False\n}"}
{"task_id": "kotlin/62", "language": "kotlin", "completion": "fun canArrange(arr: List<Int>): Int {\n    // \u00dcberpr\u00fcfen, ob das Array weniger als 2 Elemente hat\n    if (arr.size < 2) {\n        return -1\n    }\n    \n    // Variable um den Index zu speichern\n    var result = -1\n    \n    // Durchlaufe das Array ab dem zweiten Element\n    for (i in 1 until arr.size) {\n        // \u00dcberpr\u00fcfen ob das aktuelle Element kleiner oder gleich dem vorhergehenden Element ist\n        if (arr[i] <= arr[i - 1]) {\n            result = i\n        }\n    }\n    \n    return result\n}\n\n// Beispielaufrufe\nfun main() {\n    println(canArrange(listOf(1, 2, 4, 3, 5))) // Ausgabe: 3\n    println(canArrange(listOf(1, 2, 3))) // Ausgabe: -1\n}"}
{"task_id": "kotlin/63", "language": "kotlin", "completion": "fun largestSmallestIntegers(lst: List<Int>): Pair<Int?, Int?> {\n    var largestNegative: Int? = null\n    var smallestPositive: Int? = null\n\n    for (num in lst) {\n        if (num < 0) {\n            if (largestNegative == null || num > largestNegative) {\n                largestNegative = num\n            }\n        } else if (num > 0) {\n            if (smallestPositive == null || num < smallestPositive) {\n                smallestPositive = num\n            }\n        }\n    }\n\n    return Pair(largestNegative, smallestPositive)\n}\n\n// Beispielaufrufe\nfun main() {\n    println(largestSmallestIntegers(listOf(2, 4, 1, 3, 5, 7))) // Output: (null, 1)\n    println(largestSmallestIntegers(emptyList())) // Output: (null, null)\n    println(largestSmallestIntegers(listOf(0))) // Output: (null, null)\n    println(largestSmallestIntegers(listOf(-3, -1, -2, 0, 4, 3))) // Output: (-1, 3)\n    println(largestSmallestIntegers(listOf(-3, -1, -2, 4, 3))) // Output: (-1, 3)\n}"}
{"task_id": "kotlin/64", "language": "kotlin", "completion": "fun factorial(n: Int): Int {\n    return if (n <= 1) 1 else n * factorial(n - 1)\n}\n\nfun specialFactorial(n: Int): Int {\n    var result = 1\n    for (i in 1..n) {\n        result *= factorial(i)\n    }\n    return result\n}\n\nfun main() {\n    println(specialFactorial(4))  // Ausgabe: 288\n}"}
{"task_id": "kotlin/65", "language": "kotlin", "completion": "fun isPrime(n: Int): Boolean {\n    if (n <= 1) return false\n    if (n == 2) return true\n    if (n % 2 == 0) return false\n    for (i in 3..Math.sqrt(n.toDouble()).toInt() step 2) {\n        if (n % i == 0) return false\n    }\n    return true\n}\n\nfun wordsInSentence(sentence: String): String {\n    return sentence.split(\" \")\n        .filter { isPrime(it.length) }\n        .joinToString(\" \")\n}\n\nfun main() {\n    // Beispiel 1\n    val sentence1 = \"This is a test\"\n    println(wordsInSentence(sentence1)) // Ausgabe: \"is\"\n\n    // Beispiel 2\n    val sentence2 = \"lets go for swimming\"\n    println(wordsInSentence(sentence2)) // Ausgabe: \"go for\"\n}"}
{"task_id": "kotlin/66", "language": "kotlin", "completion": "fun simplify(x: String, n: String): Boolean {\n    // Zerlegen der Br\u00fcche x und n in Z\u00e4hler und Nenner\n    val (xNumerator, xDenominator) = x.split(\"/\").map { it.toInt() }\n    val (nNumerator, nDenominator) = n.split(\"/\").map { it.toInt() }\n\n    // Produkt der Br\u00fcche berechnen\n    val productNumerator = xNumerator * nNumerator\n    val productDenominator = xDenominator * nDenominator\n\n    // \u00dcberpr\u00fcfen, ob das Ergebnis eine ganze Zahl ist\n    return productNumerator % productDenominator == 0\n}\n\n// Testf\u00e4lle\nfun main() {\n    println(simplify(\"1/5\", \"5/1\")) // True\n    println(simplify(\"1/6\", \"2/1\")) // False\n    println(simplify(\"7/10\", \"10/2\")) // False\n}"}
{"task_id": "kotlin/67", "language": "kotlin", "completion": "fun orderByPoints(nums: List<Int>): List<Int> {\n    // Funktion zum Berechnen der Ziffernsumme einer Zahl\n    fun digitSum(n: Int): Int {\n        return n.toString().filter { it.isDigit() }.sumOf { it.toString().toInt() }\n    }\n\n    // Sortieren der Liste basierend auf der Ziffernsumme und dem Originalindex\n    return nums.withIndex().sortedWith(compareBy({ digitSum(it.value) }, { it.index })).map { it.value }\n}\n\nfun main() {\n    // Testf\u00e4lle\n    println(orderByPoints(listOf(1, 11, -1, -11, -12)))  // Output: [-1, -11, 1, -12, 11]\n    println(orderByPoints(emptyList()))  // Output: []\n}"}
{"task_id": "kotlin/68", "language": "kotlin", "completion": "fun specialFilter(nums: List<Int>): Int {\n    return nums.count { num ->\n        val absNum = Math.abs(num)\n        absNum > 10 && isOdd(absNum.toString().first()) && isOdd(absNum.toString().last())\n    }\n}\n\nfun isOdd(char: Char): Boolean {\n    return char in listOf('1', '3', '5', '7', '9')\n}\n\nfun main() {\n    println(specialFilter(listOf(15, -73, 14, -15))) // 1\n    println(specialFilter(listOf(33, -2, -3, 45, 21, 109))) // 2\n}"}
{"task_id": "kotlin/69", "language": "kotlin", "completion": "fun getMaxTriples(n: Int): Int {\n    // Schritt 1: Array a erstellen\n    val a = IntArray(n) { i -> (i + 1) * (i + 1) - (i + 1) + 1 }\n\n    // Schritt 2: Anzahl der g\u00fcltigen Tripel finden\n    var count = 0\n    for (i in 0 until n - 2) {\n        for (j in i + 1 until n - 1) {\n            for (k in j + 1 until n) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++\n                }\n            }\n        }\n    }\n\n    // Schritt 3: Anzahl der Tripel zur\u00fcckgeben\n    return count\n}\n\n// Beispieltest\nfun main() {\n    val n = 5\n    println(getMaxTriples(n))  // Ausgabe: 1\n}"}
{"task_id": "kotlin/70", "language": "kotlin", "completion": "fun bf(planet1: String, planet2: String): List<String> {\n    val planets = listOf(\n        \"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\n    )\n\n    val index1 = planets.indexOf(planet1)\n    val index2 = planets.indexOf(planet2)\n\n    // \u00dcberpr\u00fcfen, ob beide Planeten g\u00fcltige Namen haben\n    if (index1 == -1 || index2 == -1) {\n        return emptyList()\n    }\n\n    // Finden der Min- und Max-Indizes\n    val startIndex = minOf(index1, index2)\n    val endIndex = maxOf(index1, index2)\n\n    // Extrahieren der Planeten zwischen den beiden Indizes\n    return planets.subList(startIndex + 1, endIndex)\n}\n\n// Testausgaben\nfun main() {\n    println(bf(\"Jupiter\", \"Neptune\")) // ==> [\"Saturn\", \"Uranus\"]\n    println(bf(\"Earth\", \"Mercury\")) // ==> [\"Venus\"]\n    println(bf(\"Mercury\", \"Uranus\")) // ==> [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"]\n    println(bf(\"Pluto\", \"Earth\")) // ==> []\n}"}
{"task_id": "kotlin/71", "language": "kotlin", "completion": "fun isPrime(n: Int): Boolean {\n    if (n <= 1) return false\n    if (n == 2) return true\n    if (n % 2 == 0) return false\n    for (i in 3..Math.sqrt(n.toDouble()).toInt() step 2) {\n        if (n % i == 0) return false\n    }\n    return true\n}\n\nfun xOrY(n: Int, x: Int, y: Int): Int {\n    return if (isPrime(n)) x else y\n}\n\nfun main() {\n    println(xOrY(7, 34, 12))  // Output: 34\n    println(xOrY(15, 8, 5))   // Output: 5\n}"}
{"task_id": "kotlin/72", "language": "kotlin", "completion": "fun doubleTheDifference(lst : List<Any>) : Int {\n    return lst.filterIsInstance<Int>() // Nur ganze Zahlen behalten\n              .filter { it > 0 && it % 2 != 0 } // Nur positive, ungerade Zahlen behalten\n              .map { it * it } // Die Quadrate der Zahlen berechnen\n              .sum() // Die Quadrate aufsummieren\n}\n\n// Testf\u00e4lle\nfun main() {\n    println(doubleTheDifference(listOf(1, 3, 2, 0))) // 10\n    println(doubleTheDifference(listOf(-1, -2, 0))) // 0\n    println(doubleTheDifference(listOf(9, -2))) // 81\n    println(doubleTheDifference(listOf(0))) // 0\n    println(doubleTheDifference(listOf())) // 0\n}"}
{"task_id": "kotlin/73", "language": "kotlin", "completion": "fun strongestExtension(className: String, extensions: List<String>): String {\n    var strongestExtension = \"\"\n    var maxStrength = Int.MIN_VALUE\n\n    for (extension in extensions) {\n        val capCount = extension.count { it.isUpperCase() }\n        val smCount = extension.count { it.isLowerCase() }\n        val strength = capCount - smCount\n\n        if (strength > maxStrength) {\n            maxStrength = strength\n            strongestExtension = extension\n        }\n    }\n\n    return \"$className.$strongestExtension\"\n}\n\n// Testbeispiele\nfun main() {\n    println(strongestExtension(\"my_class\", listOf(\"AA\", \"Be\", \"CC\"))) // Erwartet: my_class.AA\n    println(strongestExtension(\"Slices\", listOf(\"SErviNGSliCes\", \"Cheese\", \"StuFfed\"))) // Erwartet: Slices.SErviNGSliCes\n}"}
{"task_id": "kotlin/74", "language": "kotlin", "completion": "fun cycpatternCheck(a: String, b: String): Boolean {\n    // Wenn b l\u00e4nger ist als a, kann b oder seine Rotationen nicht Teilstring von a sein\n    if (b.length > a.length) return false\n\n    // Erstellen aller Rotationen von b\n    val rotations = mutableListOf<String>()\n    for (i in b.indices) {\n        val rotation = b.substring(i) + b.substring(0, i)\n        rotations.add(rotation)\n    }\n\n    // \u00dcberpr\u00fcfen, ob eine der Rotationen von b Teilstring von a ist\n    for (rotation in rotations) {\n        if (a.contains(rotation)) {\n            return true\n        }\n    }\n    \n    return false\n}\n\n// Testf\u00e4lle\nfun main() {\n    println(cycpatternCheck(\"abcd\", \"abd\")) // False\n    println(cycpatternCheck(\"hello\", \"ell\")) // True\n    println(cycpatternCheck(\"whassup\", \"psus\")) // False\n    println(cycpatternCheck(\"abab\", \"baa\")) // True\n    println(cycpatternCheck(\"efef\", \"eeff\")) // False\n    println(cycpatternCheck(\"himenss\", \"simen\")) // True\n}"}
{"task_id": "kotlin/75", "language": "kotlin", "completion": "fun intToMiniRoman(number: Int): String {\n    // Liste der r\u00f6mischen Symbole und ihre Werte\n    val romans = listOf(\n        1000 to \"m\",\n        900 to \"cm\",\n        500 to \"d\",\n        400 to \"cd\",\n        100 to \"c\",\n        90 to \"xc\",\n        50 to \"l\",\n        40 to \"xl\",\n        10 to \"x\",\n        9 to \"ix\",\n        5 to \"v\",\n        4 to \"iv\",\n        1 to \"i\"\n    )\n\n    var num = number\n    val romanString = StringBuilder()\n\n    // \u00dcber die Liste der r\u00f6mischen Symbole iterieren\n    for ((value, symbol) in romans) {\n        // Solange die aktuelle Zahl gr\u00f6\u00dfer oder gleich dem Wert des Symbols ist\n        while (num >= value) {\n            // Das Symbol hinzuf\u00fcgen\n            romanString.append(symbol)\n            // Die Zahl um den Wert des Symbols reduzieren\n            num -= value\n        }\n    }\n\n    return romanString.toString()\n}\n\nfun main() {\n    println(intToMiniRoman(19))   // xix\n    println(intToMiniRoman(152))  // clii\n    println(intToMiniRoman(426))  // cdxxvi\n}"}
{"task_id": "kotlin/76", "language": "kotlin", "completion": "fun rightAngleTriangle(a: Int, b: Int, c: Int): Boolean {\n    // Finde die l\u00e4ngste Seite\n    val maxSide = maxOf(a, b, c)\n    val otherSides = listOf(a, b, c).filter { it != maxSide }\n\n    // \u00dcberpr\u00fcfe, ob die Summe der Quadrate der beiden anderen Seiten gleich dem Quadrat der l\u00e4ngsten Seite ist\n    return if (otherSides.size == 2) {\n        val (side1, side2) = otherSides\n        maxSide * maxSide == side1 * side1 + side2 * side2\n    } else {\n        false\n    }\n}\n\n// Testf\u00e4lle\nfun main() {\n    println(rightAngleTriangle(3, 4, 5)) // Erwartet: True\n    println(rightAngleTriangle(1, 2, 3)) // Erwartet: False\n    println(rightAngleTriangle(5, 12, 13)) // Erwartet: True\n    println(rightAngleTriangle(7, 24, 25)) // Erwartet: True\n    println(rightAngleTriangle(8, 15, 17)) // Erwartet: True\n}"}
{"task_id": "kotlin/77", "language": "kotlin", "completion": "fun solve(s: String): String {\n    // Pr\u00fcfen, ob der String Buchstaben enth\u00e4lt\n    val containsLetter = s.any { it.isLetter() }\n    \n    return if (containsLetter) {\n        // Wenn der String Buchstaben enth\u00e4lt, kehren wir die Gro\u00df- und Kleinschreibung um\n        s.map { \n            if (it.isUpperCase()) it.toLowerCase() \n            else if (it.isLowerCase()) it.toUpperCase() \n            else it \n        }.joinToString(\"\")\n    } else {\n        // Wenn der String keine Buchstaben enth\u00e4lt, kehren wir den String um\n        s.reversed()\n    }\n}\n\n// Testf\u00e4lle\nfun main() {\n    println(solve(\"1234\"))  // \"4321\"\n    println(solve(\"ab\"))    // \"AB\"\n    println(solve(\"#a@C\"))  // \"#A@c\"\n}"}
{"task_id": "kotlin/78", "language": "kotlin", "completion": "import java.security.MessageDigest\n\nfun stringToMd5(text: String): String? {\n    if (text.isEmpty()) return null\n\n    val md = MessageDigest.getInstance(\"MD5\")\n    val digest = md.digest(text.toByteArray())\n    val hexString = StringBuilder()\n\n    for (byte in digest) {\n        val hex = Integer.toHexString(0xff and byte.toInt())\n        if (hex.length == 1) {\n            hexString.append('0')\n        }\n        hexString.append(hex)\n    }\n\n    return hexString.toString()\n}\n\nfun main() {\n    println(stringToMd5(\"Hello world\"))  // Outputs: 3e25960a79dbc69b674cd4ec67a72c62\n}"}
{"task_id": "kotlin/79", "language": "kotlin", "completion": "fun generateIntegers(a: Int, b: Int): List<Int> {\n    // Bestimme die Grenzen des Bereichs\n    val start = minOf(a, b)\n    val end = maxOf(a, b)\n\n    // Erzeuge eine Sequenz von Zahlen im Bereich und filtere die geraden Zahlen heraus\n    return (start..end).filter { it % 2 == 0 }\n}\n\n// Testbeispiele\nfun main() {\n    println(generateIntegers(2, 8))  // [2, 4, 6, 8]\n    println(generateIntegers(8, 2))  // [2, 4, 6, 8]\n    println(generateIntegers(10, 14))  // [10, 12, 14]\n}"}
