{"task_id": "java/0", "language": "java", "completion": "import java.util.*;\n\nclass BelowZero {\n    public static Boolean belowZero(List<Object> operations) {\n        int balance = 0;\n        \n        for (Object operation : operations) {\n            if (operation instanceof Integer) {\n                balance += (Integer) operation;\n                if (balance < 0) {\n                    return true;\n                }\n            } else {\n                System.out.println(\"Invalid operation: \" + operation);\n                return false; // Invalid input, should not happen as per problem statement\n            }\n        }\n        \n        return false;\n    }\n    \n    public static void main(String[] args) {\n        List<Object> operations1 = Arrays.asList(1, 2, 3);\n        System.out.println(belowZero(operations1)); // False\n        \n        List<Object> operations2 = Arrays.asList(1, 2, -4, 5);\n        System.out.println(belowZero(operations2)); // True\n    }\n}"}
{"task_id": "java/1", "language": "java", "completion": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\nclass SumProduct {\n    /**\n     * \n     * F\u00fcr eine gegebene Liste von ganzen Zahlen soll ein Tupel zur\u00fcckgegeben werden, das aus der Summe und dem Produkt aller Zahlen in der Liste besteht.\n     * Eine leere Summe soll gleich 0 und ein leeres Produkt gleich 1 sein.\n     * >>> sum_product([])\n     * (0, 1)\n     * >>> sum_product([1, 2, 3, 4])\n     * (10, 24)\n     *\n     */\n    public static List<Integer> sumProduct(List<Object> numbers) {\n        if (numbers == null || numbers.isEmpty()) {\n            return Arrays.asList(0, 1); // Return (sum, product) as a list of integers\n        }\n\n        int sum = 0;\n        BigInteger product = BigInteger.ONE;\n\n        for (Object num : numbers) {\n            if (num instanceof Integer) {\n                int number = (int) num;\n                sum += number;\n                product = product.multiply(BigInteger.valueOf(number));\n            } else {\n                throw new IllegalArgumentException(\"All elements in the list must be integers.\");\n            }\n        }\n\n        List<Integer> result = new ArrayList<>();\n        result.add(sum);\n        result.add(product.intValue());\n        return result;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(sumProduct(Arrays.asList())); // Output: [0, 1]\n        System.out.println(sumProduct(Arrays.asList(1, 2, 3, 4))); // Output: [10, 24]\n    }\n}"}
{"task_id": "java/2", "language": "java", "completion": "// \u00dcberpr\u00fcfen, ob die Eingabezeichenketten gleich lang sind\n        if (a.length() != b.length()) {\n            throw new IllegalArgumentException(\"Die beiden Zeichenketten m\u00fcssen dieselbe L\u00e4nge haben.\");\n        }\n\n        // StringBuilder zum Ergebnis hinzuf\u00fcgen\n        StringBuilder result = new StringBuilder();\n\n        // Durchlaufen der Zeichenketten und XOR-Operation\n        for (int i = 0; i < a.length(); i++) {\n            char bitA = a.charAt(i);\n            char bitB = b.charAt(i);\n\n            // F\u00fchren Sie eine bin\u00e4re XOR-Operation durch und f\u00fcgen Sie das Ergebnis zum StringBuilder hinzu\n            if (bitA == bitB) {\n                result.append('0');\n            } else {\n                result.append('1');\n            }\n        }\n\n        // Konvertieren Sie den StringBuilder in eine Zeichenkette und geben Sie das Ergebnis zur\u00fcck\n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        // Beispieltestfall\n        String a = \"010\";\n        String b = \"110\";\n        System.out.println(\"Ergebnis: \" + stringXor(a, b));  // Ausgabe sollte '100' sein\n    }\n}"}
{"task_id": "java/3", "language": "java", "completion": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\nclass Longest {\n    /**\n     * \n     * Aus einer Liste von Zeichenketten soll die l\u00e4ngste zur\u00fcckgegeben werden. Im Falle von mehreren Zeichenketten mit gleicher L\u00e4nge soll die erste zur\u00fcckgegeben werden. Falls die Eingabeliste leer ist, soll null zur\u00fcckgegeben werden.\n     * >>> longest([])\n     * null\n     * >>> longest(['a', 'b', 'c'])\n     * 'a'\n     * >>> longest(['a', 'bb', 'ccc'])\n     * 'ccc'\n     */\n    public static String longest(List<Object> strings) {\n        if (strings == null || strings.isEmpty()) {\n            return null;\n        }\n\n        String longestString = \"\";\n        for (String s : strings) {\n            if (s.length() > longestString.length()) {\n                longestString = s;\n            }\n        }\n        return longestString;\n    }\n\n    public static void main(String[] args) {\n        List<Object> list1 = new ArrayList<>();\n        System.out.println(longest(list1)); // null\n\n        List<Object> list2 = Arrays.asList(\"a\", \"b\", \"c\");\n        System.out.println(longest(list2)); // 'a'\n\n        List<Object> list3 = Arrays.asList(\"a\", \"bb\", \"ccc\");\n        System.out.println(longest(list3)); // 'ccc'\n    }\n}"}
{"task_id": "java/4", "language": "java", "completion": "class GreatestCommonDivisor {\n    /**\n     * Gib den gr\u00f6\u00dften gemeinsamen Teiler von zwei ganzen Zahlen a und b zur\u00fcck.\n     * >>> greatest_common_divisor(3, 5)\n     * 1\n     * >>> greatest_common_divisor(25, 15)\n     * 5\n     */\n    public static int greatestCommonDivisor(int a, int b) {\n        // Ensure that the numbers are non-negative\n        if (a < 0) a = -a;\n        if (b < 0) b = -b;\n\n        // Use the Euclidean algorithm to find the GCD\n        while (b != 0) {\n            int temp = b;\n            b = a % b;\n            a = temp;\n        }\n        return a;\n    }\n\n    public static void main(String[] args) {\n        // Test cases\n        System.out.println(greatestCommonDivisor(3, 5)); // Output: 1\n        System.out.println(greatestCommonDivisor(25, 15)); // Output: 5\n        System.out.println(greatestCommonDivisor(-3, 5)); // Output: 1 (ignoring the sign)\n        System.out.println(greatestCommonDivisor(25, -15)); // Output: 5 (ignoring the sign)\n    }\n}"}
{"task_id": "java/5", "language": "java", "completion": "// Split the input string into individual words\n        String[] numberWords = numbers.split(\" \");\n\n        // Create a list to hold the numeric values of the words\n        List<Integer> numericValues = new ArrayList<>();\n\n        // Map each word to its corresponding numeric value\n        Map<String, Integer> wordToNumberMap = new HashMap<>();\n        wordToNumberMap.put(\"null\", 0);\n        wordToNumberMap.put(\"eins\", 1);\n        wordToNumberMap.put(\"zwei\", 2);\n        wordToNumberMap.put(\"drei\", 3);\n        wordToNumberMap.put(\"vier\", 4);\n        wordToNumberMap.put(\"f\u00fcnf\", 5);\n        wordToNumberMap.put(\"sechs\", 6);\n        wordToNumberMap.put(\"sieben\", 7);\n        wordToNumberMap.put(\"acht\", 8);\n        wordToNumberMap.put(\"neun\", 9);\n\n        // Convert each word to its numeric value and add it to the list\n        for (String word : numberWords) {\n            if (wordToNumberMap.containsKey(word)) {\n                numericValues.add(wordToNumberMap.get(word));\n            } else {\n                throw new IllegalArgumentException(\"Invalid number word: \" + word);\n            }\n        }\n\n        // Sort the list of numeric values\n        Collections.sort(numericValues);\n\n        // Convert the sorted numeric values back to words\n        List<String> sortedWords = new ArrayList<>();\n        for (int value : numericValues) {\n            for (Map.Entry<String, Integer> entry : wordToNumberMap.entrySet()) {\n                if (entry.getValue().equals(value)) {\n                    sortedWords.add(entry.getKey());\n                    break;\n                }\n            }\n        }\n\n        // Join the sorted words into a single string and return it\n        return String.join(\" \", sortedWords);\n    }\n\n    public static void main(String[] args) {\n        // Test the sortNumbers method with an example input\n        System.out.println(sortNumbers(\"three one five\")); // Output: \"one three five\"\n    }\n}\n\nThis code defines a `SortNumbers` class with a static method `sortNumbers` that takes a string of space-separated number words and returns them sorted in ascending order. The method uses a map to convert the number words to their numeric values, sorts these values, and then converts them back to words before returning the result."}
{"task_id": "java/6", "language": "java", "completion": "// \u00dcberpr\u00fcfen, ob die Liste leer ist oder nur ein Element enth\u00e4lt\n        if (numbers == null || numbers.size() < 2) {\n            throw new IllegalArgumentException(\"Die Liste muss mindestens zwei Elemente enthalten.\");\n        }\n\n        // Finden der minimalen und maximalen Werte in der Liste\n        double min = Collections.min(numbers);\n        double max = Collections.max(numbers);\n\n        // Erstellen einer neuen Liste f\u00fcr die transformierten Zahlen\n        List<Double> rescaledNumbers = new ArrayList<>();\n\n        // Durchlaufen der urspr\u00fcnglichen Liste und Anwenden der linearen Transformation\n        for (double number : numbers) {\n            double rescaledValue = (number - min) / (max - min);\n            rescaledNumbers.add(rescaledValue);\n        }\n\n        return rescaledNumbers;\n    }\n\n    public static void main(String[] args) {\n        // Beispieltestfall\n        List<Double> numbers = Arrays.asList(1.0, 2.0, 3.0, 4.0, 5.0);\n        System.out.println(rescaleToUnit(numbers)); // Ausgabe: [0.0, 0.25, 0.5, 0.75, 1.0]\n    }\n}"}
{"task_id": "java/7", "language": "java", "completion": "class FlipCase {\n    /**\n     * F\u00fcr einen gegebenen String, tausche Kleinbuchstaben in Gro\u00dfbuchstaben und Gro\u00dfbuchstaben in Kleinbuchstaben um.\n     * >>> flip_case('Hello')\n     * 'hELLO'\n     */\n    public static String flipCase(String string) {\n        StringBuilder flippedString = new StringBuilder();\n        \n        for (char c : string.toCharArray()) {\n            if (Character.isLowerCase(c)) {\n                flippedString.append(Character.toUpperCase(c));\n            } else if (Character.isUpperCase(c)) {\n                flippedString.append(Character.toLowerCase(c));\n            } else {\n                flippedString.append(c);\n            }\n        }\n        \n        return flippedString.toString();\n    }\n\n    public static void main(String[] args) {\n        // Beispieltestfall\n        String example = \"Hello\";\n        System.out.println(\"Original: \" + example);\n        System.out.println(\"Flip Case: \" + flipCase(example));\n    }\n}"}
{"task_id": "java/8", "language": "java", "completion": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\nclass GetPositive {\n    /**\n     * \n     * Gib nur positive Zahlen in der Liste zur\u00fcck.\n     * >>> get_positive([-1, 2, -4, 5, 6])\n     * [2, 5, 6]\n     * >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n     * [5, 3, 2, 3, 9, 123, 1]\n     *\n     */\n    public static List<Object> getPositive(List<Object> l) {\n        List<Object> positiveNumbers = new ArrayList<>();\n        for (Object num : l) {\n            if (num instanceof Integer && ((Integer) num > 0)) {\n                positiveNumbers.add(num);\n            }\n        }\n        return positiveNumbers;\n    }\n\n    public static void main(String[] args) {\n        List<Object> numbers = Arrays.asList(-1, 2, -4, 5, 6);\n        System.out.println(getPositive(numbers)); // Output: [2, 5, 6]\n\n        List<Object> numbers2 = Arrays.asList(5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10);\n        System.out.println(getPositive(numbers2)); // Output: [5, 3, 2, 3, 9, 123, 1]\n    }\n}"}
{"task_id": "java/9", "language": "java", "completion": "class IsPrime {\n    /**\n     * Gib \"true\" zur\u00fcck, wenn eine gegebene Zahl eine Primzahl ist, andernfalls gib \"false\" zur\u00fcck.\n     * >>> is_prime(6)\n     * False\n     * >>> is_prime(101)\n     * True\n     * >>> is_prime(11)\n     * True\n     * >>> is_prime(13441)\n     * True\n     * >>> is_prime(61)\n     * True\n     * >>> is_prime(4)\n     * False\n     * >>> is_prime(1)\n     * False\n     */\n    public static Boolean isPrime(int n) {\n        if (n <= 1) {\n            return false; // Numbers less than or equal to 1 are not prime numbers.\n        }\n        if (n == 2) {\n            return true; // 2 is the only even prime number.\n        }\n        if (n % 2 == 0) {\n            return false; // Other even numbers are not prime.\n        }\n        for (int i = 3; i <= Math.sqrt(n); i += 2) {\n            if (n % i == 0) {\n                return false; // Found a divisor other than 1 and n itself.\n            }\n        }\n        return true; // No divisors found, so it is a prime number.\n    }\n\n    public static void main(String[] args) {\n        System.out.println(isPrime(6));   // False\n        System.out.println(isPrime(101)); // True\n        System.out.println(isPrime(11));  // True\n        System.out.println(isPrime(13441)); // True\n        System.out.println(isPrime(61));  // True\n        System.out.println(isPrime(4));   // False\n        System.out.println(isPrime(1));   // False\n    }\n}"}
{"task_id": "java/10", "language": "java", "completion": "// Create a new list to store the sorted and unique elements\n        List<Integer> result = new ArrayList<>();\n\n        // Use a Set to ensure uniqueness\n        Set<Integer> uniqueSet = new HashSet<>(l);\n\n        // Convert the set back to a list and sort it\n        result.addAll(uniqueSet);\n        Collections.sort(result);\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        List<Integer> numbers = Arrays.asList(5, 3, 5, 2, 3, 3, 9, 0, 123);\n        System.out.println(unique(numbers)); // Output: [0, 2, 3, 5, 9, 123]\n    }\n}"}
{"task_id": "java/11", "language": "java", "completion": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\nclass PrimeFib {\n    /**\n     * prime_fib gibt die n-te Zahl zur\u00fcck, die sowohl eine Fibonacci-Zahl als auch eine Primzahl ist.\n     * >>> prime_fib(1)\n     * 2\n     * >>> prime_fib(2)\n     * 3\n     * >>> prime_fib(3)\n     * 5\n     * >>> prime_fib(4)\n     * 13\n     * >>> prime_fib(5)\n     * 89\n     */\n    public static int primeFib(int n) {\n        List<Integer> fibPrimes = new ArrayList<>();\n        int a = 0, b = 1;\n        \n        while (fibPrimes.size() < n) {\n            int currentFib = a + b;\n            if (isPrime(currentFib)) {\n                fibPrimes.add(currentFib);\n            }\n            a = b;\n            b = currentFib;\n        }\n        \n        return fibPrimes.get(n - 1);\n    }\n    \n    private static boolean isPrime(int num) {\n        if (num <= 1) {\n            return false;\n        }\n        for (int i = 2; i * i <= num; i++) {\n            if (num % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    \n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        System.out.println(primeFib(n));\n    }\n}"}
{"task_id": "java/12", "language": "java", "completion": "import java.util.*;\n\nclass TriplesSumToZero {\n    public static Boolean triplesSumToZero(List<Integer> l) {\n        // Wenn die Liste weniger als 3 Elemente hat, kann es kein Tripel geben\n        if (l.size() < 3) {\n            return false;\n        }\n        \n        // Sortiere die Liste aufsteigend\n        Collections.sort(l);\n        \n        // Durchlaufe jede m\u00f6gliche Kombination von drei Elementen\n        for (int i = 0; i < l.size() - 2; i++) {\n            int left = i + 1;\n            int right = l.size() - 1;\n            \n            while (left < right) {\n                int sum = l.get(i) + l.get(left) + l.get(right);\n                \n                if (sum == 0) {\n                    return true; // Ein Tripel gefunden, dessen Summe Null ist\n                } else if (sum < 0) {\n                    left++; // Erh\u00f6he die Summe, indem wir das linke Element erh\u00f6hen\n                } else {\n                    right--; // Verringere die Summe, indem wir das rechte Element verringern\n                }\n            }\n        }\n        \n        return false; // Kein Tripel gefunden, dessen Summe Null ist\n    }\n    \n    public static void main(String[] args) {\n        System.out.println(triplesSumToZero(Arrays.asList(1, 3, 5, 0))); // False\n        System.out.println(triplesSumToZero(Arrays.asList(1, 3, -2, 1))); // True\n        System.out.println(triplesSumToZero(Arrays.asList(1, 2, 3, 7))); // False\n        System.out.println(triplesSumToZero(Arrays.asList(2, 4, -5, 3, 9, 7))); // True\n        System.out.println(triplesSumToZero(Arrays.asList(1))); // False\n    }\n}"}
{"task_id": "java/13", "language": "java", "completion": "import java.util.*;\n\nclass PairsSumToZero {\n    /**\n     * pairs_sum_to_zero nimmt eine Liste von ganzen Zahlen als Eingabe.\n     * Es gibt True zur\u00fcck, wenn es zwei unterschiedliche Elemente in der Liste gibt, die sich zu Null addieren, andernfalls gibt es False zur\u00fcck.\n     * >>> pairs_sum_to_zero([1, 3, 5, 0])\n     * False\n     * >>> pairs_sum_to_zero([1, 3, -2, 1])\n     * True\n     * >>> pairs_sum_to_zero([1, 2, 3, 7])\n     * False\n     * >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n     * True\n     * >>> pairs_sum_to_zero([1])\n     * False\n     */\n    public static Boolean pairsSumToZero(List<Integer> l) {\n        // Erstellen Sie einen HashSet, um die Elemente zu speichern\n        Set<Integer> seen = new HashSet<>();\n        \n        // Durchlaufen der Liste\n        for (int num : l) {\n            // \u00dcberpr\u00fcfen, ob das negative von num in den geseeenen Zahlen ist\n            if (seen.contains(-num)) {\n                return true;\n            }\n            // F\u00fcgen Sie num zum HashSet hinzu\n            seen.add(num);\n        }\n        \n        // Wenn keine Paarung gefunden wurde, geben Sie false zur\u00fcck\n        return false;\n    }\n\n    public static void main(String[] args) {\n        List<Integer> list1 = Arrays.asList(1, 3, 5, 0);\n        System.out.println(pairsSumToZero(list1)); // False\n\n        List<Integer> list2 = Arrays.asList(1, 3, -2, 1);\n        System.out.println(pairsSumToZero(list2)); // True\n\n        List<Integer> list3 = Arrays.asList(1, 2, 3, 7);\n        System.out.println(pairsSumToZero(list3)); // False\n\n        List<Integer> list4 = Arrays.asList(2, 4, -5, 3, 5, 7);\n        System.out.println(pairsSumToZero(list4)); // True\n\n        List<Integer> list5 = Arrays.asList(1);\n        System.out.println(pairsSumToZero(list5)); // False\n    }\n}"}
{"task_id": "java/14", "language": "java", "completion": "class Fib4 {\n    public static int fib4(int n) {\n        if (n == 0) return 0;\n        if (n == 1) return 0;\n        if (n == 2) return 2;\n        if (n == 3) return 0;\n\n        // Array zur Speicherung der letzten vier Werte\n        int[] fibArray = new int[n + 1];\n        fibArray[0] = 0;\n        fibArray[1] = 0;\n        fibArray[2] = 2;\n        fibArray[3] = 0;\n\n        // Berechnung der Folge iterativ\n        for (int i = 4; i <= n; i++) {\n            fibArray[i] = fibArray[i - 1] + fibArray[i - 2] + fibArray[i - 3] + fibArray[i - 4];\n        }\n\n        return fibArray[n];\n    }\n\n    public static void main(String[] args) {\n        System.out.println(fib4(5)); // Output: 4\n        System.out.println(fib4(6)); // Output: 8\n        System.out.println(fib4(7)); // Output: 14\n    }\n}"}
{"task_id": "java/15", "language": "java", "completion": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\nclass Median {\n    /**\n     * Gib den Median der Elemente in der Liste l zur\u00fcck.\n     * >>> median([3, 1, 2, 4, 5])\n     * 3\n     * >>> median([-10, 4, 6, 1000, 10, 20])\n     * 15.0\n     */\n    public static Number median(List<Integer> l) {\n        // Sort the list\n        Collections.sort(l);\n        \n        int size = l.size();\n        \n        // If the list has an odd number of elements, return the middle element\n        if (size % 2 == 1) {\n            return l.get(size / 2);\n        } else {\n            // If the list has an even number of elements, return the average of the two middle elements\n            int mid1 = size / 2 - 1;\n            int mid2 = size / 2;\n            double sum = l.get(mid1) + l.get(mid2);\n            return sum / 2;\n        }\n    }\n    \n    public static void main(String[] args) {\n        List<Integer> list1 = Arrays.asList(3, 1, 2, 4, 5);\n        System.out.println(median(list1)); // Output: 3\n        \n        List<Integer> list2 = Arrays.asList(-10, 4, 6, 1000, 10, 20);\n        System.out.println(median(list2)); // Output: 15.0\n    }\n}"}
{"task_id": "java/16", "language": "java", "completion": "if (text == null || text.isEmpty()) {\n            return true; // An empty string or null is considered a palindrome\n        }\n\n        String cleanedText = text.replaceAll(\"[^a-zA-Z0-9]\", \"\").toLowerCase();\n\n        int left = 0;\n        int right = cleanedText.length() - 1;\n\n        while (left < right) {\n            if (cleanedText.charAt(left) != cleanedText.charAt(right)) {\n                return false;\n            }\n            left++;\n            right--;\n        }\n\n        return true;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(isPalindrome(\"\")); // True\n        System.out.println(isPalindrome(\"aba\")); // True\n        System.out.println(isPalindrome(\"aaaaa\")); // True\n        System.out.println(isPalindrome(\"zbcd\")); // False\n    }\n}\n\nThis Java class defines a method `isPalindrome` that checks if a given string is a palindrome. It ignores case and non-alphanumeric characters, making it versatile for various inputs. The main method demonstrates the usage of this method with several test cases."}
{"task_id": "java/17", "language": "java", "completion": "import java.util.*;\n\nclass RemoveVowels {\n    /**\n     * remove_vowels ist eine Funktion, die einen String entgegennimmt und einen String ohne Vokale zur\u00fcckgibt.\n     * >>> remove_vowels('')\n     * ''\n     * >>> remove_vowels(\"abcdef\\nghijklm\")\n     * 'bcdf\\nghjklm'\n     * >>> remove_vowels('abcdef')\n     * 'bcdf'\n     * >>> remove_vowels('aaaaa')\n     * ''\n     * >>> remove_vowels('aaBAA')\n     * 'B'\n     * >>> remove_vowels('zbcd')\n     * 'zbcd'\n     */\n    public static String removeVowels(String text) {\n        if (text == null || text.isEmpty()) {\n            return \"\";\n        }\n        \n        StringBuilder result = new StringBuilder();\n        for (char c : text.toCharArray()) {\n            if (!isVowel(c)) {\n                result.append(c);\n            }\n        }\n        return result.toString();\n    }\n    \n    private static boolean isVowel(char c) {\n        c = Character.toLowerCase(c);\n        return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u';\n    }\n\n    public static void main(String[] args) {\n        System.out.println(removeVowels(\"\")); // ''\n        System.out.println(removeVowels(\"abcdef\\nghijklm\")); // 'bcdf\\nghjklm'\n        System.out.println(removeVowels(\"abcdef\")); // 'bcdf'\n        System.out.println(removeVowels(\"aaaaa\")); // ''\n        System.out.println(removeVowels(\"aaBAA\")); // 'B'\n        System.out.println(removeVowels(\"zbcd\")); // 'zbcd'\n    }\n}"}
{"task_id": "java/18", "language": "java", "completion": "for (int num : l) {\n            if (num >= t) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        List<Integer> list1 = Arrays.asList(1, 2, 4, 10);\n        int threshold1 = 100;\n        System.out.println(belowThreshold(list1, threshold1)); // True\n\n        List<Integer> list2 = Arrays.asList(1, 20, 4, 10);\n        int threshold2 = 5;\n        System.out.println(belowThreshold(list2, threshold2)); // False\n    }\n}"}
{"task_id": "java/19", "language": "java", "completion": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\nclass Add {\n    /**\n     * Adds two numbers x and y.\n     * >>> add(2, 3)\n     * 5\n     * >>> add(5, 7)\n     * 12\n     */\n    public static int add(int x, int y) {\n        return x + y;\n    }\n}"}
{"task_id": "java/20", "language": "java", "completion": "import java.util.*;\n\nclass SameChars {\n    /**\n     * \u00dcberpr\u00fcfen Sie, ob zwei W\u00f6rter dieselben Zeichen enthalten.\n     */\n    public static Boolean sameChars(String s0, String s1) {\n        // Create frequency maps for both strings\n        Map<Character, Integer> freqMap0 = getFrequencyMap(s0);\n        Map<Character, Integer> freqMap1 = getFrequencyMap(s1);\n\n        // Compare the frequency maps\n        return freqMap0.equals(freqMap1);\n    }\n\n    private static Map<Character, Integer> getFrequencyMap(String s) {\n        Map<Character, Integer> freqMap = new HashMap<>();\n        for (char c : s.toCharArray()) {\n            freqMap.put(c, freqMap.getOrDefault(c, 0) + 1);\n        }\n        return freqMap;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(sameChars(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\")); // True\n        System.out.println(sameChars(\"abcd\", \"dddddddabc\")); // True\n        System.out.println(sameChars(\"dddddddabc\", \"abcd\")); // True\n        System.out.println(sameChars(\"eabcd\", \"dddddddabc\")); // False\n        System.out.println(sameChars(\"abcd\", \"dddddddabce\")); // False\n        System.out.println(sameChars(\"eabcdzzzz\", \"dddzzzzzzzddddabc\")); // False\n    }\n}"}
{"task_id": "java/21", "language": "java", "completion": "class Fib {\n    /**\n     * Gib die n-te Fibonacci-Zahl zur\u00fcck.\n     * >>> fib(10)\n     * 55\n     * >>> fib(1)\n     * 1\n     * >>> fib(8)\n     * 21\n     */\n    public static int fib(int n) {\n        if (n <= 0) {\n            throw new IllegalArgumentException(\"Input must be a positive integer.\");\n        }\n        \n        if (n == 1 || n == 2) {\n            return 1;\n        }\n        \n        int a = 1, b = 1;\n        for (int i = 3; i <= n; i++) {\n            int c = a + b;\n            a = b;\n            b = c;\n        }\n        return b;\n    }\n}"}
{"task_id": "java/22", "language": "java", "completion": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\nclass Common {\n    /**\n     * Gib sortierte eindeutige gemeinsame Elemente f\u00fcr zwei Listen zur\u00fcck.\n     * >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n     * [1, 5, 653]\n     * >>> common([5, 3, 2, 8], [3, 2])\n     * [2, 3]\n     */\n    public static List<Object> common(List<Integer> l1, List<Object> l2) {\n        // Convert lists to sets to remove duplicates and facilitate comparison\n        Set<Integer> set1 = new HashSet<>(l1);\n        Set<Object> set2 = new HashSet<>(l2);\n\n        // Find the intersection of the two sets\n        set1.retainAll(set2);\n\n        // Convert the result back to a list and sort it\n        List<Integer> commonList = new ArrayList<>(set1);\n        Collections.sort(commonList);\n\n        return (List<Object>) commonList;\n    }\n\n    public static void main(String[] args) {\n        // Test cases\n        System.out.println(common(Arrays.asList(1, 4, 3, 34, 653, 2, 5), Arrays.asList(5, 7, 1, 5, 9, 653, 121)));\n        System.out.println(common(Arrays.asList(5, 3, 2, 8), Arrays.asList(3, 2)));\n    }\n}"}
{"task_id": "java/23", "language": "java", "completion": "// Initialize the largest prime factor to -1 (assuming all inputs are greater than 1)\n        int largestFactor = -1;\n\n        // Check for smallest prime factor, which is 2\n        while (n % 2 == 0) {\n            largestFactor = 2;\n            n /= 2;\n        }\n\n        // Check for odd factors starting from 3\n        for (int i = 3; i <= Math.sqrt(n); i += 2) {\n            while (n % i == 0) {\n                largestFactor = i;\n                n /= i;\n            }\n        }\n\n        // If n is still greater than 2, then it must be a prime number itself\n        if (n > 2) {\n            largestFactor = n;\n        }\n\n        return largestFactor;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.print(\"Enter a number to find its largest prime factor: \");\n        int number = scanner.nextInt();\n        System.out.println(\"The largest prime factor of \" + number + \" is: \" + largestPrimeFactor(number));\n    }\n}"}
{"task_id": "java/24", "language": "java", "completion": "class SumToN {\n    /**\n     * sum_to_n ist eine Funktion, die Zahlen von 1 bis n summiert.\n     * >>> sum_to_n(30)\n     * 465\n     * >>> sum_to_n(100)\n     * 5050\n     * >>> sum_to_n(5)\n     * 15\n     * >>> sum_to_n(10)\n     * 55\n     * >>> sum_to_n(1)\n     * 1\n     */\n    public static int sumToN(int n) {\n        return (n * (n + 1)) / 2;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        System.out.println(\"Gib eine Zahl ein: \");\n        int number = scanner.nextInt();\n        \n        int result = sumToN(number);\n        System.out.println(\"Die Summe von 1 bis \" + number + \" ist: \" + result);\n    }\n}"}
{"task_id": "java/25", "language": "java", "completion": "import java.util.*;\n\nclass Derivative {\n    /**\n     * \n     * xs repr\u00e4sentieren die Koeffizienten eines Polynoms.\n     *     xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     *     Gib die Ableitung dieses Polynoms in derselben Form zur\u00fcck.\n     * >>> derivative([3, 1, 2, 4, 5])\n     * [1, 4, 12, 20]\n     * >>> derivative([1, 2, 3])\n     * [2, 6]\n     *\n     */\n    public static List<Integer> derivative(List<Integer> xs) {\n        // Create a new list to store the derivatives of the coefficients\n        List<Integer> result = new ArrayList<>();\n        \n        // Iterate through the coefficients and calculate the derivatives\n        for (int i = 1; i < xs.size(); i++) {\n            int coefficient = xs.get(i) * i;\n            result.add(coefficient);\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        // Test cases\n        List<Integer> test1 = Arrays.asList(3, 1, 2, 4, 5);\n        System.out.println(derivative(test1)); // Output: [1, 4, 12, 20]\n        \n        List<Integer> test2 = Arrays.asList(1, 2, 3);\n        System.out.println(derivative(test2)); // Output: [2, 6]\n    }\n}"}
{"task_id": "java/26", "language": "java", "completion": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\nclass Fibfib {\n    /**\n     * Die FibFib-Zahlenfolge ist eine Folge \u00e4hnlich der Fibonacci-Folge, die wie folgt definiert ist:\n     *     fibfib(0) == 0\n     *     fibfib(1) == 0\n     *     fibfib(2) == 1\n     *     fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n     * Bitte schreiben Sie eine Funktion, um das n-te Element der FibFib-Zahlenfolge effizient zu berechnen.\n     */\n    public static int fibfib(int n) {\n        if (n == 0) return 0;\n        if (n == 1) return 0;\n        if (n == 2) return 1;\n\n        // Array zur Speicherung der FibFib-Werte\n        int[] fibfibArray = new int[n + 1];\n        fibfibArray[0] = 0;\n        fibfibArray[1] = 0;\n        fibfibArray[2] = 1;\n\n        // Berechnung der FibFib-Werte iterativ\n        for (int i = 3; i <= n; i++) {\n            fibfibArray[i] = fibfibArray[i - 1] + fibfibArray[i - 2] + fibfibArray[i - 3];\n        }\n\n        return fibfibArray[n];\n    }\n\n    public static void main(String[] args) {\n        // Testf\u00e4lle\n        System.out.println(fibfib(1)); // Ausgabe: 0\n        System.out.println(fibfib(5)); // Ausgabe: 4\n        System.out.println(fibfib(8)); // Ausgabe: 24\n    }\n}"}
{"task_id": "java/27", "language": "java", "completion": "class VowelsCount {\n    /**\n     * \n     * Schreiben Sie eine Funktion vowels_count, die einen String, der ein Wort repr\u00e4sentiert, als Eingabe erh\u00e4lt und die Anzahl der Vokale im String zur\u00fcckgibt. Vokale sind in diesem Fall 'a', 'e', 'i', 'o', 'u'. Hierbei ist 'y' auch ein Vokal, aber nur wenn es am Ende des gegebenen Wortes steht.\n     * \n     * Beispiel:\n     * >>> vowels_count(\"abcde\")\n     * 2\n     * >>> vowels_count(\"ACEDY\")\n     * 3\n     *\n     */\n    public static int vowelsCount(String s) {\n        // Definieren Sie die Vokale\n        String vowels = \"aeiouAEIOU\";\n        int count = 0;\n        \n        // Durchlaufen Sie den String und z\u00e4hlen Sie die Vokale\n        for (char c : s.toCharArray()) {\n            if (vowels.indexOf(c) != -1) {\n                count++;\n            }\n        }\n        \n        return count;\n    }\n\n    public static void main(String[] args) {\n        // Testf\u00e4lle\n        System.out.println(vowelsCount(\"abcde\")); // 2\n        System.out.println(vowelsCount(\"ACEDY\")); // 3\n    }\n}"}
{"task_id": "java/28", "language": "java", "completion": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\nclass Search {\n    /**\n     * * \n     * Sie erhalten eine nicht-leere Liste von positiven Ganzzahlen. Geben Sie die gr\u00f6\u00dfte Ganzzahl zur\u00fcck, die gr\u00f6\u00dfer als Null ist und eine H\u00e4ufigkeit hat, die gr\u00f6\u00dfer oder gleich dem Wert der Ganzzahl selbst ist. Die H\u00e4ufigkeit einer Ganzzahl ist die Anzahl der Male, die sie in der Liste vorkommt. Wenn kein solcher Wert existiert, geben Sie -1 zur\u00fcck. Beispiele:\n     * \n     *     search([4, 1, 2, 2, 3, 1]) == 2\n     *     search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n     *     search([5, 5, 4, 4, 4]) == -1\n     *\n     */\n    public static int search(List<Integer> lst) {\n        // Erstellen Sie eine Map, um die H\u00e4ufigkeit der Zahlen zu z\u00e4hlen\n        Map<Integer, Integer> frequencyMap = new HashMap<>();\n        \n        // Durchlaufen Sie die Liste und aktualisieren Sie die H\u00e4ufigkeitsmap\n        for (int num : lst) {\n            frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);\n        }\n        \n        // Initialisieren Sie die gr\u00f6\u00dfte Zahl mit -1\n        int maxValidNumber = -1;\n        \n        // Durchlaufen Sie die Map und \u00fcberpr\u00fcfen Sie die Bedingung f\u00fcr jede Zahl\n        for (Map.Entry<Integer, Integer> entry : frequencyMap.entrySet()) {\n            int number = entry.getKey();\n            int count = entry.getValue();\n            \n            // Wenn die H\u00e4ufigkeit gr\u00f6\u00dfer oder gleich der Zahl ist und die Zahl gr\u00f6\u00dfer als das aktuelle maxValidNumber, aktualisieren Sie maxValidNumber\n            if (count >= number && number > maxValidNumber) {\n                maxValidNumber = number;\n            }\n        }\n        \n        return maxValidNumber;\n    }\n    \n    public static void main(String[] args) {\n        List<Integer> list1 = Arrays.asList(4, 1, 2, 2, 3, 1);\n        List<Integer> list2 = Arrays.asList(1, 2, 2, 3, 3, 3, 4, 4, 4);\n        List<Integer> list3 = Arrays.asList(5, 5, 4, 4, 4);\n        \n        System.out.println(search(list1)); // Ausgabe: 2\n        System.out.println(search(list2)); // Ausgabe: 3\n        System.out.println(search(list3)); // Ausgabe: -1\n    }\n}"}
{"task_id": "java/29", "language": "java", "completion": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\nclass TriangleArea {\n    /**\n     * \n     * Gegeben sind die L\u00e4ngen der drei Seiten eines Dreiecks. Gib die Fl\u00e4che des Dreiecks auf 2 Dezimalstellen gerundet zur\u00fcck, wenn die drei Seiten ein g\u00fcltiges Dreieck bilden. Andernfalls gib -1 zur\u00fcck. Drei Seiten bilden ein g\u00fcltiges Dreieck, wenn die Summe von zwei Seiten gr\u00f6\u00dfer ist als die dritte Seite. Beispiel:\n     * \n     * triangle_area(3, 4, 5) == 6.00\n     * triangle_area(1, 2, 10) == -1\n     *\n     */\n    public static Number triangleArea(int a, int b, int c) {\n        // \u00dcberpr\u00fcfen, ob die drei Seiten ein g\u00fcltiges Dreieck bilden\n        if (a + b > c && a + c > b && b + c > a) {\n            double s = (a + b + c) / 2.0;\n            double area = Math.sqrt(s * (s - a) * (s - b) * (s - c));\n            return new BigDecimal(area).setScale(2, BigDecimal.ROUND_HALF_UP);\n        } else {\n            return -1;\n        }\n    }\n\n    public static void main(String[] args) {\n        System.out.println(triangleArea(3, 4, 5)); // Ausgabe: 6.00\n        System.out.println(triangleArea(1, 2, 10)); // Ausgabe: -1\n    }\n}"}
{"task_id": "java/30", "language": "java", "completion": "import java.util.*;\n\nclass WillItFly {\n    /**\n     * Schreiben Sie eine Funktion, die True zur\u00fcckgibt, wenn das Objekt q fliegen wird, und False sonst. Das Objekt q wird fliegen, wenn es ausbalanciert ist (es ist eine palindromische Liste) und die Summe seiner Elemente kleiner oder gleich dem maximal m\u00f6glichen Gewicht w ist.\n     * \n     * Beispiel:\n     * will_it_fly([1, 2], 5) \u279e False \n     * # 1+2 ist kleiner als das maximal m\u00f6gliche Gewicht, aber es ist unausgeglichen.\n     * \n     * will_it_fly([3, 2, 3], 1) \u279e False\n     * # es ist ausbalanciert, aber 3+2+3 ist mehr als das maximal m\u00f6gliche Gewicht.\n     * \n     * will_it_fly([3, 2, 3], 9) \u279e True\n     * # 3+2+3 ist kleiner als das maximal m\u00f6gliche Gewicht, und es ist ausbalanciert.\n     * \n     * will_it_fly([3], 5) \u279e True\n     * # 3 ist kleiner als das maximal m\u00f6gliche Gewicht, und es ist ausbalanciert.\n     */\n    public static Boolean willItFly(List<Integer> q, int w) {\n        // \u00dcberpr\u00fcfen, ob die Liste ein Palindrom ist\n        boolean isPalindrome = true;\n        for (int i = 0; i < q.size() / 2; i++) {\n            if (!q.get(i).equals(q.get(q.size() - 1 - i))) {\n                isPalindrome = false;\n                break;\n            }\n        }\n        \n        // Berechnen der Summe der Elemente in der Liste\n        int sum = 0;\n        for (int num : q) {\n            sum += num;\n        }\n        \n        // \u00dcberpr\u00fcfen, ob die Summe kleiner oder gleich dem maximalen Gewicht ist\n        return isPalindrome && sum <= w;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(willItFly(Arrays.asList(1, 2), 5)); // False\n        System.out.println(willItFly(Arrays.asList(3, 2, 3), 1)); // False\n        System.out.println(willItFly(Arrays.asList(3, 2, 3), 9)); // True\n        System.out.println(willItFly(Arrays.asList(3), 5)); // True\n    }\n}"}
{"task_id": "java/31", "language": "java", "completion": "import java.util.*;\n\nclass IsMultiplyPrime {\n    /**\n     * \n     * Schreiben Sie eine Funktion, die true zur\u00fcckgibt, wenn die gegebene Zahl das Produkt von 3 Primzahlen ist, und false sonst. Dabei ist bekannt, dass (a) kleiner als 100 ist. Beispiel:\n     * \n     * is_multiply_prime(30) == True\n     * 30 = 2 * 3 * 5\n     *\n     */\n    public static Boolean isMultiplyPrime(int a) {\n        // Liste der Primzahlen bis zur Wurzel von a\n        List<Integer> primes = getPrimesUpToSqrt(a);\n        \n        // \u00dcberpr\u00fcfen, ob das Produkt von drei Primzahlen gleich a ist\n        for (int i = 0; i < primes.size(); i++) {\n            for (int j = i; j < primes.size(); j++) {\n                for (int k = j; k < primes.size(); k++) {\n                    if (primes.get(i) * primes.get(j) * primes.get(k) == a) {\n                        return true;\n                    }\n                }\n            }\n        }\n        \n        return false;\n    }\n    \n    // Hilfsfunktion, um Primzahlen bis zur Wurzel von a zu finden\n    private static List<Integer> getPrimesUpToSqrt(int a) {\n        List<Integer> primes = new ArrayList<>();\n        for (int i = 2; i * i <= a; i++) {\n            if (isPrime(i)) {\n                primes.add(i);\n            }\n        }\n        return primes;\n    }\n    \n    // Hilfsfunktion, um zu pr\u00fcfen, ob eine Zahl eine Primzahl ist\n    private static boolean isPrime(int num) {\n        if (num <= 1) {\n            return false;\n        }\n        for (int i = 2; i * i <= num; i++) {\n            if (num % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    \n    public static void main(String[] args) {\n        System.out.println(isMultiplyPrime(30)); // True, da 30 = 2 * 3 * 5\n        System.out.println(isMultiplyPrime(60)); // False, da keine drei Primzahlen existieren, die 60 ergeben\n    }\n}"}
{"task_id": "java/32", "language": "java", "completion": "class DecimalToBinary {\n    /**\n     * \n     * Sie erhalten eine Zahl in Dezimalform und Ihre Aufgabe besteht darin, sie in das Bin\u00e4rformat umzuwandeln. Die Funktion sollte einen String zur\u00fcckgeben, wobei jedes Zeichen eine Bin\u00e4rzahl darstellt. Jedes Zeichen im String wird '0' oder '1' sein.\n     * \n     * Es wird ein zus\u00e4tzliches Paar von Zeichen 'db' am Anfang und am Ende des Strings geben. Die zus\u00e4tzlichen zeichen dienen zur Formatierungshilfe.\n     * \n     * Beispiele:\n     * \n     * decimal_to_binary(15)   # returns \"db1111db\"\n     * decimal_to_binary(32)   # returns \"db100000db\"\n     *\n     */\n    public static String decimalToBinary(int decimal) {\n        // Wandeln Sie die Dezimalzahl in eine Bin\u00e4rzahl um\n        String binaryString = Integer.toBinaryString(decimal);\n        \n        // F\u00fcgen Sie die zus\u00e4tzlichen Zeichen 'db' am Anfang und Ende des Strings hinzu\n        return \"db\" + binaryString + \"db\";\n    }\n\n    public static void main(String[] args) {\n        // Testbeispiele\n        System.out.println(decimalToBinary(15));  // Ausgabe: db1111db\n        System.out.println(decimalToBinary(32));  // Ausgabe: db100000db\n    }\n}"}
{"task_id": "java/33", "language": "java", "completion": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\nclass IsHappy {\n    /**\n     * \n     * Du erh\u00e4ltst einen String s.\n     * Deine Aufgabe ist es zu \u00fcberpr\u00fcfen, ob der String gl\u00fccklich ist oder nicht.\n     * Ein String ist gl\u00fccklich, wenn seine L\u00e4nge mindestens 3 betr\u00e4gt und jede Gruppe von 3 aufeinanderfolgenden Buchstaben unterschiedlich sind.\n     * Zum Beispiel:\n     * \n     * is_happy(a) => False\n     * is_happy(aa) => False\n     * is_happy(abcd) => True\n     * is_happy(aabb) => False\n     * is_happy(adb) => True\n     * is_happy(xyy) => False\n     *\n     */\n    public static Boolean isHappy(String s) {\n        // \u00dcberpr\u00fcfen, ob die L\u00e4nge des Strings mindestens 3 ist\n        if (s.length() < 3) {\n            return false;\n        }\n        \n        // Durchlaufen des Strings und \u00fcberpr\u00fcfen der Gruppen von 3 aufeinanderfolgenden Buchstaben\n        for (int i = 0; i <= s.length() - 3; i++) {\n            String group = s.substring(i, i + 3);\n            // \u00dcberpr\u00fcfen, ob die Gruppe von 3 aufeinanderfolgenden Buchstaben unterschiedlich sind\n            for (int j = i + 1; j <= s.length() - 3; j++) {\n                String otherGroup = s.substring(j, j + 3);\n                if (group.equals(otherGroup)) {\n                    return false;\n                }\n            }\n        }\n        \n        // Wenn alle Gruppen von 3 aufeinanderfolgenden Buchstaben unterschiedlich sind, ist der String gl\u00fccklich\n        return true;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(isHappy(\"a\")); // False\n        System.out.println(isHappy(\"aa\")); // False\n        System.out.println(isHappy(\"abcd\")); // True\n        System.out.println(isHappy(\"aabb\")); // False\n        System.out.println(isHappy(\"adb\")); // True\n        System.out.println(isHappy(\"xyy\")); // False\n    }\n}"}
{"task_id": "java/34", "language": "java", "completion": "// Implementieren Sie die Funktion hier\n        List<String> letterGrades = new ArrayList<>();\n        for (Number grade : grades) {\n            double gpa = grade.doubleValue();\n            if (gpa == 4.0) {\n                letterGrades.add(\"A+\");\n            } else if (gpa > 3.7) {\n                letterGrades.add(\"A\");\n            } else if (gpa > 3.3) {\n                letterGrades.add(\"A-\");\n            } else if (gpa > 3.0) {\n                letterGrades.add(\"B+\");\n            } else if (gpa > 2.7) {\n                letterGrades.add(\"B\");\n            } else if (gpa > 2.3) {\n                letterGrades.add(\"B-\");\n            } else if (gpa > 2.0) {\n                letterGrades.add(\"C+\");\n            } else if (gpa > 1.7) {\n                letterGrades.add(\"C\");\n            } else if (gpa > 1.3) {\n                letterGrades.add(\"C-\");\n            } else if (gpa > 1.0) {\n                letterGrades.add(\"D+\");\n            } else if (gpa > 0.7) {\n                letterGrades.add(\"D\");\n            } else if (gpa > 0.0) {\n                letterGrades.add(\"D-\");\n            } else {\n                letterGrades.add(\"E\");\n            }\n        }\n        return letterGrades;\n    }\n\n    public static void main(String[] args) {\n        List<Number> grades = Arrays.asList(4.0, 3.0, 1.7, 2.0, 3.5);\n        System.out.println(numericalLetterGrade(grades)); // Ausgabe: ['A+', 'B', 'C-', 'C', 'A-']\n    }\n}"}
{"task_id": "java/35", "language": "java", "completion": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\nclass PrimeLength {\n    /**\n     * Schreiben Sie eine Funktion, die einen String entgegennimmt und True zur\u00fcckgibt, wenn die L\u00e4nge des Strings eine Primzahl ist, andernfalls False.\n     * Beispiele:\n     * prime_length('Hello') == True\n     * prime_length('abcdcba') == True\n     * prime_length('kittens') == True\n     * prime_length('orange') == False\n     */\n    public static Boolean primeLength(String string) {\n        int length = string.length();\n        if (length <= 1) {\n            return false;\n        }\n        for (int i = 2; i <= Math.sqrt(length); i++) {\n            if (length % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(primeLength(\"Hello\")); // True\n        System.out.println(primeLength(\"abcdcba\")); // True\n        System.out.println(primeLength(\"kittens\")); // True\n        System.out.println(primeLength(\"orange\")); // False\n    }\n}"}
{"task_id": "java/36", "language": "java", "completion": "import java.util.*;\n\nclass Solve {\n    /**\n     * Gegeben eine positive Ganzzahl N, gib die Gesamtsumme ihrer Ziffern in bin\u00e4rer Form zur\u00fcck.\n     */\n    public static String solve(int n) {\n        // 1. Wandle die Zahl N in ihre Bin\u00e4rdarstellung um\n        String binaryString = Integer.toBinaryString(n);\n        \n        // 2. Berechne die Summe der Bin\u00e4rziffern\n        int sum = 0;\n        for (char c : binaryString.toCharArray()) {\n            if (c == '1') {\n                sum += 1;\n            }\n        }\n        \n        // 3. Gib die Summe als bin\u00e4re Zeichenkette zur\u00fcck\n        return Integer.toBinaryString(sum);\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        System.out.println(solve(n));\n    }\n}"}
{"task_id": "java/37", "language": "java", "completion": "import java.util.*;\n\nclass GetRow {\n    public static List<Object> getRow(List<Object> lst, int x) {\n        List<Tuple> coordinates = new ArrayList<>();\n        \n        // Iterate through each row in the list\n        for (int i = 0; i < lst.size(); i++) {\n            List<Integer> row = (List<Integer>) lst.get(i);\n            // Iterate through each element in the row\n            for (int j = 0; j < row.size(); j++) {\n                if (row.get(j) == x) {\n                    coordinates.add(new Tuple(i, j));\n                }\n            }\n        }\n        \n        // Sort the list of tuples first by row index in ascending order, then by column index in descending order\n        coordinates.sort((a, b) -> {\n            if (a.row != b.row) {\n                return Integer.compare(a.row, b.row);\n            } else {\n                return Integer.compare(b.col, a.col);\n            }\n        });\n        \n        // Convert the list of tuples to a list of lists (as required by the problem statement)\n        List<Object> result = new ArrayList<>();\n        for (Tuple t : coordinates) {\n            result.add(Arrays.asList(t.row, t.col));\n        }\n        \n        return result;\n    }\n    \n    // Helper class to store row and column indices as a tuple\n    static class Tuple {\n        int row;\n        int col;\n        \n        Tuple(int row, int col) {\n            this.row = row;\n            this.col = col;\n        }\n    }\n    \n    public static void main(String[] args) {\n        System.out.println(getRow(Arrays.asList(\n                Arrays.asList(1, 2, 3, 4, 5, 6),\n                Arrays.asList(1, 2, 3, 4, 1, 6),\n                Arrays.asList(1, 2, 3, 4, 5, 1)\n        ), 1)); // Output: [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n        \n        System.out.println(getRow(Arrays.asList(), 1)); // Output: []\n        \n        System.out.println(getRow(Arrays.asList(\n                Arrays.asList(),\n                Arrays.asList(1),\n                Arrays.asList(1, 2, 3)\n        ), 3)); // Output: [(2, 2)]\n    }\n}"}
{"task_id": "java/38", "language": "java", "completion": "import java.util.*;\n\nclass NextSmallest {\n    /**\n     * \n     * Sie erhalten eine Liste von ganzen Zahlen.\n     * Schreiben Sie eine Funktion next_smallest(), die das zweitkleinste Element der Liste zur\u00fcckgibt.\n     * Geben Sie null zur\u00fcck, wenn es kein solches Element gibt.\n     * next_smallest([1, 2, 3, 4, 5]) == 2\n     * next_smallest([5, 1, 4, 3, 2]) == 2\n     * next_smallest([]) == None\n     * next_smallest([1, 1]) == None\n     *\n     */\n    public static Integer nextSmallest(List<Integer> lst) {\n        if (lst == null || lst.size() < 2) {\n            return null;\n        }\n        \n        // Use a TreeSet to automatically handle duplicates and maintain sorted order\n        Set<Integer> set = new TreeSet<>(lst);\n        \n        // Convert the set back to a list and get the second element\n        List<Integer> sortedList = new ArrayList<>(set);\n        \n        if (sortedList.size() < 2) {\n            return null;\n        }\n        \n        return sortedList.get(1);\n    }\n\n    public static void main(String[] args) {\n        System.out.println(nextSmallest(Arrays.asList(1, 2, 3, 4, 5))); // Output: 2\n        System.out.println(nextSmallest(Arrays.asList(5, 1, 4, 3, 2))); // Output: 2\n        System.out.println(nextSmallest(new ArrayList<>())); // Output: null\n        System.out.println(nextSmallest(Arrays.asList(1, 1))); // Output: null\n    }\n}"}
{"task_id": "java/39", "language": "java", "completion": "// Split the input string by sentence-ending punctuation marks ('.', '?', '!')\n        String[] sentences = s.split(\"[.?!]\");\n        \n        // Initialize a counter for bored sentences\n        int count = 0;\n        \n        // Iterate through each sentence\n        for (String sentence : sentences) {\n            // Trim leading and trailing whitespace from the sentence\n            sentence = sentence.trim();\n            \n            // Check if the sentence starts with \"Ich\"\n            if (sentence.startsWith(\"Ich\")) {\n                count++;\n            }\n        }\n        \n        return count;\n    }\n    \n    public static void main(String[] args) {\n        System.out.println(isBored(\"Hello world\")); // Output: 0\n        System.out.println(isBored(\"The sky is blue. The sun is shining. I love this weather\")); // Output: 1\n    }\n}"}
{"task_id": "java/40", "language": "java", "completion": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\nclass Skjkasdkd {\n    /**\n     * \n     * Sie erhalten eine Liste von ganzen Zahlen.\n     *     Sie m\u00fcssen den gr\u00f6\u00dften Primzahlwert finden und die Summe seiner Ziffern zur\u00fcckgeben.\n     * \n     *     Beispiele:\n     * \n     * For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n     * For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n     * For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n     * For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n     * For lst = [0,81,12,3,1,21] the output should be 3\n     * For lst = [0,8,1,2,1,7] the output should be 7\n     *\n     */\n    public static int skjkasdkd(List<Integer> lst) {\n        // Helper function to check if a number is prime\n        boolean isPrime(int num) {\n            if (num <= 1) return false;\n            if (num == 2) return true;\n            if (num % 2 == 0) return false;\n            for (int i = 3; i * i <= num; i += 2) {\n                if (num % i == 0) return false;\n            }\n            return true;\n        }\n\n        // Find the largest prime number in the list\n        int maxPrime = -1;\n        for (int num : lst) {\n            if (isPrime(num) && num > maxPrime) {\n                maxPrime = num;\n            }\n        }\n\n        // If no prime number is found, return 0\n        if (maxPrime == -1) return 0;\n\n        // Calculate the sum of the digits of the largest prime number\n        int sumOfDigits = 0;\n        while (maxPrime > 0) {\n            sumOfDigits += maxPrime % 10;\n            maxPrime /= 10;\n        }\n\n        return sumOfDigits;\n    }\n\n    public static void main(String[] args) {\n        List<Integer> lst1 = Arrays.asList(0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3);\n        System.out.println(skjkasdkd(lst1)); // Output: 10\n\n        List<Integer> lst2 = Arrays.asList(1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1);\n        System.out.println(skjkasdkd(lst2)); // Output: 25\n\n        List<Integer> lst3 = Arrays.asList(1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3);\n        System.out.println(skjkasdkd(lst3)); // Output: 13\n\n        List<Integer> lst4 = Arrays.asList(0,724,32,71,99,32,6,0,5,91,83,0,5,6);\n        System.out.println(skjkasdkd(lst4)); // Output: 11\n\n        List<Integer> lst5 = Arrays.asList(0,81,12,3,1,21);\n        System.out.println(skjkasdkd(lst5)); // Output: 3\n\n        List<Integer> lst6 = Arrays.asList(0,8,1,2,1,7);\n        System.out.println(skjkasdkd(lst6)); // Output: 7\n    }\n}"}
{"task_id": "java/41", "language": "java", "completion": "// Check if the dictionary is empty\n        if (dict == null || ((Map<?, ?>) dict).isEmpty()) {\n            return false;\n        }\n\n        // Cast the dictionary to a Map\n        Map<String, String> map = (Map<String, String>) dict;\n\n        // Check all keys in the dictionary\n        for (String key : map.keySet()) {\n            if (!key.equals(key.toLowerCase()) && !key.equals(key.toUpperCase())) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    public static void main(String[] args) {\n        // Test cases\n        Map<String, String> dict1 = new HashMap<>();\n        dict1.put(\"a\", \"apple\");\n        dict1.put(\"b\", \"banana\");\n        System.out.println(checkDictCase(dict1)); // should return True\n\n        Map<String, String> dict2 = new HashMap<>();\n        dict2.put(\"a\", \"apple\");\n        dict2.put(\"A\", \"banana\");\n        dict2.put(\"B\", \"banana\");\n        System.out.println(checkDictCase(dict2)); // should return False\n\n        Map<String, String> dict3 = new HashMap<>();\n        dict3.put(\"a\", \"apple\");\n        dict3.put(8, \"banana\");\n        dict3.put(\"a\", \"apple\");\n        System.out.println(checkDictCase(dict3)); // should return False\n\n        Map<String, String> dict4 = new HashMap<>();\n        dict4.put(\"Name\", \"John\");\n        dict4.put(\"Age\", \"36\");\n        dict4.put(\"City\", \"Houston\");\n        System.out.println(checkDictCase(dict4)); // should return False\n\n        Map<String, String> dict5 = new HashMap<>();\n        dict5.put(\"STATE\", \"NC\");\n        dict5.put(\"ZIP\", \"12345\");\n        System.out.println(checkDictCase(dict5)); // should return True\n    }\n}"}
{"task_id": "java/42", "language": "java", "completion": "import java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\nclass ClosestInteger {\n    /**\n     * \n     * Erstellen Sie eine Funktion, die einen Wert (String) annimmt, der eine Zahl darstellt, und gibt die n\u00e4chstgelegene Ganzzahl zur\u00fcck. Wenn die Zahl gleich weit von zwei Ganzzahlen entfernt ist, runden Sie sie weg von Null.\n     * \n     *     Beispiele\n     * >>> closest_integer(\"10\")\n     * 10\n     * >>> closest_integer(\"15.3\")\n     * 15\n\n     * Note:\n     * Rounding away from zero means that if the given number is equidistant\n     * from two integers, the one you should return is the one that is the\n     * farthest from zero. For example closest_integer(\"14.5\") should\n     * return 15 and closest_integer(\"-14.5\") should return -15.\n     *\n     */\n    public static int closestInteger(String value) {\n        // Parse the string to a BigDecimal for precise arithmetic operations\n        BigDecimal num = new BigDecimal(value);\n        \n        // If the number is already an integer, just return it as an int\n        if (num.scale() == 0) {\n            return num.intValue();\n        }\n        \n        // Find the two nearest integers\n        int lower = num.intValue();\n        int upper = lower + 1;\n        \n        // Calculate the distances to the lower and upper integers\n        double distanceToLower = Math.abs(num.doubleValue() - lower);\n        double distanceToUpper = Math.abs(num.doubleValue() - upper);\n        \n        // Rounding away from zero if equidistant\n        if (distanceToLower == distanceToUpper) {\n            return num.doubleValue() > 0 ? upper : lower;\n        }\n        \n        // Return the nearest integer\n        return distanceToLower < distanceToUpper ? lower : upper;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(closestInteger(\"10\"));     // Output: 10\n        System.out.println(closestInteger(\"15.3\"));   // Output: 15\n        System.out.println(closestInteger(\"14.5\"));   // Output: 15\n        System.out.println(closestInteger(\"-14.5\"));  // Output: -15\n    }\n}"}
{"task_id": "java/43", "language": "java", "completion": "import java.util.*;\n\nclass MakeAPile {\n    public static List<Integer> makeAPile(int n) {\n        List<Integer> pile = new ArrayList<>();\n        \n        // Start with the given number of stones for the first level\n        int currentLevel = n;\n        \n        // Loop to generate each subsequent level\n        for (int i = 0; i < n; i++) {\n            pile.add(currentLevel);\n            \n            // Determine the next level based on whether the current level is odd or even\n            if (currentLevel % 2 == 0) {\n                // If the current level is even, find the next even number\n                currentLevel += 2;\n            } else {\n                // If the current level is odd, find the next odd number\n                currentLevel += 2;\n            }\n        }\n        \n        return pile;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(makeAPile(3)); // Output: [3, 5, 7]\n        System.out.println(makeAPile(4)); // Output: [4, 6, 8, 10]\n    }\n}"}
{"task_id": "java/44", "language": "java", "completion": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\nclass WordsString {\n    /**\n     * * \n     * Sie erhalten einen String von W\u00f6rtern, die durch Kommas oder Leerzeichen getrennt sind. Ihre Aufgabe ist es, den String in W\u00f6rter aufzuteilen und ein Array der W\u00f6rter zur\u00fcckzugeben.\n     * \n     * Zum Beispiel:\n     * \n     * words_string(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n     * words_string(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n     *\n     */\n    public static List<String> wordsString(String s) {\n        // Erstellen Sie eine Liste, um die W\u00f6rter zu speichern\n        List<String> wordsList = new ArrayList<>();\n        \n        // Split the string by spaces and commas to get individual words\n        String[] wordsArray = s.split(\"[ ,]+\");\n        \n        // Add each word from the array to the list\n        for (String word : wordsArray) {\n            wordsList.add(word);\n        }\n        \n        return wordsList;\n    }\n\n    public static void main(String[] args) {\n        // Test cases\n        System.out.println(wordsString(\"Hi, my name is John\")); // [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n        System.out.println(wordsString(\"One, two, three, four, five, six\")); // [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    }\n}"}
{"task_id": "java/45", "language": "java", "completion": "// \u00dcberpr\u00fcfen, ob die Zahlen korrekt sind und in der richtigen Reihenfolge vorliegen\n        if (x > y) {\n            return -1;\n        }\n\n        // Iterieren vom gr\u00f6\u00dferen Wert zur\u00fcck zum kleineren Wert\n        for (int i = y; i >= x; i--) {\n            // \u00dcberpr\u00fcfen, ob die Zahl gerade ist\n            if (i % 2 == 0) {\n                return i;\n            }\n        }\n\n        // Wenn keine gerade Zahl gefunden wird, gib -1 zur\u00fcck\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        System.out.print(\"Geben Sie die erste Zahl ein: \");\n        int x = scanner.nextInt();\n\n        System.out.print(\"Geben Sie die zweite Zahl ein: \");\n        int y = scanner.nextInt();\n\n        int result = chooseNum(x, y);\n        if (result != -1) {\n            System.out.println(\"Die gr\u00f6\u00dfte gerade Zahl im Bereich [\" + x + \", \" + y + \"] ist: \" + result);\n        } else {\n            System.out.println(\"Es gibt keine gerade Zahl im Bereich [\" + x + \", \" + y + \"].\");\n        }\n    }\n}\n\n// Diese Funktion nimmt zwei positive Zahlen x und y entgegen und gibt die gr\u00f6\u00dfte gerade Zahl zur\u00fcck, die im Bereich [x, y] enthalten ist. Wenn es keine solche Zahl gibt, sollte die Funktion -1 zur\u00fcckgeben.\n// \n// Beispiel:\n// choose_num(12, 15) = 14\n// choose_num(13, 12) = -1"}
{"task_id": "java/46", "language": "java", "completion": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\nclass RoundedAvg {\n    /**\n     * \n     * Sie erhalten zwei positive Ganzzahlen n und m. Ihre Aufgabe besteht darin, den Durchschnitt der Ganzzahlen von n bis m (einschlie\u00dflich n und m) zu berechnen. Runden Sie die Antwort auf die n\u00e4chste Ganzzahl und konvertieren Sie diese in bin\u00e4r. Wenn n gr\u00f6\u00dfer als m ist, geben Sie -1 zur\u00fcck. Beispiel:\n     * \n     * rounded_avg(1, 5) => \"0b11\"\n     * rounded_avg(7, 5) => -1\n     * rounded_avg(10, 20) => \"0b1111\"\n     * rounded_avg(20, 33) => \"0b11010\"\n     *\n     */\n    public static Object roundedAvg(int n, int m) {\n        if (n > m) {\n            return -1;\n        }\n        \n        long sum = 0;\n        for (int i = n; i <= m; i++) {\n            sum += i;\n        }\n        \n        double avgDouble = (double)sum / (m - n + 1);\n        int avgInt = (int)Math.round(avgDouble);\n        \n        String binaryString = Integer.toBinaryString(avgInt);\n        \n        return \"0b\" + binaryString;\n    }\n    \n    public static void main(String[] args) {\n        System.out.println(roundedAvg(1, 5)); // \"0b11\"\n        System.out.println(roundedAvg(7, 5)); // -1\n        System.out.println(roundedAvg(10, 20)); // \"0b1111\"\n        System.out.println(roundedAvg(20, 33)); // \"0b11010\"\n    }\n}"}
{"task_id": "java/47", "language": "java", "completion": "import java.util.*;\n\nclass F {\n    public static List<Integer> f(int n) {\n        List<Integer> result = new ArrayList<>();\n        \n        for (int i = 1; i <= n; i++) {\n            if (i % 2 == 0) {\n                // Berechne die Fakult\u00e4t von i\n                int factorial = 1;\n                for (int j = 1; j <= i; j++) {\n                    factorial *= j;\n                }\n                result.add(factorial);\n            } else {\n                // Berechne die Summe der Zahlen von 1 bis i\n                int sum = 0;\n                for (int j = 1; j <= i; j++) {\n                    sum += j;\n                }\n                result.add(sum);\n            }\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(f(5)); // Ausgabe: [1, 2, 6, 24, 15]\n    }\n}"}
{"task_id": "java/48", "language": "java", "completion": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\nclass EvenOddPalindrome {\n    /**\n     * Gegeben eine positive ganze Zahl n, gibt eine Tupel zur\u00fcck, das die Anzahl der geraden und ungeraden ganzen Palindrome enth\u00e4lt, die im Bereich (1, n) einschlie\u00dflich liegen.\n     */\n    public static List<Integer> evenOddPalindrome(int n) {\n        int evenCount = 0;\n        int oddCount = 0;\n        \n        for (int i = 1; i <= n; i++) {\n            if (isPalindrome(i)) {\n                if (i % 2 == 0) {\n                    evenCount++;\n                } else {\n                    oddCount++;\n                }\n            }\n        }\n        \n        List<Integer> result = new ArrayList<>();\n        result.add(evenCount);\n        result.add(oddCount);\n        return result;\n    }\n    \n    /**\n     * Pr\u00fcft, ob eine Zahl ein Palindrom ist.\n     */\n    private static boolean isPalindrome(int number) {\n        String str = Integer.toString(number);\n        int len = str.length();\n        for (int i = 0; i < len / 2; i++) {\n            if (str.charAt(i) != str.charAt(len - 1 - i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    \n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        List<Integer> result = evenOddPalindrome(n);\n        System.out.println(\"Even count: \" + result.get(0) + \", Odd count: \" + result.get(1));\n    }\n}"}
{"task_id": "java/49", "language": "java", "completion": "import java.util.*;\n\nclass MoveOneBall {\n    /**\n     * Wir haben ein Array 'arr' mit N ganzen Zahlen arr[1], arr[2], ..., arr[N]. Die Zahlen im Array werden zuf\u00e4llig angeordnet sein. Deine Aufgabe besteht darin zu bestimmen, ob es m\u00f6glich ist, ein Array in nicht abnehmender Reihenfolge zu sortieren, indem du die folgende Operation auf das gegebene Array anwendest:\n     * Du darfst beliebig oft eine Rechtsschiebeoperation durchf\u00fchren.\n     * Eine Rechtsschiebeoperation bedeutet, dass alle Elemente des Arrays um eine Position in Richtung rechts verschoben werden. Das letzte Element des Arrays wird an die Startposition im Array verschoben, d.h. an den Index 0.\n     * \n     * Wenn es m\u00f6glich ist, das sortierte Array durch Ausf\u00fchren der oben genannten Operation zu erhalten, gib True zur\u00fcck, sonst gib False zur\u00fcck.\n     * Wenn das gegebene Array leer ist, gib True zur\u00fcck.\n     * \n     * Hinweis: Die gegebene Liste hat garantiert eindeutige Elemente.\n     * \n     * Zum Beispiel:\n     * \n     * move_one_ball([3, 4, 5, 1, 2])==>True\n     * Erkl\u00e4rung: Durch Ausf\u00fchren von 2 Rechtsschiebeoperationen kann die nicht abnehmende Reihenfolge f\u00fcr das gegebene Array erreicht werden.\n     * move_one_ball([3, 5, 4, 1, 2])==>False\n     * Erkl\u00e4rung: Es ist nicht m\u00f6glich, die nicht abnehmende Reihenfolge f\u00fcr das gegebene Array durch Ausf\u00fchren beliebiger Anzahl von Rechtsschiebeoperationen zu erhalten.\n     * \n     */\n    public static Boolean moveOneBall(List<Integer> arr) {\n        if (arr == null || arr.isEmpty()) {\n            return true;\n        }\n        \n        int n = arr.size();\n        // Check if the array is already sorted\n        boolean isSorted = true;\n        for (int i = 1; i < n; i++) {\n            if (arr.get(i) < arr.get(i - 1)) {\n                isSorted = false;\n                break;\n            }\n        }\n        \n        if (isSorted) {\n            return true;\n        }\n        \n        // Try all possible shifts and check if the array can be sorted\n        for (int shift = 0; shift < n; shift++) {\n            boolean canSort = true;\n            for (int i = 1; i < n; i++) {\n                if (arr.get((i - shift) % n) > arr.get((i - shift + 1) % n)) {\n                    canSort = false;\n                    break;\n                }\n            }\n            if (canSort) {\n                return true;\n            }\n        }\n        \n        return false;\n    }\n    \n    public static void main(String[] args) {\n        List<Integer> arr1 = Arrays.asList(3, 4, 5, 1, 2);\n        List<Integer> arr2 = Arrays.asList(3, 5, 4, 1, 2);\n        \n        System.out.println(moveOneBall(arr1)); // True\n        System.out.println(moveOneBall(arr2)); // False\n    }\n}"}
{"task_id": "java/50", "language": "java", "completion": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\nclass Exchange {\n    public static String exchange(List<Integer> lst1, List<Integer> lst2) {\n        // Pr\u00fcfen, ob alle Elemente in lst1 gerade sind\n        for (int num : lst1) {\n            if (num % 2 != 0) {\n                // Wenn ein ungerades Element gefunden wird, versuchen wir es aus lst2 zu entfernen\n                lst2.remove(Integer.valueOf(num));\n            }\n        }\n        \n        // Pr\u00fcfen, ob nach dem Entfernen alle Elemente in lst1 gerade sind\n        for (int num : lst1) {\n            if (num % 2 != 0) {\n                return \"NO\";\n            }\n        }\n        \n        return \"YES\";\n    }\n    \n    public static void main(String[] args) {\n        System.out.println(exchange(Arrays.asList(1, 2, 3, 4), Arrays.asList(1, 2, 3, 4))); // Output: YES\n        System.out.println(exchange(Arrays.asList(1, 2, 3, 4), Arrays.asList(1, 5, 3, 4))); // Output: NO\n    }\n}"}
{"task_id": "java/51", "language": "java", "completion": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\nclass ReverseDelete {\n    /**\n     * \n     * Aufgabe\n     *     Wir haben zwei Zeichenketten s und c. Du musst alle Zeichen in s l\u00f6schen, die einem Zeichen in c entsprechen.\n     *     Dann musst du \u00fcberpr\u00fcfen, ob die resultierende Zeichenkette ein Palindrom ist.\n     *     Eine Zeichenkette ist ein Palindrom, wenn sie r\u00fcckw\u00e4rts gelesen genauso aussieht wie vorw\u00e4rts.\n     *     Du solltest ein Tupel zur\u00fcckgeben, das die resultierende Zeichenkette und True/False f\u00fcr die \u00dcberpr\u00fcfung enth\u00e4lt.\n     *     Beispiel\n     *     F\u00fcr s = \"abcde\", c = \"ae\" sollte das Ergebnis ('bcd',False) sein.\n     *     F\u00fcr s = \"abcdef\", c = \"b\" sollte das Ergebnis ('acdef',False) sein.\n     *     F\u00fcr s = \"abcdedcba\", c = \"ab\" sollte das Ergebnis ('cdedc',True) sein.\n     * \n     *\n     */\n    public static List<Object> reverseDelete(String s, String c) {\n        // StringBuilder to store the result after removing characters in 'c' from 's'\n        StringBuilder result = new StringBuilder();\n        \n        // Set to keep track of characters in 'c' for fast lookup\n        HashSet<Character> charsToRemove = new HashSet<>();\n        for (char ch : c.toCharArray()) {\n            charsToRemove.add(ch);\n        }\n        \n        // Remove characters from 's' that are present in 'charsToRemove'\n        for (char ch : s.toCharArray()) {\n            if (!charsToRemove.contains(ch)) {\n                result.append(ch);\n            }\n        }\n        \n        // Check if the resulting string is a palindrome\n        boolean isPalindrome = checkPalindrome(result.toString());\n        \n        // Return the result as a list of objects\n        List<Object> resultList = new ArrayList<>();\n        resultList.add(result.toString());\n        resultList.add(isPalindrome);\n        \n        return resultList;\n    }\n    \n    // Helper method to check if a string is a palindrome\n    private static boolean checkPalindrome(String str) {\n        int left = 0;\n        int right = str.length() - 1;\n        \n        while (left < right) {\n            if (str.charAt(left) != str.charAt(right)) {\n                return false;\n            }\n            left++;\n            right--;\n        }\n        \n        return true;\n    }\n    \n    public static void main(String[] args) {\n        // Test cases\n        System.out.println(reverseDelete(\"abcde\", \"ae\")); // Output: ['bcd', False]\n        System.out.println(reverseDelete(\"abcdef\", \"b\")); // Output: ['acdef', False]\n        System.out.println(reverseDelete(\"abcdedcba\", \"ab\")); // Output: ['cdedc', True]\n    }\n}"}
{"task_id": "java/52", "language": "java", "completion": "import java.util.*;\n\nclass MaxFill {\n    public static int maxFill(List<List<Integer>> grid, int capacity) {\n        int totalWater = 0;\n        \n        // Berechne die Gesamtmenge an Wasser im Gitter\n        for (List<Integer> row : grid) {\n            for (int water : row) {\n                if (water == 1) {\n                    totalWater++;\n                }\n            }\n        }\n        \n        // Berechne die ben\u00f6tigte Anzahl von Eimern\n        int fillsNeeded = (totalWater + capacity - 1) / capacity; // ceiling division\n        \n        return fillsNeeded;\n    }\n    \n    public static void main(String[] args) {\n        List<List<Integer>> grid1 = Arrays.asList(\n            Arrays.asList(0, 0, 1, 0),\n            Arrays.asList(0, 1, 0, 0),\n            Arrays.asList(1, 1, 1, 1)\n        );\n        System.out.println(maxFill(grid1, 1)); // Output: 6\n        \n        List<List<Integer>> grid2 = Arrays.asList(\n            Arrays.asList(0, 0, 1, 1),\n            Arrays.asList(0, 0, 0, 0),\n            Arrays.asList(1, 1, 1, 1),\n            Arrays.asList(0, 1, 1, 1)\n        );\n        System.out.println(maxFill(grid2, 2)); // Output: 5\n        \n        List<List<Integer>> grid3 = Arrays.asList(\n            Arrays.asList(0, 0, 0),\n            Arrays.asList(0, 0, 0)\n        );\n        System.out.println(maxFill(grid3, 5)); // Output: 0\n    }\n}"}
{"task_id": "java/53", "language": "java", "completion": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\nclass SelectWords {\n    /**\n     * \n     * Gegeben eine Zeichenkette s und eine nat\u00fcrliche Zahl n, wurde Ihnen die Aufgabe zugewiesen, eine Funktion zu implementieren, die eine Liste aller W\u00f6rter aus der Zeichenkette s zur\u00fcckgibt, die genau n Konsonanten enthalten, in der Reihenfolge, in der diese W\u00f6rter in der Zeichenkette s erscheinen. Wenn die Zeichenkette s leer ist, sollte die Funktion eine leere Liste zur\u00fcckgeben. Hinweis: Sie k\u00f6nnen davon ausgehen, dass die Eingabezeichenkette nur Buchstaben und Leerzeichen enth\u00e4lt. Beispiele:\n     * \n     * select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n     * select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n     * select_words(\"simple white space\", 2) ==> []\n     * select_words(\"Hello world\", 4) ==> [\"world\"]\n     * select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\n     *\n     */\n    public static List<Object> selectWords(String s, int n) {\n        if (s == null || s.isEmpty()) {\n            return new ArrayList<>();\n        }\n\n        String[] words = s.split(\" \");\n        List<Object> result = new ArrayList<>();\n\n        for (String word : words) {\n            if (countConsonants(word) == n) {\n                result.add(word);\n            }\n        }\n\n        return result;\n    }\n\n    private static int countConsonants(String word) {\n        String consonants = word.replaceAll(\"[aeiouAEIOU ]\", \"\");\n        return consonants.length();\n    }\n\n    public static void main(String[] args) {\n        System.out.println(selectWords(\"Mary had a little lamb\", 4)); // [\"little\"]\n        System.out.println(selectWords(\"Mary had a little lamb\", 3)); // [\"Mary\", \"lamb\"]\n        System.out.println(selectWords(\"simple white space\", 2)); // []\n        System.out.println(selectWords(\"Hello world\", 4)); // [\"world\"]\n        System.out.println(selectWords(\"Uncle sam\", 3)); // [\"Uncle\"]\n    }\n}"}
{"task_id": "java/54", "language": "java", "completion": "// Sortiere das Array in absteigender Reihenfolge\n        Collections.sort(arr, Collections.reverseOrder());\n\n        // W\u00e4hle die ersten k Elemente aus dem sortierten Array\n        List<Integer> result = new ArrayList<>();\n        for (int i = 0; i < k && i < arr.size(); i++) {\n            result.add(arr.get(i));\n        }\n\n        // Sortiere die Ergebnisliste aufsteigend und wandle sie in eine Liste von Objekten um\n        Collections.sort(result);\n        return new ArrayList<>(result);\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        System.out.print(\"Geben Sie die Elemente des Arrays (durch Leerzeichen getrennt) ein: \");\n        String input = scanner.nextLine();\n        String[] elements = input.split(\" \");\n        List<Integer> arr = new ArrayList<>();\n        for (String element : elements) {\n            arr.add(Integer.parseInt(element));\n        }\n\n        System.out.print(\"Geben Sie die Zahl k ein: \");\n        int k = scanner.nextInt();\n\n        List<Object> result = maximum(arr, k);\n        System.out.println(\"Die sortierte Liste der \" + k + \" gr\u00f6\u00dften Zahlen ist: \" + result);\n    }\n}"}
{"task_id": "java/55", "language": "java", "completion": "// \u00dcberpr\u00fcfen, ob die L\u00e4nge des Arrays innerhalb der erlaubten Grenzen liegt\n        if (arr == null || arr.size() < 1 || arr.size() > 100) {\n            throw new IllegalArgumentException(\"Array length must be between 1 and 100\");\n        }\n\n        // \u00dcberpr\u00fcfen, ob k innerhalb der erlaubten Grenzen liegt\n        if (k < 1 || k > arr.size()) {\n            throw new IllegalArgumentException(\"k must be between 1 and the size of the array\");\n        }\n\n        int sum = 0;\n        for (int i = 0; i < k; i++) {\n            // \u00dcberpr\u00fcfen, ob das Element zwei Ziffern hat\n            if (String.valueOf(arr.get(i)).length() <= 2) {\n                sum += arr.get(i);\n            }\n        }\n\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        List<Integer> arr = Arrays.asList(111, 21, 3, 4000, 5, 6, 7, 8, 9);\n        int k = 4;\n        System.out.println(addElements(arr, k)); // Ausgabe: 24\n    }\n}"}
{"task_id": "java/56", "language": "java", "completion": "import java.util.*;\n\nclass Intersection {\n    /**\n     * \n     * Sie erhalten zwei Intervalle,\n     *     wobei jedes Intervall ein Paar von ganzen Zahlen ist. Zum Beispiel, Intervall = (start, end) = (1, 2).\n     *     Die gegebenen Intervalle sind geschlossen, was bedeutet, dass das Intervall (start, end)\n     *     sowohl start als auch end einschlie\u00dft.\n     *     F\u00fcr jedes gegebene Intervall wird angenommen, dass sein Start kleiner oder gleich seinem Ende ist.\n     *     Ihre Aufgabe ist es zu bestimmen, ob die L\u00e4nge des Schnitts dieser beiden\n     *     Intervalle eine Primzahl ist.\n     *     Zum Beispiel ist der Schnitt der Intervalle (1, 3), (2, 4) (2, 3),\n     *     dessen L\u00e4nge 1 ist, was keine Primzahl ist.\n     *     Wenn die L\u00e4nge des Schnitts eine Primzahl ist, geben Sie \"YES\" zur\u00fcck,\n     *     andernfalls geben Sie \"NO\" zur\u00fcck.\n     *     Wenn sich die beiden Intervalle nicht \u00fcberschneiden, geben Sie \"NO\" zur\u00fcck.\n     * \n     *     [Eingabe/Ausgabe] Beispiele:\n     * \n     * intersection((1, 2), (2, 3)) ==> \"NO\"\n     * intersection((-1, 1), (0, 4)) ==> \"NO\"\n     * intersection((-3, -1), (-5, 5)) ==> \"YES\"\n     *\n     */\n    public static String intersection(List<Integer> interval1, List<Integer> interval2) {\n        int start1 = interval1.get(0);\n        int end1 = interval1.get(1);\n        int start2 = interval2.get(0);\n        int end2 = interval2.get(1);\n\n        // Find the intersection of the two intervals\n        int intersectStart = Math.max(start1, start2);\n        int intersectEnd = Math.min(end1, end2);\n\n        // If there is no intersection, return \"NO\"\n        if (intersectStart > intersectEnd) {\n            return \"NO\";\n        }\n\n        // Calculate the length of the intersection\n        int intersectLength = intersectEnd - intersectStart + 1;\n\n        // Check if the length is a prime number\n        if (isPrime(intersectLength)) {\n            return \"YES\";\n        } else {\n            return \"NO\";\n        }\n    }\n\n    // Helper method to check if a number is prime\n    private static boolean isPrime(int num) {\n        if (num <= 1) {\n            return false;\n        }\n        for (int i = 2; i * i <= num; i++) {\n            if (num % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        // Test cases\n        System.out.println(intersection(Arrays.asList(1, 2), Arrays.asList(2, 3))); // \"NO\"\n        System.out.println(intersection(Arrays.asList(-1, 1), Arrays.asList(0, 4))); // \"NO\"\n        System.out.println(intersection(Arrays.asList(-3, -1), Arrays.asList(-5, 5))); // \"YES\"\n    }\n}"}
{"task_id": "java/57", "language": "java", "completion": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\nclass Tri {\n    /**\n     * \n     * Jeder kennt die Fibonacci-Folge, die in den letzten Jahrhunderten von Mathematikern tiefgehend untersucht wurde. Was die meisten Menschen jedoch nicht wissen, ist die Tribonacci-Folge. Die Tribonacci-Folge wird durch die Rekursion definiert: tri(1) = 3 tri(n) = 1 + n / 2, wenn n gerade ist. tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), wenn n ungerade ist. Zum Beispiel: tri(2) = 1 + (2 / 2) = 2 tri(4) = 3 tri(3) = tri(2) + tri(1) + tri(4) = 2 + 3 + 3 = 8 Sie erhalten eine nicht-negative ganze Zahl n und m\u00fcssen eine Liste der ersten n + 1 Zahlen der Tribonacci-Folge zur\u00fcckgeben. Beispiele: tri(3) = [1, 3, 2, 8]\n     * \n     *\n     */\n    public static List<Number> tri(int n) {\n        // Erstellen einer Liste zur Speicherung der Tribonacci-Folge\n        List<Number> result = new ArrayList<>();\n        \n        // Rekursive Funktion zur Berechnung der Tribonacci-Folge\n        for (int i = 0; i <= n; i++) {\n            result.add(calculateTribonacci(i));\n        }\n        \n        return result;\n    }\n    \n    private static int calculateTribonacci(int n) {\n        if (n == 0) {\n            return 1; // Tribonacci von 0 ist definiert als 1\n        } else if (n == 1) {\n            return 3; // Tribonacci von 1 ist definiert als 3\n        } else if (n % 2 == 0) {\n            return 1 + n / 2; // Wenn n gerade ist, berechne nach der gegebenen Formel\n        } else {\n            return calculateTribonacci(n - 1) + calculateTribonacci(n - 2) + calculateTribonacci(n + 1); // Wenn n ungerade ist, rekursiv berechnen\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        List<Number> result = tri(n);\n        System.out.println(result);\n    }\n}"}
{"task_id": "java/58", "language": "java", "completion": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\nclass Digits {\n    /**\n     * Gegeben eine positive ganze Zahl n, gib das Produkt der ungeraden Ziffern zur\u00fcck.\n     * Gib 0 zur\u00fcck, wenn alle Ziffern gerade sind.\n     */\n    public static int digits(int n) {\n        // Wandeln Sie die Zahl in eine Zeichenkette um, um die einzelnen Ziffern zu betrachten\n        String numStr = Integer.toString(n);\n        \n        // Initialisieren Sie das Produkt der ungeraden Ziffern\n        int product = 1;\n        \n        // Durchlaufen Sie jede Ziffer in der Zeichenkette\n        for (int i = 0; i < numStr.length(); i++) {\n            char digitChar = numStr.charAt(i);\n            int digit = Character.getNumericValue(digitChar);\n            \n            // Pr\u00fcfen Sie, ob die Ziffer ungerade ist\n            if (digit % 2 != 0) {\n                product *= digit;\n            }\n        }\n        \n        // Wenn das Produkt gleich 1 ist und mindestens eine ungerade Ziffer gefunden wurde,\n        // dann sind alle Ziffern ungerade. Andernfalls gibt es keine ungeraden Ziffern.\n        if (product == 1 && n % 2 != 0) {\n            return product;\n        } else {\n            return 0;\n        }\n    }\n\n    public static void main(String[] args) {\n        // Testf\u00e4lle\n        System.out.println(digits(1));   // Ausgabe: 1\n        System.out.println(digits(4));   // Ausgabe: 0\n        System.out.println(digits(235)); // Ausgabe: 15\n    }\n}"}
{"task_id": "java/59", "language": "java", "completion": "import java.util.Stack;\n\nclass IsNested {\n    /**\n     * Erstellen Sie eine Funktion, die einen String als Eingabe erh\u00e4lt, der nur eckige Klammern enth\u00e4lt. Die Funktion sollte True zur\u00fcckgeben, wenn und nur wenn es eine g\u00fcltige Teilfolge von Klammern gibt, bei der mindestens eine Klammer in der Teilfolge verschachtelt ist.\n     * is_nested('[[]]') \u279e True\n     * is_nested('[]]]]]]][[[[[]') \u279e False\n     * is_nested('[][]') \u279e False\n     * is_nested('[]') \u279e False\n     * is_nested('[[][]]') \u279e True\n     * is_nested('[[]][[') \u279e True\n     */\n    public static Boolean isNested(String string) {\n        // Wenn die Zeichenfolge null oder leer ist, gib false zur\u00fcck\n        if (string == null || string.isEmpty()) {\n            return false;\n        }\n\n        Stack<Character> stack = new Stack<>();\n        \n        for (char ch : string.toCharArray()) {\n            if (ch == '[') {\n                // Wenn eine \u00f6ffnende Klammer gefunden wird, legen Sie sie auf den Stack ab\n                stack.push(ch);\n            } else if (ch == ']') {\n                // Wenn eine schlie\u00dfende Klammer gefunden wird, pr\u00fcfen Sie, ob der Stack nicht leer ist und die letzte \u00f6ffnende Klammer entfernt werden kann\n                if (!stack.isEmpty()) {\n                    stack.pop();\n                } else {\n                    // Wenn der Stack leer ist, bedeutet dies, dass es keine \u00fcbereinstimmende \u00f6ffnende Klammer gibt\n                    return false;\n                }\n            }\n        }\n        \n        // Wenn der Stack am Ende noch Elemente enth\u00e4lt, bedeutet dies, dass nicht alle \u00f6ffnenden Klammern geschlossen wurden\n        return stack.isEmpty();\n    }\n\n    public static void main(String[] args) {\n        System.out.println(isNested(\"[[]]\")); // True\n        System.out.println(isNested(\"[]]]]]]][[[[[]\")); // False\n        System.out.println(isNested(\"[][]\")); // False\n        System.out.println(isNested(\"[]\")); // False\n        System.out.println(isNested(\"[[][]]\")); // True\n        System.out.println(isNested(\"[[]][[\")); // True\n    }\n}"}
{"task_id": "java/60", "language": "java", "completion": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\nclass SumSquares {\n    /**\n     * \n     * Sie erhalten eine Liste von Zahlen.\n     * Sie m\u00fcssen die Summe der quadrierten Zahlen in der gegebenen Liste zur\u00fcckgeben,\n     * runden Sie jedes Element in der Liste zuerst auf die n\u00e4chste Ganzzahl (Ceiling).\n     * Beispiele:\n     * F\u00fcr lst = [1,2,3] sollte die Ausgabe 14 sein\n     * F\u00fcr lst = [1,4,9] sollte die Ausgabe 98 sein\n     * F\u00fcr lst = [1,3,5,7] sollte die Ausgabe 84 sein\n     * F\u00fcr lst = [1.4,4.2,0] sollte die Ausgabe 29 sein\n     * F\u00fcr lst = [-2.4,1,1] sollte die Ausgabe 6 sein\n     * \n     * \n     */\n    public static int sumSquares(List<Number> lst) {\n        int sum = 0;\n        for (Number num : lst) {\n            // Runden auf die n\u00e4chste Ganzzahl (Ceiling)\n            double roundedNum = Math.ceil(num.doubleValue());\n            // Quadrieren und zur Summe addieren\n            sum += Math.pow((int)roundedNum, 2);\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        List<Number> lst1 = Arrays.asList(1, 2, 3);\n        List<Number> lst2 = Arrays.asList(1, 4, 9);\n        List<Number> lst3 = Arrays.asList(1, 3, 5, 7);\n        List<Number> lst4 = Arrays.asList(1.4, 4.2, 0);\n        List<Number> lst5 = Arrays.asList(-2.4, 1, 1);\n\n        System.out.println(\"Sum of squares for lst1: \" + sumSquares(lst1)); // Output: 14\n        System.out.println(\"Sum of squares for lst2: \" + sumSquares(lst2)); // Output: 98\n        System.out.println(\"Sum of squares for lst3: \" + sumSquares(lst3)); // Output: 84\n        System.out.println(\"Sum of squares for lst4: \" + sumSquares(lst4)); // Output: 29\n        System.out.println(\"Sum of squares for lst5: \" + sumSquares(lst5)); // Output: 6\n    }\n}"}
{"task_id": "java/61", "language": "java", "completion": "// Check if the string is empty or null\n        if (txt == null || txt.isEmpty()) {\n            return false;\n        }\n\n        // Remove trailing spaces from the string\n        String trimmedTxt = txt.trim();\n\n        // Get the last character of the trimmed string\n        char lastChar = trimmedTxt.charAt(trimmedTxt.length() - 1);\n\n        // Check if the last character is a letter and not part of a word\n        return Character.isLetter(lastChar) && !Character.isLetterOrDigit(lastChar);\n    }\n\n    public static void main(String[] args) {\n        System.out.println(checkIfLastCharIsALetter(\"apple pie\")); // \u279e False\n        System.out.println(checkIfLastCharIsALetter(\"apple pi e\")); // \u279e True\n        System.out.println(checkIfLastCharIsALetter(\"apple pi e \")); // \u279e False\n        System.out.println(checkIfLastCharIsALetter(\"\")); // \u279e False\n    }\n}"}
{"task_id": "java/62", "language": "java", "completion": "import java.util.*;\n\nclass CanArrange {\n    /**\n     * \n     * Erstellen Sie eine Funktion, die den gr\u00f6\u00dften Index eines Elements zur\u00fcckgibt, das nicht gr\u00f6\u00dfer oder gleich dem unmittelbar vorhergehenden Element ist. Wenn kein solches Element vorhanden ist, geben Sie -1 zur\u00fcck. Das gegebene Array enth\u00e4lt keine doppelten Werte.\n     * \n     * Beispiele:\n     * \n     * can_arrange([1,2,4,3,5]) = 3\n     * can_arrange([1,2,3]) = -1\n     *\n     */\n    public static int canArrange(List<Object> arr) {\n        // \u00dcberpr\u00fcfen, ob die Liste leer ist\n        if (arr == null || arr.isEmpty()) {\n            return -1;\n        }\n\n        // Durchlaufen der Liste von vorne nach hinten\n        for (int i = arr.size() - 1; i > 0; i--) {\n            // Vergleichen des aktuellen Elements mit dem vorherigen Element\n            if ((int)arr.get(i) < (int)arr.get(i - 1)) {\n                return i;\n            }\n        }\n\n        // Wenn kein solches Element gefunden wurde, geben wir -1 zur\u00fcck\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        List<Object> arr1 = Arrays.asList(1, 2, 4, 3, 5);\n        List<Object> arr2 = Arrays.asList(1, 2, 3);\n        \n        System.out.println(canArrange(arr1)); // Ausgabe: 3\n        System.out.println(canArrange(arr2)); // Ausgabe: -1\n    }\n}"}
{"task_id": "java/63", "language": "java", "completion": "// Hier ist der Code zur L\u00f6sung der Aufgabe. Wir initialisieren die gr\u00f6\u00dfte negative Zahl und die kleinste positive Zahl mit Null, da wir sp\u00e4ter pr\u00fcfen m\u00fcssen, ob diese Werte tats\u00e4chlich ge\u00e4ndert wurden.\n        Integer largestNegative = null;\n        Integer smallestPositive = null;\n\n        // Wir iterieren \u00fcber die Liste und aktualisieren die gr\u00f6\u00dften/kleinesten Werte basierend auf den Elementen der Liste.\n        for (Object obj : lst) {\n            if (obj instanceof Integer) {\n                int num = (Integer) obj;\n                if (num < 0) {\n                    if (largestNegative == null || num > largestNegative) {\n                        largestNegative = num;\n                    }\n                } else if (num > 0) {\n                    if (smallestPositive == null || num < smallestPositive) {\n                        smallestPositive = num;\n                    }\n                }\n            }\n        }\n\n        // Wir erstellen eine Liste, um die Ergebnisse zur\u00fcckzugeben.\n        List<Integer> result = new ArrayList<>();\n        if (largestNegative != null) {\n            result.add(largestNegative);\n        } else {\n            result.add(null);\n        }\n        if (smallestPositive != null) {\n            result.add(smallestPositive);\n        } else {\n            result.add(null);\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        // Testf\u00e4lle\n        System.out.println(largestSmallestIntegers(Arrays.asList(2, 4, 1, 3, 5, 7))); // (None, 1)\n        System.out.println(largestSmallestIntegers(new ArrayList<>())); // (None, None)\n        System.out.println(largestSmallestIntegers(Arrays.asList(0))); // (None, None)\n    }\n}"}
{"task_id": "java/64", "language": "java", "completion": "import java.math.BigInteger;\n\nclass SpecialFactorial {\n    /**\n     * Die brasilianische Fakult\u00e4t ist definiert als:\n     *     brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n     *     wobei n > 0\n     *\n     * Beispiel:\n     * >>> specialFactorial(4)\n     * 288\n     */\n    public static long specialFactorial(int n) {\n        if (n <= 0) {\n            throw new IllegalArgumentException(\"Der Wert von n muss gr\u00f6\u00dfer als 0 sein.\");\n        }\n\n        BigInteger result = BigInteger.ONE;\n\n        for (int i = 1; i <= n; i++) {\n            result = result.multiply(factorial(i));\n        }\n\n        return Long.parseLong(result.toString());\n    }\n\n    private static BigInteger factorial(int num) {\n        BigInteger fact = BigInteger.ONE;\n        for (int i = 1; i <= num; i++) {\n            fact = fact.multiply(BigInteger.valueOf(i));\n        }\n        return fact;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.print(\"Geben Sie eine Zahl ein: \");\n        int n = scanner.nextInt();\n        long result = specialFactorial(n);\n        System.out.println(\"Die spezielle Fakult\u00e4t von \" + n + \" ist: \" + result);\n    }\n}"}
{"task_id": "java/65", "language": "java", "completion": "import java.util.*;\n\nclass WordsInSentence {\n    /**\n     * Du erh\u00e4ltst einen String, der einen Satz repr\u00e4sentiert. Der Satz enth\u00e4lt einige W\u00f6rter, die durch ein Leerzeichen getrennt sind. Du musst einen String zur\u00fcckgeben, der die W\u00f6rter aus dem urspr\u00fcnglichen Satz enth\u00e4lt, deren L\u00e4ngen Primzahlen sind. Die Reihenfolge der W\u00f6rter im neuen String sollte dieselbe wie im Original sein.\n     * \n     * Beispiel 1:\n     *     Eingabe: sentence = \"This is a test\"\n     *     Ausgabe: \"is\"\n     * \n     * Beispiel 2:\n     *     Eingabe: sentence = \"lets go for swimming\"\n     *     Ausgabe: \"go for\"\n     * \n     * Einschr\u00e4nkungen:\n     *     * 1 <= len(sentence) <= 100\n     *     * Der Satz enth\u00e4lt nur Buchstaben.\n     */\n    public static String wordsInSentence(String sentence) {\n        // Teilen Sie den Satz in W\u00f6rter auf\n        String[] words = sentence.split(\" \");\n        \n        // Erstellen Sie eine Liste, um die W\u00f6rter mit Primzahl-L\u00e4ngen zu speichern\n        List<String> resultWords = new ArrayList<>();\n        \n        for (String word : words) {\n            int length = word.length();\n            if (isPrime(length)) {\n                resultWords.add(word);\n            }\n        }\n        \n        // Verbinden Sie die gefundenen W\u00f6rter mit Leerzeichen und geben Sie sie zur\u00fcck\n        return String.join(\" \", resultWords);\n    }\n    \n    // Hilfsfunktion, um zu \u00fcberpr\u00fcfen, ob eine Zahl eine Primzahl ist\n    private static boolean isPrime(int num) {\n        if (num <= 1) {\n            return false;\n        }\n        for (int i = 2; i * i <= num; i++) {\n            if (num % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    \n    public static void main(String[] args) {\n        // Testf\u00e4lle\n        System.out.println(wordsInSentence(\"This is a test\")); // Ausgabe: \"is\"\n        System.out.println(wordsInSentence(\"lets go for swimming\")); // Ausgabe: \"go for\"\n    }\n}"}
{"task_id": "java/66", "language": "java", "completion": "import java.util.Scanner;\n\nclass Simplify {\n    /**\n     * \n     * Deine Aufgabe ist es, eine Funktion zu implementieren, die den Ausdruck x * n vereinfacht. Die Funktion gibt True zur\u00fcck, wenn x * n zu einer ganzen Zahl ausgewertet wird, andernfalls False. Sowohl x als auch n sind Zeichenketten, die eine Bruchzahl darstellen und das folgende Format haben: <Z\u00e4hler>/<Nenner>, wobei sowohl Z\u00e4hler als auch Nenner positive ganze Zahlen sind.\n     * \n     * Du kannst davon ausgehen, dass x und n g\u00fcltige Bruchzahlen sind und keinen Nenner von Null haben.\n     * simplify(\"1/5\", \"5/1\") = True\n     * simplify(\"1/6\", \"2/1\") = False\n     * simplify(\"7/10\", \"10/2\") = False\n     *\n     */\n    public static Boolean simplify(String x, String n) {\n        // Teilen der Zeichenketten in Z\u00e4hler und Nenner auf\n        String[] partsX = x.split(\"/\");\n        String[] partsN = n.split(\"/\");\n        \n        // Umwandlung der Teile in ganze Zahlen\n        int numeratorX = Integer.parseInt(partsX[0]);\n        int denominatorX = Integer.parseInt(partsX[1]);\n        int numeratorN = Integer.parseInt(partsN[0]);\n        int denominatorN = Integer.parseInt(partsN[1]);\n        \n        // Berechnung des Produkts der beiden Bruchzahlen\n        int resultNumerator = numeratorX * numeratorN;\n        int resultDenominator = denominatorX * denominatorN;\n        \n        // Pr\u00fcfung, ob das Ergebnis eine ganze Zahl ist\n        return (resultNumerator % resultDenominator == 0);\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        System.out.println(\"Gib den ersten Bruch ein: \");\n        String x = scanner.nextLine();\n        \n        System.out.println(\"Gib den zweiten Bruch ein: \");\n        String n = scanner.nextLine();\n        \n        boolean result = simplify(x, n);\n        System.out.println(result);\n    }\n}"}
{"task_id": "java/67", "language": "java", "completion": "import java.util.*;\n\nclass OrderByPoints {\n    /**\n     * Schreiben Sie eine Funktion, die die gegebene Liste von Ganzzahlen\n     * in aufsteigender Reihenfolge nach der Summe ihrer Ziffern sortiert.\n     * Hinweis: Wenn es mehrere Elemente mit \u00e4hnlicher Summe ihrer Ziffern gibt,\n     * ordnen Sie sie basierend auf ihrem Index in der Originalliste.\n     */\n    public static List<Integer> orderByPoints(List<Integer> nums) {\n        // Erstellen einer Liste von Paaren (num, sumOfDigits)\n        List<Pair> pairs = new ArrayList<>();\n        for (int i = 0; i < nums.size(); i++) {\n            int num = nums.get(i);\n            int sumOfDigits = sumDigits(num);\n            pairs.add(new Pair(num, sumOfDigits, i));\n        }\n\n        // Sortieren der Paare basierend auf der Summe der Ziffern und dem Index\n        pairs.sort((a, b) -> {\n            if (a.sumOfDigits != b.sumOfDigits) {\n                return Integer.compare(a.sumOfDigits, b.sumOfDigits);\n            } else {\n                return Integer.compare(a.index, b.index);\n            }\n        });\n\n        // Extrahieren der sortierten Zahlen in eine neue Liste\n        List<Integer> sortedNums = new ArrayList<>();\n        for (Pair pair : pairs) {\n            sortedNums.add(pair.num);\n        }\n\n        return sortedNums;\n    }\n\n    // Hilfsklasse f\u00fcr Paare von Zahl und Summe ihrer Ziffern\n    private static class Pair {\n        int num;\n        int sumOfDigits;\n        int index;\n\n        Pair(int num, int sumOfDigits, int index) {\n            this.num = num;\n            this.sumOfDigits = sumOfDigits;\n            this.index = index;\n        }\n    }\n\n    // Hilfsmethode zur Berechnung der Summe der Ziffern einer Zahl\n    private static int sumDigits(int num) {\n        int sum = 0;\n        num = Math.abs(num); // Nur die Betragszahl verwenden\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        List<Integer> numbers = Arrays.asList(1, 11, -1, -11, -12);\n        System.out.println(orderByPoints(numbers)); // Output: [-1, -11, 1, -12, 11]\n    }\n}"}
{"task_id": "java/68", "language": "java", "completion": "import java.util.*;\n\nclass Specialfilter {\n    /**\n     * Schreiben Sie eine Funktion, die ein Array von Zahlen als Eingabe erh\u00e4lt und die Anzahl der Elemente im Array zur\u00fcckgibt, die gr\u00f6\u00dfer als 10 sind und bei denen sowohl die erste als auch die letzte Ziffer der Zahl ungerade sind (1, 3, 5, 7, 9).\n     * \n     * specialFilter([15, -73, 14, -15]) => 1 \n     * specialFilter([33, -2, -3, 45, 21, 109]) => 2\n     */\n    public static int specialfilter(List<Object> nums) {\n        int count = 0;\n        \n        for (Object num : nums) {\n            if (num instanceof Integer) {\n                int number = (Integer) num;\n                \n                // Check if the number is greater than 10\n                if (Math.abs(number) > 10) {\n                    \n                    // Convert the number to a string to check the last digit\n                    String strNum = Integer.toString(Math.abs(number));\n                    int lastDigit = Character.getNumericValue(strNum.charAt(strNum.length() - 1));\n                    \n                    // Check if the first and last digits are odd\n                    if (isOdd(Character.getNumericValue(strNum.charAt(0))) && isOdd(lastDigit)) {\n                        count++;\n                    }\n                }\n            }\n        }\n        \n        return count;\n    }\n    \n    // Helper method to check if a number is odd\n    private static boolean isOdd(int num) {\n        return num % 2 != 0;\n    }\n\n    public static void main(String[] args) {\n        List<Object> list1 = Arrays.asList(15, -73, 14, -15);\n        System.out.println(specialfilter(list1)); // Output: 1\n        \n        List<Object> list2 = Arrays.asList(33, -2, -3, 45, 21, 109);\n        System.out.println(specialfilter(list2)); // Output: 2\n    }\n}"}
{"task_id": "java/69", "language": "java", "completion": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\nclass GetMaxTriples {\n    /**\n     * * \n     * Sie erhalten eine positive ganze Zahl n. Sie m\u00fcssen ein Integer-Array a der L\u00e4nge n erstellen.\n     *         F\u00fcr jedes i (1 \u2264 i \u2264 n) gilt: a[i] = i * i - i + 1.\n     *         Geben Sie die Anzahl der Tripel (a[i], a[j], a[k]) von a zur\u00fcck, bei denen i < j < k gilt und a[i] + a[j] + a[k] ein Vielfaches von 3 ist.\n     * \n     *     Beispiel:\n     *         Eingabe: n = 5\n     *         Ausgabe: 1\n     *         Erkl\u00e4rung:\n     *         a = [1, 3, 7, 13, 21]\n     *         Das einzige g\u00fcltige Tripel ist (1, 7, 13).\n     * \n     *\n     */\n    public static int getMaxTriples(int n) {\n        // Erstellen Sie das Array a\n        int[] a = new int[n + 1];\n        for (int i = 1; i <= n; i++) {\n            a[i] = i * i - i + 1;\n        }\n\n        // Z\u00e4hlen der g\u00fcltigen Tripel\n        int count = 0;\n        for (int i = 1; i <= n - 2; i++) {\n            for (int j = i + 1; j <= n - 1; j++) {\n                for (int k = j + 1; k <= n; k++) {\n                    if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                        count++;\n                    }\n                }\n            }\n        }\n\n        return count;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        System.out.println(getMaxTriples(n));\n    }\n}"}
{"task_id": "java/70", "language": "java", "completion": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\nclass Bf {\n    /**\n     * Es gibt acht Planeten in unserem Sonnensystem: Der Sonne am n\u00e4chsten ist Merkur, dann folgen Venus, die Erde, Mars, Jupiter, Saturn, Uranus und Neptun. Schreiben Sie eine Funktion, die zwei Planetennamen als Zeichenketten planet1 und planet2 annimmt. Die Funktion sollte ein Tupel zur\u00fcckgeben, das alle Planeten enth\u00e4lt, deren Umlaufbahnen zwischen der Umlaufbahn von Planet1 und der Umlaufbahn von Planet2 liegen und nach N\u00e4he zur Sonne sortiert sind. Die Funktion sollte ein leeres Tupel zur\u00fcckgeben, wenn planet1 oder planet2 keine korrekten Planetennamen sind. Beispiele:\n     * \n     * bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n     * bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n     * bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n     */\n    public static List<Object> bf(String planet1, String planet2) {\n        // Map of planets to their distance from the Sun\n        Map<String, Integer> planetDistanceMap = new HashMap<>();\n        planetDistanceMap.put(\"Mercury\", 1);\n        planetDistanceMap.put(\"Venus\", 2);\n        planetDistanceMap.put(\"Earth\", 3);\n        planetDistanceMap.put(\"Mars\", 4);\n        planetDistanceMap.put(\"Jupiter\", 5);\n        planetDistanceMap.put(\"Saturn\", 6);\n        planetDistanceMap.put(\"Uranus\", 7);\n        planetDistanceMap.put(\"Neptune\", 8);\n        \n        // Check if both planets are valid\n        if (!planetDistanceMap.containsKey(planet1) || !planetDistanceMap.containsKey(planet2)) {\n            return new ArrayList<>();\n        }\n        \n        int distance1 = planetDistanceMap.get(planet1);\n        int distance2 = planetDistanceMap.get(planet2);\n        \n        // Ensure distance1 is less than or equal to distance2\n        if (distance1 > distance2) {\n            int temp = distance1;\n            distance1 = distance2;\n            distance2 = temp;\n        }\n        \n        List<String> result = new ArrayList<>();\n        for (Map.Entry<String, Integer> entry : planetDistanceMap.entrySet()) {\n            if (entry.getValue() > distance1 && entry.getValue() < distance2) {\n                result.add(entry.getKey());\n            }\n        }\n        \n        // Sort the result by distance from the Sun\n        result.sort((p1, p2) -> planetDistanceMap.get(p1).compareTo(planetDistanceMap.get(p2)));\n        \n        return new ArrayList<>(result);\n    }\n    \n    public static void main(String[] args) {\n        System.out.println(bf(\"Jupiter\", \"Neptune\")); // ==> (\"Saturn\", \"Uranus\")\n        System.out.println(bf(\"Earth\", \"Mercury\")); // ==> (\"Venus\")\n        System.out.println(bf(\"Mercury\", \"Uranus\")); // ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n    }\n}"}
{"task_id": "java/71", "language": "java", "completion": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\nclass XOrY {\n    /**\n     * Ein einfaches Programm, das den Wert von x zur\u00fcckgeben sollte, wenn n eine Primzahl ist, und den Wert von y zur\u00fcckgeben sollte, wenn nicht.\n     * \n     * Beispiele:\n     * \n     * for x_or_y(7, 34, 12) == 34\n     * for x_or_y(15, 8, 5) == 5\n     * \n     */\n    public static int xOrY(int n, int x, int y) {\n        if (isPrime(n)) {\n            return x;\n        } else {\n            return y;\n        }\n    }\n\n    // Hilfsfunktion zur \u00dcberpr\u00fcfung, ob eine Zahl eine Primzahl ist\n    private static boolean isPrime(int num) {\n        if (num <= 1) {\n            return false;\n        }\n        for (int i = 2; i <= Math.sqrt(num); i++) {\n            if (num % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        // Beispielaufrufe\n        System.out.println(xOrY(7, 34, 12)); // Ausgabe: 34\n        System.out.println(xOrY(15, 8, 5));  // Ausgabe: 5\n    }\n}"}
{"task_id": "java/72", "language": "java", "completion": "import java.util.*;\n\nclass DoubleTheDifference {\n    public static int doubleTheDifference(List<Object> lst) {\n        int sum = 0;\n        \n        for (Object obj : lst) {\n            if (obj instanceof Integer) {\n                int num = (Integer) obj;\n                if (num > 0 && num % 2 != 0) {\n                    sum += num * num;\n                }\n            }\n        }\n        \n        return sum;\n    }\n    \n    public static void main(String[] args) {\n        System.out.println(doubleTheDifference(Arrays.asList(1, 3, 2, 0))); // Output: 10\n        System.out.println(doubleTheDifference(Arrays.asList(-1, -2, 0))); // Output: 0\n        System.out.println(doubleTheDifference(Arrays.asList(9, -2))); // Output: 81\n        System.out.println(doubleTheDifference(Collections.singletonList(0))); // Output: 0\n        System.out.println(doubleTheDifference(new ArrayList<>())); // Output: 0\n    }\n}"}
{"task_id": "java/73", "language": "java", "completion": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\nclass StrongestExtension {\n    /**\n     * \n     * Sie erhalten den Namen einer Klasse (einen String) und eine Liste von Erweiterungen. Die Erweiterungen sollen verwendet werden, um zus\u00e4tzliche Klassen zur Klasse zu laden. Die St\u00e4rke der Erweiterung wird wie folgt definiert: Sei CAP die Anzahl der Gro\u00dfbuchstaben im Namen der Erweiterung und SM die Anzahl der Kleinbuchstaben im Namen der Erweiterung. Die St\u00e4rke wird durch den Bruch CAP - SM gegeben. Sie sollten die st\u00e4rkste Erweiterung finden und einen String in diesem Format zur\u00fcckgeben: ClassName.StrongestExtensionName. Wenn es zwei oder mehr Erweiterungen mit der gleichen St\u00e4rke gibt, sollten Sie die w\u00e4hlen, die zuerst in der Liste steht. Zum Beispiel, wenn Sie \"Slices\" als Klasse und eine Liste von Erweiterungen erhalten: ['SErviNGSliCes', 'Cheese', 'StuFfed'], sollten Sie 'Slices.SErviNGSliCes' zur\u00fcckgeben, da 'SErviNGSliCes' die st\u00e4rkste Erweiterung ist (ihre St\u00e4rke ist -1). Beispiel:\n     * \n     * for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n     *\n     */\n    public static String strongestExtension(String className, List<String> extensions) {\n        // Initialize variables to keep track of the strongest extension\n        String strongestExtension = \"\";\n        int maxStrength = Integer.MIN_VALUE;\n\n        // Iterate through each extension in the list\n        for (String ext : extensions) {\n            int CAP = 0, SM = 0;\n            \n            // Count the number of uppercase and lowercase letters in the extension name\n            for (char c : ext.toCharArray()) {\n                if (Character.isUpperCase(c)) {\n                    CAP++;\n                } else if (Character.isLowerCase(c)) {\n                    SM++;\n                }\n            }\n            \n            // Calculate the strength of the current extension\n            int strength = CAP - SM;\n            \n            // Update the strongest extension if the current one is stronger\n            if (strength > maxStrength) {\n                maxStrength = strength;\n                strongestExtension = ext;\n            }\n        }\n        \n        // Return the result in the format ClassName.StrongestExtensionName\n        return className + \".\" + strongestExtension;\n    }\n\n    public static void main(String[] args) {\n        List<String> extensions = Arrays.asList(\"SErviNGSliCes\", \"Cheese\", \"StuFfed\");\n        System.out.println(strongestExtension(\"Slices\", extensions)); // Output: Slices.SErviNGSliCes\n        \n        List<String> extensions2 = Arrays.asList(\"AA\", \"Be\", \"CC\");\n        System.out.println(strongestExtension(\"my_class\", extensions2)); // Output: my_class.AA\n    }\n}"}
{"task_id": "java/74", "language": "java", "completion": "class CycpatternCheck {\n    /**\n     * \n     * Du bekommst 2 W\u00f6rter. Du musst True zur\u00fcckgeben, wenn das zweite Wort oder eine seiner Rotationen ein Teilstring im ersten Wort ist.\n     * cycpattern_check(\"abcd\",\"abd\") => False\n     * cycpattern_check(\"hello\",\"ell\") => True\n     * cycpattern_check(\"whassup\",\"psus\") => False\n     * cycpattern_check(\"abab\",\"baa\") => True\n     * cycpattern_check(\"efef\",\"eeff\") => False\n     * cycpattern_check(\"himenss\",\"simen\") => True\n     *\n     */\n    public static Boolean cycpatternCheck(String a, String b) {\n        // If the length of b is greater than a, it can't be a substring\n        if (b.length() > a.length()) {\n            return false;\n        }\n        \n        // Create all rotations of string b\n        String rotatedB = b + b;\n        \n        // Check each rotation to see if it is a substring of a\n        for (int i = 0; i < b.length(); i++) {\n            String rotation = rotatedB.substring(i, i + b.length());\n            if (a.contains(rotation)) {\n                return true;\n            }\n        }\n        \n        // If no rotation is a substring of a, return false\n        return false;\n    }\n}"}
{"task_id": "java/75", "language": "java", "completion": "import java.util.*;\n\nclass IntToMiniRoman {\n    /**\n     * Gegeben eine positive Ganzzahl, erhalte ihre r\u00f6mische Numeral-\u00c4quivalenz als Zeichenkette und gib sie in Kleinbuchstaben zur\u00fcck.\n     * Einschr\u00e4nkungen: 1 <= num <= 1000\n     */\n    public static String intToMiniRoman(int number) {\n        if (number < 1 || number > 1000) {\n            throw new IllegalArgumentException(\"Number must be between 1 and 1000\");\n        }\n\n        // Map of Roman numerals to their values\n        List<Map.Entry<Integer, String>> romanNumerals = Arrays.asList(\n            new AbstractMap.SimpleEntry<>(1000, \"m\"),\n            new AbstractMap.SimpleEntry<>(900, \"cm\"),\n            new AbstractMap.SimpleEntry<>(500, \"d\"),\n            new AbstractMap.SimpleEntry<>(400, \"cd\"),\n            new AbstractMap.SimpleEntry<>(100, \"c\"),\n            new AbstractMap.SimpleEntry<>(90, \"xc\"),\n            new AbstractMap.SimpleEntry<>(50, \"l\"),\n            new AbstractMap.SimpleEntry<>(40, \"xl\"),\n            new AbstractMap.SimpleEntry<>(10, \"x\"),\n            new AbstractMap.SimpleEntry<>(9, \"ix\"),\n            new AbstractMap.SimpleEntry<>(5, \"v\"),\n            new AbstractMap.SimpleEntry<>(4, \"iv\"),\n            new AbstractMap.SimpleEntry<>(1, \"i\")\n        );\n\n        StringBuilder roman = new StringBuilder();\n\n        for (Map.Entry<Integer, String> entry : romanNumerals) {\n            while (number >= entry.getKey()) {\n                number -= entry.getKey();\n                roman.append(entry.getValue());\n            }\n        }\n\n        return roman.toString().toLowerCase();\n    }\n\n    public static void main(String[] args) {\n        System.out.println(intToMiniRoman(19)); // Output: xix\n        System.out.println(intToMiniRoman(152)); // Output: clii\n        System.out.println(intToMiniRoman(426)); // Output: cdxxvi\n    }\n}"}
{"task_id": "java/76", "language": "java", "completion": "// To determine if three sides form a right-angled triangle, we can use the Pythagorean theorem. This theorem states that in a right-angled triangle, the square of the length of the hypotenuse (the side opposite the right angle) is equal to the sum of the squares of the lengths of the other two sides.\n        // We need to find the maximum value among the three sides, which will be our \"hypotenuse\" candidate. Then we check if the Pythagorean theorem holds for this candidate and the other two sides.\n        \n        // First, identify the largest side as the potential hypotenuse (c)\n        int maxSide = Math.max(a, Math.max(b, c));\n        \n        // Now, apply the Pythagorean theorem: if maxSide^2 == sum of squares of other two sides, it's a right-angled triangle.\n        if (maxSide * maxSide == (a*a + b*b + c*c) - maxSide*maxSide) {\n            return true; // It's a right-angled triangle\n        } else {\n            return false; // Not a right-angled triangle\n        }\n    }\n\n    public static void main(String[] args) {\n        System.out.println(rightAngleTriangle(3, 4, 5)); // Should print true\n        System.out.println(rightAngleTriangle(1, 2, 3)); // Should print false\n    }\n}"}
{"task_id": "java/77", "language": "java", "completion": "class Solve {\n    public static String solve(String s) {\n        StringBuilder result = new StringBuilder();\n        \n        for (char c : s.toCharArray()) {\n            if (Character.isLetter(c)) {\n                if (Character.isLowerCase(c)) {\n                    result.append(Character.toUpperCase(c));\n                } else {\n                    result.append(Character.toLowerCase(c));\n                }\n            } else {\n                result.append(c);\n            }\n        }\n        \n        return result.toString();\n    }\n}"}
{"task_id": "java/78", "language": "java", "completion": "import java.io.*;\nimport java.security.*;\nimport java.util.*;\n\nclass StringToMd5 {\n    /**\n     * Gegeben eine Zeichenkette 'text', gibt seine md5-Hash-\u00c4quivalent-Zeichenkette zur\u00fcck.\n     * Wenn 'text' eine leere Zeichenkette ist, gib null zur\u00fcck.\n     */\n    public static String stringToMd5(String text) {\n        if (text == null || text.isEmpty()) {\n            return null;\n        }\n\n        try {\n            // Berechne den MD5-Hash der Eingabezeichenkette\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            byte[] messageDigest = md.digest(text.getBytes());\n\n            // Wandle den Hash in eine Hexadezimalzeichenkette um\n            StringBuilder sb = new StringBuilder();\n            for (byte b : messageDigest) {\n                sb.append(String.format(\"%02x\", b & 0xff));\n            }\n\n            return sb.toString();\n        } catch (NoSuchAlgorithmException e) {\n            throw new RuntimeException(\"MD5 algorithm not available.\", e);\n        }\n    }\n\n    public static void main(String[] args) {\n        // Test der Methode\n        String text = \"Hello world\";\n        String md5Hash = stringToMd5(text);\n        System.out.println(\"MD5 Hash of '\" + text + \"' is: \" + md5Hash);\n    }\n}"}
{"task_id": "java/79", "language": "java", "completion": "// Ensure the range is correctly ordered\n        int start = Math.min(a, b);\n        int end = Math.max(a, b);\n\n        // Create an ArrayList to store the even numbers\n        List<Object> result = new ArrayList<>();\n\n        // Iterate through the range and check for even numbers\n        for (int i = start; i <= end; i++) {\n            if (i % 2 == 0) {\n                result.add(i);\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        // Test cases\n        System.out.println(generateIntegers(2, 8)); // [2, 4, 6, 8]\n        System.out.println(generateIntegers(8, 2)); // [2, 4, 6, 8]\n        System.out.println(generateIntegers(10, 14)); // []\n    }\n}"}
