{"task_id": "kotlin/0", "language": "kotlin", "completion": "fun belowZero(operations: List<Any>): Boolean {\n    var balance = 0\n    \n    for (operation in operations) {\n        when (operation) {\n            is Int -> {\n                balance += operation\n                if (balance < 0) {\n                    return true\n                }\n            }\n            else -> {\n                // Ignoriere andere Typen, da nur Ganzzahlen verwendet werden\n            }\n        }\n    }\n    \n    return false\n}\n\n// Testf\u00e4lle\nfun main() {\n    println(belowZero(listOf(1, 2, 3))) // False\n    println(belowZero(listOf(1, 2, -4, 5))) // True\n}"}
{"task_id": "kotlin/1", "language": "kotlin", "completion": "fun sumProduct(numbers: List<Int>): Pair<Int, Int> {\n    if (numbers.isEmpty()) {\n        return Pair(0, 1)\n    }\n    \n    val sum = numbers.sum()\n    val product = numbers.reduce { acc, i -> acc * i }\n    \n    return Pair(sum, product)\n}\n\n// Beispielaufrufe\nfun main() {\n    println(sumProduct(emptyList())) // (0, 1)\n    println(sumProduct(listOf(1, 2, 3, 4))) // (10, 24)\n}"}
{"task_id": "kotlin/2", "language": "kotlin", "completion": "fun stringXor(a: String, b: String): String {\n    // \u00dcberpr\u00fcfen, ob die Eingabezeichenketten gleich lang sind\n    if (a.length != b.length) {\n        throw IllegalArgumentException(\"Die Zeichenketten m\u00fcssen gleich lang sein\")\n    }\n\n    val result = StringBuilder()\n\n    // Durchlaufen der Zeichenketten und Ausf\u00fchren der XOR-Operation f\u00fcr jedes Zeichenpaar\n    for (i in a.indices) {\n        val charA = a[i]\n        val charB = b[i]\n        if (charA == charB) {\n            result.append('0')\n        } else {\n            result.append('1')\n        }\n    }\n\n    return result.toString()\n}\n\n// Beispielaufruf\nfun main() {\n    val a = \"010\"\n    val b = \"110\"\n    println(stringXor(a, b))  // Ausgabe: '100'\n}"}
{"task_id": "kotlin/3", "language": "kotlin", "completion": "fun longest(strings: List<String>): String? {\n    if (strings.isEmpty()) return null\n    \n    var longestString = strings[0]\n    \n    for (string in strings) {\n        if (string.length > longestString.length) {\n            longestString = string\n        }\n    }\n    \n    return longestString\n}"}
{"task_id": "kotlin/4", "language": "kotlin", "completion": "fun greatestCommonDivisor(a : Int, b : Int) : Int {\n    // Stellen Sie sicher, dass wir mit positiven Zahlen arbeiten\n    val x = Math.abs(a)\n    val y = Math.abs(b)\n    \n    // Wenn eine der Zahlen 0 ist, ist der GCD die andere Zahl\n    if (x == 0) return y\n    if (y == 0) return x\n    \n    // Ansonsten verwenden wir den euklidischen Algorithmus\n    var a = x\n    var b = y\n    while (b != 0) {\n        val temp = b\n        b = a % b\n        a = temp\n    }\n    return a\n}\n\n// Testf\u00e4lle\nfun main() {\n    println(greatestCommonDivisor(3, 5)) // Ausgabe: 1\n    println(greatestCommonDivisor(25, 15)) // Ausgabe: 5\n}"}
{"task_id": "kotlin/5", "language": "kotlin", "completion": "fun sortNumbers(numbers: String): String {\n    // Liste der g\u00fcltigen Zahlennamen\n    val validNumbers = listOf(\"null\", \"eins\", \"zwei\", \"drei\", \"vier\", \"f\u00fcnf\", \"sechs\", \"sieben\", \"acht\", \"neun\")\n    \n    // String in eine Liste von W\u00f6rtern aufteilen\n    val words = numbers.split(\" \")\n    \n    // Zahlennamen zu deren Index im validNumbers-Array konvertieren\n    val numberIndices = words.map { validNumbers.indexOf(it) }\n    \n    // Indices sortieren\n    val sortedIndices = numberIndices.sorted()\n    \n    // Sortierte Indices zur\u00fcck zu den Zahlennamen konvertieren\n    val sortedWords = sortedIndices.map { validNumbers[it] }\n    \n    // Die sortierten W\u00f6rter wieder zu einem String zusammenf\u00fcgen\n    return sortedWords.joinToString(\" \")\n}\n\n// Beispielaufrufe\nfun main() {\n    println(sortNumbers(\"three one five\")) // Ausgabe: \"one three five\"\n}"}
{"task_id": "kotlin/6", "language": "kotlin", "completion": "fun rescaleToUnit(numbers: List<Double>): List<Double> {\n    if (numbers.size < 2) {\n        throw IllegalArgumentException(\"Die Liste muss mindestens zwei Elemente enthalten.\")\n    }\n    \n    val min = numbers.minOrNull() ?: throw IllegalStateException(\"Die Liste darf nicht leer sein.\")\n    val max = numbers.maxOrNull() ?: throw IllegalStateException(\"Die Liste darf nicht leer sein.\")\n    \n    return numbers.map { (it - min) / (max - min) }\n}\n\n// Beispielaufruf\nfun main() {\n    val result = rescaleToUnit(listOf(1.0, 2.0, 3.0, 4.0, 5.0))\n    println(result) // Ausgabe: [0.0, 0.25, 0.5, 0.75, 1.0]\n}"}
{"task_id": "kotlin/7", "language": "kotlin", "completion": "fun flipCase(string: String): String {\n    val flippedString = StringBuilder()\n    \n    for (char in string) {\n        when {\n            char.isLowerCase() -> flippedString.append(char.toUpperCase())\n            char.isUpperCase() -> flippedString.append(char.toLowerCase())\n            else -> flippedString.append(char)\n        }\n    }\n    \n    return flippedString.toString()\n}\n\n// Beispielaufruf\nfun main() {\n    val result = flipCase(\"Hello\")\n    println(result)  // Ausgabe: hELLO\n}"}
{"task_id": "kotlin/8", "language": "kotlin", "completion": "fun getPositive(l: List<Any>): List<Any> {\n    return l.filterIsInstance<Number>().filter { it.toDouble() > 0 }.map { it }\n}\n\n// Beispielaufrufe\nfun main() {\n    println(getPositive(listOf(-1, 2, -4, 5, 6))) // [2, 5, 6]\n    println(getPositive(listOf(5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10))) // [5, 3, 2, 3, 9, 123, 1]\n}"}
{"task_id": "kotlin/9", "language": "kotlin", "completion": "fun isPrime(n: Int): Boolean {\n    if (n <= 1) return false\n    if (n == 2 || n == 3) return true\n    if (n % 2 == 0 || n % 3 == 0) return false\n    \n    var i = 5\n    while (i * i <= n) {\n        if (n % i == 0 || n % (i + 2) == 0) return false\n        i += 6\n    }\n    return true\n}"}
{"task_id": "kotlin/10", "language": "kotlin", "completion": "fun unique(l: List<Int>): List<Int> {\n    // Entfernen der Duplikate und Sortieren der Liste\n    return l.distinct().sorted()\n}\n\n// Beispielaufruf\nfun main() {\n    val result = unique(listOf(5, 3, 5, 2, 3, 3, 9, 0, 123))\n    println(result) // Ausgabe: [0, 2, 3, 5, 9, 123]\n}"}
{"task_id": "kotlin/11", "language": "kotlin", "completion": "fun isPrime(num: Int): Boolean {\n    if (num <= 1) return false\n    if (num == 2) return true\n    if (num % 2 == 0) return false\n    for (i in 3..sqrt(num.toDouble()).toInt() step 2) {\n        if (num % i == 0) return false\n    }\n    return true\n}\n\nfun fibonacci(n: Int): Long {\n    if (n <= 0) throw IllegalArgumentException(\"n must be positive\")\n    if (n == 1) return 0\n    if (n == 2) return 1\n    var a = 0L\n    var b = 1L\n    for (i in 3..n) {\n        val next = a + b\n        a = b\n        b = next\n    }\n    return b\n}\n\nfun primeFib(n: Int): Int {\n    if (n <= 0) throw IllegalArgumentException(\"n must be positive\")\n    var count = 0\n    var i = 0\n    while (count < n) {\n        val fibNum = fibonacci(i).toInt()\n        if (isPrime(fibNum)) {\n            count++\n        }\n        if (count < n) i++\n    }\n    return fibonacci(i).toInt()\n}\n\n// Beispielaufrufe\nfun main() {\n    println(primeFib(1)) // 2\n    println(primeFib(2)) // 3\n    println(primeFib(3)) // 5\n    println(primeFib(4)) // 13\n    println(primeFib(5)) // 89\n}"}
{"task_id": "kotlin/12", "language": "kotlin", "completion": "fun triplesSumToZero(l: List<Int>): Boolean {\n    // Wenn die Liste zu klein ist, gib false zur\u00fcck\n    if (l.size < 3) return false\n    \n    // Sortiere die Liste\n    val sortedList = l.sorted()\n    \n    // Durchlaufe die Liste und verwende zwei Zeiger f\u00fcr jedes Element\n    for (i in 0 until sortedList.size - 2) {\n        var left = i + 1\n        var right = sortedList.size - 1\n        \n        while (left < right) {\n            val sum = sortedList[i] + sortedList[left] + sortedList[right]\n            \n            // Wenn die Summe gleich Null ist, haben wir gefunden\n            if (sum == 0) return true\n            \n            // Ansonsten passen wir den linken oder rechten Zeiger an\n            if (sum < 0) {\n                left++\n            } else {\n                right--\n            }\n        }\n    }\n    \n    // Wenn keine drei Elemente gefunden wurden, die zu Null addieren, gib false zur\u00fcck\n    return false\n}"}
{"task_id": "kotlin/13", "language": "kotlin", "completion": "fun pairsSumToZero(l: List<Int>): Boolean {\n    // Wir verwenden ein Set um doppelte Elemente zu vermeiden\n    val seen = mutableSetOf<Int>()\n    \n    for (num in l) {\n        if (seen.contains(-num)) {\n            return true\n        }\n        seen.add(num)\n    }\n    \n    return false\n}\n\n// Testf\u00e4lle\nfun main() {\n    println(pairsSumToZero(listOf(1, 3, 5, 0))) // False\n    println(pairsSumToZero(listOf(1, 3, -2, 1))) // False\n    println(pairsSumToZero(listOf(1, 2, 3, 7))) // False\n    println(pairsSumToZero(listOf(2, 4, -5, 3, 5, 7))) // True\n    println(pairsSumToZero(listOf(1))) // False\n}"}
{"task_id": "kotlin/14", "language": "kotlin", "completion": "fun fib4(n: Int): Int {\n    if (n == 0) return 0\n    if (n == 1) return 0\n    if (n == 2) return 2\n    if (n == 3) return 0\n\n    val sequence = mutableListOf(0, 0, 2, 0)\n    \n    for (i in 4..n) {\n        val nextValue = sequence[i - 1] + sequence[i - 2] + sequence[i - 3] + sequence[i - 4]\n        sequence.add(nextValue)\n    }\n    \n    return sequence[n]\n}\n\n// Test cases\nfun main() {\n    println(fib4(5)) // Output: 4\n    println(fib4(6)) // Output: 8\n    println(fib4(7)) // Output: 14\n}"}
{"task_id": "kotlin/15", "language": "kotlin", "completion": "fun median(l: List<Int>): Any {\n    // Sortiere die Liste zuerst\n    val sortedList = l.sorted()\n    \n    // Berechne die Anzahl der Elemente\n    val size = sortedList.size\n    \n    // Wenn die Anzahl der Elemente ungerade ist, gib das mittlere Element zur\u00fcck\n    if (size % 2 == 1) {\n        return sortedList[size / 2]\n    } else {\n        // Wenn die Anzahl der Elemente gerade ist, berechne den Mittelwert der beiden mittleren Elemente\n        val middle1 = sortedList[(size - 1) / 2]\n        val middle2 = sortedList[size / 2]\n        return (middle1 + middle2) / 2.0\n    }\n}\n\n// Testf\u00e4lle\nfun main() {\n    println(median(listOf(3, 1, 2, 4, 5))) // Ausgabe: 3\n    println(median(listOf(-10, 4, 6, 1000, 10, 20))) // Ausgabe: 15.0\n}"}
{"task_id": "kotlin/16", "language": "kotlin", "completion": "fun isPalindrome(text: String): Boolean {\n    // Entferne alle Leerzeichen und wandle den Text in Kleinbuchstaben um\n    val cleanedText = text.replace(\" \", \"\").toLowerCase()\n    \n    // Vergleiche den urspr\u00fcnglichen String mit seinem umgekehrten String\n    return cleanedText == cleanedText.reversed()\n}\n\n// Testf\u00e4lle\nfun main() {\n    println(isPalindrome(\"\"))       // True\n    println(isPalindrome(\"aba\"))    // True\n    println(isPalindrome(\"aaaaa\"))  // True\n    println(isPalindrome(\"zbcd\"))   // False\n}"}
{"task_id": "kotlin/17", "language": "kotlin", "completion": "fun removeVowels(text: String): String {\n    // Definieren der Vokale (Gro\u00df- und Kleinschreibung)\n    val vowels = \"aeiouAEIOU\"\n    \n    // Erstellen eines neuen Strings ohne Vokale\n    return text.filter { !vowels.contains(it) }\n}\n\n// Testf\u00e4lle\nfun main() {\n    println(removeVowels(\"\")) // ''\n    println(removeVowels(\"abcdef\\nghijklm\")) // 'bcdf\\nghjklm'\n    println(removeVowels('abcdef')) // 'bcdf'\n    println(removeVowels('aaaaa')) // ''\n    println(removeVowels('aaBAA')) // 'B'\n    println(removeVowels('zbcd')) // 'zbcd'\n}"}
{"task_id": "kotlin/18", "language": "kotlin", "completion": "fun belowThreshold(l: List<Int>, t: Int): Boolean {\n    return l.all { it < t }\n}\n\n// Testf\u00e4lle\nfun main() {\n    println(belowThreshold(listOf(1, 2, 4, 10), 100)) // True\n    println(belowThreshold(listOf(1, 20, 4, 10), 5))   // False\n}"}
{"task_id": "kotlin/19", "language": "kotlin", "completion": "fun add(x : Int, y : Int) : Int {\n    return x + y\n}"}
{"task_id": "kotlin/20", "language": "kotlin", "completion": "fun sameChars(s0: String, s1: String): Boolean {\n    // Erstellen einer Map f\u00fcr die Zeichenh\u00e4ufigkeiten von s0\n    val charCountS0 = mutableMapOf<Char, Int>()\n    for (char in s0) {\n        charCountS0[char] = charCountS0.getOrDefault(char, 0) + 1\n    }\n    \n    // Erstellen einer Map f\u00fcr die Zeichenh\u00e4ufigkeiten von s1\n    val charCountS1 = mutableMapOf<Char, Int>()\n    for (char in s1) {\n        charCountS1[char] = charCountS1.getOrDefault(char, 0) + 1\n    }\n    \n    // Vergleichen der beiden Maps\n    return charCountS0 == charCountS1\n}\n\n// Testf\u00e4lle\nfun main() {\n    println(sameChars(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\")) // True\n    println(sameChars(\"abcd\", \"dddddddabc\")) // True\n    println(sameChars(\"dddddddabc\", \"abcd\")) // True\n    println(sameChars(\"eabcd\", \"dddddddabc\")) // False\n    println(sameChars(\"abcd\", \"dddddddabce\")) // False\n    println(sameChars(\"eabcdzzzz\", \"dddzzzzzzzddddabc\")) // False\n}"}
{"task_id": "kotlin/21", "language": "kotlin", "completion": "fun fib(n: Int): Int {\n    if (n <= 0) return 0\n    if (n == 1) return 1\n    \n    var a = 0\n    var b = 1\n    for (i in 2..n) {\n        val temp = a + b\n        a = b\n        b = temp\n    }\n    return b\n}"}
{"task_id": "kotlin/22", "language": "kotlin", "completion": "fun common(l1: List<Int>, l2: List<Any>): List<Any> {\n    // Wandle die zweite Liste in eine Menge um, um Duplikate zu entfernen\n    val set2 = l2.toSet()\n    \n    // Filtere die Elemente von der ersten Liste, die auch in der zweiten Liste vorhanden sind\n    val commonElements = l1.filter { it in set2 }\n    \n    // Wandle das Ergebnis zur\u00fcck in eine sortierte Liste\n    return commonElements.sorted().toSet().toList()\n}\n\n// Testf\u00e4lle\nfun main() {\n    println(common(listOf(1, 4, 3, 34, 653, 2, 5), listOf(5, 7, 1, 5, 9, 653, 121))) // [1, 5, 653]\n    println(common(listOf(5, 3, 2, 8), listOf(3, 2))) // [2, 3]\n}"}
{"task_id": "kotlin/23", "language": "kotlin", "completion": "fun largestPrimeFactor(n: Int): Int {\n    var num = n\n    var factor = 2\n    var maxFactor = 1 // Start with the smallest possible factor\n\n    while (factor * factor <= num) {\n        if (num % factor == 0) {\n            maxFactor = factor\n            num /= factor\n            while (num % factor == 0) {\n                num /= factor\n            }\n        }\n        factor++\n    }\n\n    // If there is a remaining prime number greater than the square root of n\n    if (num > 1 && maxFactor < num) {\n        maxFactor = num\n    }\n\n    return maxFactor\n}\n\n// Test cases\nfun main() {\n    println(largestPrimeFactor(13195)) // Output: 29\n    println(largestPrimeFactor(2048))   // Output: 2\n}"}
{"task_id": "kotlin/24", "language": "kotlin", "completion": "fun sumToN(n: Int): Int {\n    return (n * (n + 1)) / 2\n}"}
{"task_id": "kotlin/25", "language": "kotlin", "completion": "fun derivative(xs: List<Int>): List<Int> {\n    if (xs.isEmpty()) return emptyList()\n    \n    val result = mutableListOf<Int>()\n    for ((index, value) in xs.withIndex()) {\n        if (index > 0) {\n            result.add(value * index)\n        }\n    }\n    return result\n}\n\n// Beispielaufrufe\nfun main() {\n    println(derivative(listOf(3, 1, 2, 4, 5))) // [1, 4, 12, 20]\n    println(derivative(listOf(1, 2, 3)))       // [2, 6]\n}"}
{"task_id": "kotlin/26", "language": "kotlin", "completion": "fun fibfib(n: Int): Int {\n    if (n == 0) return 0\n    if (n == 1) return 0\n    if (n == 2) return 1\n    \n    val dp = mutableListOf(0, 0, 1)\n    \n    for (i in 3..n) {\n        val nextValue = dp[i - 1] + dp[i - 2] + dp[i - 3]\n        dp.add(nextValue)\n    }\n    \n    return dp[n]\n}\n\n// Test cases\nfun main() {\n    println(fibfib(1)) // Output: 0\n    println(fibfib(5)) // Output: 4\n    println(fibfib(8)) // Output: 24\n}"}
{"task_id": "kotlin/27", "language": "kotlin", "completion": "fun vowelsCount(s: String): Int {\n    val vowels = setOf('a', 'e', 'i', 'o', 'u')\n    var count = 0\n    \n    for (char in s.lowercase()) {\n        if (char in vowels) {\n            count++\n        }\n    }\n    \n    return count\n}\n\n// Beispiele\nfun main() {\n    println(vowelsCount(\"abcde\")) // Ausgabe: 2\n    println(vowelsCount(\"ACEDY\")) // Ausgabe: 3\n}"}
{"task_id": "kotlin/28", "language": "kotlin", "completion": "fun search(lst: List<Int>): Int {\n    // Erstellen einer Map zur Z\u00e4hlung der H\u00e4ufigkeiten der Elemente in der Liste\n    val frequencyMap = mutableMapOf<Int, Int>()\n    \n    // Durchlaufen der Liste und Auff\u00fcllen der Map mit den H\u00e4ufigkeiten\n    for (num in lst) {\n        frequencyMap[num] = frequencyMap.getOrDefault(num, 0) + 1\n    }\n    \n    // Iterieren \u00fcber die Map um nach dem gr\u00f6\u00dften Wert zu suchen, der die Bedingung erf\u00fcllt\n    var result = -1\n    for ((key, value) in frequencyMap) {\n        if (value >= key && key > result) {\n            result = key\n        }\n    }\n    \n    return result\n}\n\n// Beispiele testen\nfun main() {\n    println(search(listOf(4, 1, 2, 2, 3, 1))) // Ausgabe: 2\n    println(search(listOf(1, 2, 2, 3, 3, 3, 4, 4, 4))) // Ausgabe: 3\n    println(search(listOf(5, 5, 4, 4, 4))) // Ausgabe: -1\n}"}
{"task_id": "kotlin/29", "language": "kotlin", "completion": "import kotlin.math.*\n\nfun triangleArea(a : Int, b : Int, c : Int) : Any {\n    // \u00dcberpr\u00fcfen, ob die Seiten ein g\u00fcltiges Dreieck bilden\n    if (a + b <= c || a + c <= b || b + c <= a) {\n        return -1\n    }\n    \n    // Berechnen der halben Umfang des Dreiecks\n    val s = (a + b + c) / 2.0\n    \n    // Berechnen der Fl\u00e4che mit der Heron-Formel\n    val area = sqrt(s * (s - a) * (s - b) * (s - c))\n    \n    // Runden auf zwei Dezimalstellen und zur\u00fcckgeben\n    return \"%.2f\".format(area).toDouble()\n}\n\n// Beispielaufrufe\nfun main() {\n    println(triangleArea(3, 4, 5)) // Ausgabe: 6.00\n    println(triangleArea(1, 2, 10)) // Ausgabe: -1\n}"}
{"task_id": "kotlin/30", "language": "kotlin", "completion": "fun willItFly(q: List<Int>, w: Int): Boolean {\n    // Check if the list is a palindrome\n    fun isPalindrome(list: List<Int>): Boolean {\n        val reversed = list.reversed()\n        return list == reversed\n    }\n    \n    // Calculate the sum of the elements in the list\n    val sum = q.sum()\n    \n    // Check if the list is a palindrome and if the sum is less than or equal to w\n    return isPalindrome(q) && sum <= w\n}\n\n// Test cases\nfun main() {\n    println(willItFly(listOf(1, 2), 5)) // False\n    println(willItFly(listOf(3, 2, 3), 1)) // False\n    println(willItFly(listOf(3, 2, 3), 9)) // True\n    println(willItFly(listOf(3), 5)) // True\n}"}
{"task_id": "kotlin/31", "language": "kotlin", "completion": "fun isPrime(n: Int): Boolean {\n    if (n <= 1) return false\n    if (n <= 3) return true\n    if (n % 2 == 0 || n % 3 == 0) return false\n    var i = 5\n    while (i * i <= n) {\n        if (n % i == 0 || n % (i + 2) == 0) return false\n        i += 6\n    }\n    return true\n}\n\nfun isMultiplyPrime(a: Int): Boolean {\n    for (i in 2..Math.sqrt(a.toDouble()).toInt()) {\n        if (a % i != 0) continue\n        for (j in i..Math.sqrt(a / i).toInt()) {\n            if ((a / i) % j != 0) continue\n            val k = a / (i * j)\n            if (isPrime(i) && isPrime(j) && isPrime(k)) {\n                return true\n            }\n        }\n    }\n    return false\n}\n\n// Beispielaufruf\nfun main() {\n    println(isMultiplyPrime(30)) // True, da 30 = 2 * 3 * 5\n    println(isMultiplyPrime(60)) // False, keine drei Primzahlen, deren Produkt 60 ergibt\n}"}
{"task_id": "kotlin/32", "language": "kotlin", "completion": "fun decimalToBinary(decimal: Int): String {\n    // Wandle die Dezimalzahl in eine Bin\u00e4rzahl um\n    val binaryString = Integer.toBinaryString(decimal)\n    \n    // F\u00fcge die zus\u00e4tzlichen Zeichen 'db' am Anfang und Ende hinzu\n    return \"db$binaryString\" + \"db\"\n}\n\n// Beispiele\nfun main() {\n    println(decimalToBinary(15))  // Ausgabe: db1111db\n    println(decimalToBinary(32))  // Ausgabe: db100000db\n}"}
{"task_id": "kotlin/33", "language": "kotlin", "completion": "fun isHappy(s: String): Boolean {\n    // \u00dcberpr\u00fcfen, ob die L\u00e4nge des Strings mindestens 3 betr\u00e4gt\n    if (s.length < 3) return false\n    \n    // Durchlaufen des Strings und \u00dcberpr\u00fcfung jeder Gruppe von 3 aufeinanderfolgenden Buchstaben\n    for (i in 0..s.length - 3) {\n        val substring = s.substring(i, i + 3)\n        // \u00dcberpr\u00fcfen, ob die drei aufeinanderfolgenden Buchstaben unterschiedlich sind\n        if (substring[0] == substring[1] || substring[1] == substring[2] || substring[0] == substring[2]) {\n            return false\n        }\n    }\n    \n    // Wenn alle Gruppen von 3 aufeinanderfolgenden Buchstaben unterschiedlich sind, ist der String gl\u00fccklich\n    return true\n}\n\n// Testf\u00e4lle\nfun main() {\n    println(isHappy(\"a\"))       // False\n    println(isHappy(\"aa\"))      // False\n    println(isHappy(\"abcd\"))    // True\n    println(isHappy(\"aabb\"))    // False\n    println(isHappy(\"adb\"))     // True\n    println(isHappy(\"xyy\"))     // False\n}"}
{"task_id": "kotlin/34", "language": "kotlin", "completion": "fun numericalLetterGrade(grades: List<Double>): List<String> {\n    return grades.map { grade ->\n        when (grade) {\n            in 4.0 downTo 3.7 -> \"A+\"\n            in 3.7 downTo 3.3 -> \"A\"\n            in 3.3 downTo 3.0 -> \"A-\"\n            in 3.0 downTo 2.7 -> \"B+\"\n            in 2.7 downTo 2.3 -> \"B\"\n            in 2.3 downTo 2.0 -> \"B-\"\n            in 2.0 downTo 1.7 -> \"C+\"\n            in 1.7 downTo 1.3 -> \"C\"\n            in 1.3 downTo 1.0 -> \"C-\"\n            in 1.0 downTo 0.7 -> \"D+\"\n            in 0.7 downTo 0.0 -> \"D\"\n            0.0 -> \"E\"\n            else -> throw IllegalArgumentException(\"Ung\u00fcltige GPA-Wert\")\n        }\n    }\n}\n\n// Beispielaufruf\nfun main() {\n    val grades = listOf(4.0, 3.0, 1.7, 2.0, 3.5)\n    val letterGrades = numericalLetterGrade(grades)\n    println(letterGrades) // Ausgabe: [A+, B, C-, C, A-]\n}"}
{"task_id": "kotlin/35", "language": "kotlin", "completion": "fun primeLength(string: String): Boolean {\n    val length = string.length\n    if (length <= 1) return false\n    for (i in 2..Math.sqrt(length.toDouble()).toInt()) {\n        if (length % i == 0) return false\n    }\n    return true\n}"}
{"task_id": "kotlin/36", "language": "kotlin", "completion": "fun solve(n: Int): String {\n    // Wandeln Sie die Zahl in eine bin\u00e4re Zeichenkette um\n    val binaryString = Integer.toBinaryString(n)\n    \n    // Berechnen Sie die Summe der Ziffern dieser bin\u00e4ren Zeichenkette\n    var sumOfDigits = 0\n    for (char in binaryString) {\n        if (char == '1') {\n            sumOfDigits += 1\n        }\n    }\n    \n    // Geben Sie die Summe der Ziffern als bin\u00e4re Zeichenkette zur\u00fcck\n    return Integer.toBinaryString(sumOfDigits)\n}\n\n// Beispielaufrufe\nfun main() {\n    println(solve(1000))  // Ausgabe: \"1\"\n    println(solve(150))   // Ausgabe: \"110\"\n    println(solve(147))   // Ausgabe: \"1100\"\n}"}
{"task_id": "kotlin/37", "language": "kotlin", "completion": "fun getRow(lst: List<List<Int>>, x: Int): List<Pair<Int, Int>> {\n    val result = mutableListOf<Pair<Int, Int>>()\n    \n    for ((rowIndex, row) in lst.withIndex()) {\n        if (x in row) {\n            for ((colIndex, value) in row.withIndex()) {\n                if (value == x) {\n                    result.add(Pair(rowIndex, colIndex))\n                }\n            }\n        }\n    }\n    \n    // Sortieren nach Zeilen aufsteigend und dann innerhalb der Zeile nach Spalten absteigend\n    return result.sortedWith(compareBy({ it.first }, { -it.second }))\n}\n\n// Beispiele\nfun main() {\n    println(getRow(listOf(\n        listOf(1, 2, 3, 4, 5, 6),\n        listOf(1, 2, 3, 4, 1, 6),\n        listOf(1, 2, 3, 4, 5, 1)\n    ), 1)) // == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    \n    println(getRow(listOf(), 1)) // == []\n    \n    println(getRow(listOf(\n        listOf(),\n        listOf(1),\n        listOf(1, 2, 3)\n    ), 3)) // == [(2, 2)]\n}"}
{"task_id": "kotlin/38", "language": "kotlin", "completion": "fun nextSmallest(lst: List<Int>): Int? {\n    if (lst.size < 2) return null\n    \n    val sortedList = lst.sorted()\n    val smallest = sortedList[0]\n    for (i in 1 until sortedList.size) {\n        if (sortedList[i] > smallest) {\n            return sortedList[i]\n        }\n    }\n    return null\n}\n\n// Test cases\nfun main() {\n    println(nextSmallest(listOf(1, 2, 3, 4, 5))) // Output: 2\n    println(nextSmallest(listOf(5, 1, 4, 3, 2))) // Output: 2\n    println(nextSmallest(emptyList())) // Output: null\n    println(nextSmallest(listOf(1, 1))) // Output: null\n}"}
{"task_id": "kotlin/39", "language": "kotlin", "completion": "fun isBored(s: String): Int {\n    // Split the string into sentences based on '.', '?' or '!'\n    val sentences = s.split(\".\", \"?\", \"!\")\n    \n    // Initialize a counter for bored sentences\n    var count = 0\n    \n    // Iterate through each sentence\n    for (sentence in sentences) {\n        // Trim leading and trailing whitespace from the sentence\n        val trimmedSentence = sentence.trim()\n        \n        // Check if the sentence starts with \"Ich\"\n        if (trimmedSentence.startsWith(\"Ich\", ignoreCase = true)) {\n            count++\n        }\n    }\n    \n    return count\n}\n\n// Test cases\nfun main() {\n    println(isBored(\"Hello world\")) // Output: 0\n    println(isBored(\"The sky is blue. The sun is shining. I love this weather\")) // Output: 1\n}"}
{"task_id": "kotlin/40", "language": "kotlin", "completion": "fun isPrime(n: Int): Boolean {\n    if (n <= 1) return false\n    if (n == 2) return true\n    if (n % 2 == 0) return false\n    for (i in 3..sqrt(n.toDouble()).toInt() step 2) {\n        if (n % i == 0) return false\n    }\n    return true\n}\n\nfun sumOfDigits(n: Int): Int {\n    var num = n\n    var sum = 0\n    while (num != 0) {\n        sum += num % 10\n        num /= 10\n    }\n    return sum\n}\n\nfun skjkasdkd(lst: List<Int>): Int {\n    var maxPrime = -1\n    for (number in lst) {\n        if (isPrime(number)) {\n            if (number > maxPrime) {\n                maxPrime = number\n            }\n        }\n    }\n    if (maxPrime != -1) {\n        return sumOfDigits(maxPrime)\n    } else {\n        return -1 // Wenn keine Primzahl gefunden wurde, k\u00f6nnen wir eine Fehlermeldung oder einen Standardwert zur\u00fcckgeben.\n    }\n}\n\n// Beispielaufrufe:\nfun main() {\n    println(skjkasdkd(listOf(0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3))) // Output: 10\n    println(skjkasdkd(listOf(1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1))) // Output: 25\n    println(skjkasdkd(listOf(1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3))) // Output: 13\n    println(skjkasdkd(listOf(0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6))) // Output: 11\n    println(skjkasdkd(listOf(0, 81, 12, 3, 1, 21))) // Output: 3\n    println(skjkasdkd(listOf(0, 8, 1, 2, 1, 7))) // Output: 7\n}"}
{"task_id": "kotlin/41", "language": "kotlin", "completion": "fun checkDictCase(dict: Map<Any?, Any?>): Boolean {\n    if (dict.isEmpty()) return false\n\n    var allLowerCase = true\n    var allUpperCase = true\n\n    for ((key, _) in dict) {\n        when {\n            key is String -> {\n                if (!key.all { it.isLowerCase() }) {\n                    allLowerCase = false\n                }\n                if (!key.all { it.isUpperCase() }) {\n                    allUpperCase = false\n                }\n            }\n            else -> return false // If any key is not a String, return false immediately\n        }\n    }\n\n    return allLowerCase || allUpperCase\n}\n\n// Test cases\nfun main() {\n    println(checkDictCase(mapOf(\"a\" to \"apple\", \"b\" to \"banana\"))) // True\n    println(checkDictCase(mapOf(\"a\" to \"apple\", \"A\" to \"banana\", \"B\" to \"banana\"))) // False\n    println(checkDictCase(mapOf(\"a\" to \"apple\", 8 to \"banana\", \"a\" to \"apple\"))) // False\n    println(checkDictCase(mapOf(\"Name\" to \"John\", \"Age\" to \"36\", \"City\" to \"Houston\"))) // False\n    println(checkDictCase(mapOf(\"STATE\" to \"NC\", \"ZIP\" to \"12345\"))) // True\n}"}
{"task_id": "kotlin/42", "language": "kotlin", "completion": "fun closestInteger(value: String): Int {\n    // Try to parse the string to a double\n    val number = try {\n        value.toDouble()\n    } catch (e: NumberFormatException) {\n        throw IllegalArgumentException(\"Invalid number format\")\n    }\n\n    // Calculate the integer part of the number\n    val intPart = number.toInt()\n    \n    // If the number is exactly at an integer point, return it\n    if (number == intPart.toDouble()) {\n        return intPart\n    }\n\n    // Otherwise, check which integer is closer\n    val lower = intPart\n    val upper = intPart + 1\n    \n    // If the number is exactly halfway between two integers, round away from zero\n    if (number > intPart && number < upper) {\n        return if ((number - intPart) >= (upper - number)) upper else lower\n    } else if (number < intPart && number > lower) {\n        return if ((intPart - number) <= (number - lower)) intPart else lower\n    }\n\n    // If the number is exactly at an integer point, return it\n    throw IllegalArgumentException(\"Invalid number format\")\n}\n\n// Test cases\nfun main() {\n    println(closestInteger(\"10\"))       // 10\n    println(closestInteger(\"15.3\"))     // 15\n    println(closestInteger(\"14.5\"))     // 15\n    println(closestInteger(\"-14.5\"))    // -15\n}"}
{"task_id": "kotlin/43", "language": "kotlin", "completion": "fun makeAPile(n: Int): List<Int> {\n    val pile = mutableListOf<Int>()\n    var currentStones = n\n    \n    while (pile.size < n) {\n        pile.add(currentStones)\n        if (currentStones % 2 == 0) {\n            // Wenn die aktuelle Zahl gerade ist, finde die n\u00e4chste ungerade Zahl\n            currentStones += 1\n            while (currentStones % 2 == 0) {\n                currentStones++\n            }\n        } else {\n            // Wenn die aktuelle Zahl ungerade ist, finde die n\u00e4chste gerade Zahl\n            currentStones += 1\n            while (currentStones % 2 != 0) {\n                currentStones++\n            }\n        }\n    }\n    \n    return pile\n}\n\n// Beispielaufruf\nfun main() {\n    println(makeAPile(3)) // Ausgabe: [3, 5, 7]\n}"}
{"task_id": "kotlin/44", "language": "kotlin", "completion": "fun wordsString(s : String) : List<String> {\n    // Split the string by commas and spaces, then return the resulting list of words\n    return s.split(\",\", \" \").mapNotNull { it.trim() }\n}\n\n// Test cases\nfun main() {\n    println(wordsString(\"Hi, my name is John\")) // [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    println(wordsString(\"One, two, three, four, five, six\")) // [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n}"}
{"task_id": "kotlin/45", "language": "kotlin", "completion": "fun chooseNum(x: Int, y: Int): Int {\n    if (x > y) {\n        return -1\n    }\n    \n    for (i in y downTo x) {\n        if (i % 2 == 0) {\n            return i\n        }\n    }\n    \n    return -1\n}"}
{"task_id": "kotlin/46", "language": "kotlin", "completion": "fun roundedAvg(n : Int, m : Int) : Any {\n    if (n > m) {\n        return -1\n    }\n    \n    // Berechnen der Summe der Zahlen von n bis m\n    val sum = (n..m).sum()\n    \n    // Berechnen der Anzahl der Zahlen in diesem Bereich\n    val count = m - n + 1\n    \n    // Berechnen des Durchschnitts und runden auf die n\u00e4chste Ganzzahl\n    val avg = sum / count\n    \n    // Konvertieren des Durchschnitts zum bin\u00e4ren Format\n    return \"0b${avg.toString(2)}\"\n}\n\n// Beispielaufrufe\nfun main() {\n    println(roundedAvg(1, 5))  // Ausgabe: 0b11\n    println(roundedAvg(7, 5))  // Ausgabe: -1\n    println(roundedAvg(10, 20)) // Ausgabe: 0b1111\n    println(roundedAvg(20, 33)) // Ausgabe: 0b11010\n}"}
{"task_id": "kotlin/47", "language": "kotlin", "completion": "fun f(n: Int): List<Int> {\n    val result = mutableListOf<Int>()\n    \n    for (i in 1..n) {\n        if (i % 2 == 0) {\n            // Fakult\u00e4t von i berechnen\n            var factorial = 1\n            for (j in 1..i) {\n                factorial *= j\n            }\n            result.add(factorial)\n        } else {\n            // Summe der Zahlen von 1 bis i berechnen\n            val sum = (1..i).sum()\n            result.add(sum)\n        }\n    }\n    \n    return result\n}\n\n// Beispielaufruf\nfun main() {\n    println(f(5)) // Ausgabe: [1, 2, 6, 24, 15]\n}"}
{"task_id": "kotlin/48", "language": "kotlin", "completion": "fun evenOddPalindrome(n: Int): List<Int> {\n    fun isPalindrome(num: Int): Boolean {\n        val str = num.toString()\n        return str == str.reversed()\n    }\n\n    var evenCount = 0\n    var oddCount = 0\n\n    for (i in 1..n) {\n        if (isPalindrome(i)) {\n            when (val digit = i % 2) {\n                0 -> evenCount++\n                1 -> oddCount++\n            }\n        }\n    }\n\n    return listOf(evenCount, oddCount)\n}\n\n// Beispielaufrufe\nfun main() {\n    println(evenOddPalindrome(3))  // Ausgabe: [1, 2]\n    println(evenOddPalindrome(12)) // Ausgabe: [4, 6]\n}"}
{"task_id": "kotlin/49", "language": "kotlin", "completion": "fun moveOneBall(arr: List<Int>): Boolean {\n    if (arr.isEmpty()) return true\n    \n    // Pr\u00fcfen, ob das Array bereits sortiert ist\n    fun isSorted(arr: List<Int>): Boolean {\n        for (i in 1 until arr.size) {\n            if (arr[i] < arr[i - 1]) return false\n        }\n        return true\n    }\n    \n    // Verschieben des Arrays und pr\u00fcfen, ob es sortiert wird\n    fun canBeSortedByShifting(arr: List<Int>): Boolean {\n        val n = arr.size\n        for (shift in 0 until n) {\n            if (isSorted(arr.dropLast(shift).plus(arr.takeLast(shift)))) return true\n        }\n        return false\n    }\n    \n    return canBeSortedByShifting(arr)\n}\n\n// Testf\u00e4lle\nfun main() {\n    println(moveOneBall(listOf(3, 4, 5, 1, 2))) // True\n    println(moveOneBall(listOf(3, 5, 4, 1, 2))) // False\n}"}
{"task_id": "kotlin/50", "language": "kotlin", "completion": "fun exchange(lst1: List<Int>, lst2: List<Int>): String {\n    // Identifizieren der ungeraden Elemente in lst1\n    val oddInLst1 = lst1.filter { it % 2 != 0 }\n    \n    // Wenn alle Elemente in lst1 gerade sind, geben wir \"YES\" zur\u00fcck\n    if (oddInLst1.isEmpty()) return \"YES\"\n    \n    // Identifizieren der geraden Elemente in lst2\n    val evenInLst2 = lst2.filter { it % 2 == 0 }\n    \n    // Wenn es mindestens ein ungerades Element in lst1 gibt und wir kein passendes gerades Element in lst2 finden, geben wir \"NO\" zur\u00fcck\n    if (evenInLst2.isEmpty()) return \"NO\"\n    \n    // Wenn es m\u00f6glich ist, alle ungeraden Elemente in lst1 durch Austausch mit geraden Elementen in lst2 zu entfernen, geben wir \"YES\" zur\u00fcck\n    return \"YES\"\n}\n\n// Beispiele\nfun main() {\n    println(exchange(listOf(1, 2, 3, 4), listOf(1, 2, 3, 4))) // Ausgabe: \"YES\"\n    println(exchange(listOf(1, 2, 3, 4), listOf(1, 5, 3, 4))) // Ausgabe: \"NO\"\n}"}
{"task_id": "kotlin/51", "language": "kotlin", "completion": "fun reverseDelete(s : String, c : String) : List<Any> {\n    // Entferne alle Zeichen in s, die auch in c vorkommen\n    val filteredString = s.filter { !c.contains(it) }\n    \n    // \u00dcberpr\u00fcfe, ob die gefilterte Zeichenkette ein Palindrom ist\n    val isPalindrome = filteredString == filteredString.reversed()\n    \n    // Gib das Ergebnis als Tupel zur\u00fcck\n    return listOf(filteredString, isPalindrome)\n}\n\n// Beispielaufrufe\nfun main() {\n    println(reverseDelete(\"abcde\", \"ae\"))  // Ausgabe: ['bcd', false]\n    println(reverseDelete(\"abcdef\", \"b\"))   // Ausgabe: ['acdef', false]\n    println(reverseDelete(\"abcdedcba\", \"ab\"))  // Ausgabe: ['cdedc', true]\n}"}
{"task_id": "kotlin/52", "language": "kotlin", "completion": "fun maxFill(grid: List<List<Int>>, capacity: Int): Int {\n    var totalWater = 0\n    \n    // Durchlaufen Sie jede Zeile in der Matrix und z\u00e4hlen Sie die Anzahl der Wasserstellen (1)\n    for (row in grid) {\n        for (water in row) {\n            if (water == 1) {\n                totalWater++\n            }\n        }\n    }\n    \n    // Berechnen Sie, wie oft die Eimer gef\u00fcllt werden m\u00fcssen, um das Wasser zu extrahieren\n    return if (totalWater > 0) {\n        val requiredFill = totalWater / capacity\n        if (totalWater % capacity != 0) {\n            requiredFill + 1\n        } else {\n            requiredFill\n        }\n    } else {\n        0\n    }\n}\n\n// Beispieltests\nfun main() {\n    println(maxFill(listOf(listOf(0, 0, 1, 0), listOf(0, 1, 0, 0), listOf(1, 1, 1, 1)), 1)) // Ausgabe: 6\n    println(maxFill(listOf(listOf(0, 0, 1, 1), listOf(0, 0, 0, 0), listOf(1, 1, 1, 1), listOf(0, 1, 1, 1)), 2)) // Ausgabe: 5\n    println(maxFill(listOf(listOf(0, 0, 0), listOf(0, 0, 0)), 5)) // Ausgabe: 0\n}"}
{"task_id": "kotlin/53", "language": "kotlin", "completion": "fun selectWords(s: String, n: Int): List<String> {\n    if (s.isEmpty()) return emptyList()\n    \n    val vowels = setOf('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U')\n    fun isConsonant(c: Char) = c !in vowels && c.isLetter()\n    \n    val words = s.split(\" \")\n    return words.filter { word -> \n        word.count { isConsonant(it) } == n \n    }\n}\n\n// Beispiele\nfun main() {\n    println(selectWords(\"Mary had a little lamb\", 4)) // [\"little\"]\n    println(selectWords(\"Mary had a little lamb\", 3)) // [\"Mary\", \"lamb\"]\n    println(selectWords(\"simple white space\", 2)) // []\n    println(selectWords(\"Hello world\", 4)) // [\"world\"]\n    println(selectWords(\"Uncle sam\", 3)) // [\"Uncle\"]\n}"}
{"task_id": "kotlin/54", "language": "kotlin", "completion": "fun maximum(arr: List<Int>, k: Int): List<Any> {\n    // Sortiere das Array in absteigender Reihenfolge\n    val sortedArr = arr.sortedByDescending { it }\n    \n    // W\u00e4hle die ersten k Elemente aus dem sortierten Array\n    return sortedArr.take(k).toList()\n}\n\n// Beispiel 1\nfun main() {\n    val result1 = maximum(listOf(-3, -4, 5), 3)\n    println(result1) // Ausgabe: [-4, -3, 5]\n}\n\n// Beispiel 2\nfun main() {\n    val result2 = maximum(listOf(4, -4, 4), 2)\n    println(result2) // Ausgabe: [4, 4]\n}\n\n// Beispiel 3\nfun main() {\n    val result3 = maximum(listOf(-3, 2, 1, 2, -1, -2, 1), 1)\n    println(result3) // Ausgabe: [2]\n}"}
{"task_id": "kotlin/55", "language": "kotlin", "completion": "fun addElements(arr: List<Int>, k: Int): Int {\n    // Filtere die ersten k Elemente, die nur h\u00f6chstens zwei Ziffern haben\n    val filteredList = arr.take(k).filter { it.toString().length <= 2 }\n    \n    // Summiere die gefilterten Elemente\n    return filteredList.sum()\n}\n\n// Beispielaufruf\nfun main() {\n    val arr = listOf(111, 21, 3, 4000, 5, 6, 7, 8, 9)\n    val k = 4\n    println(addElements(arr, k)) // Ausgabe: 24\n}"}
{"task_id": "kotlin/56", "language": "kotlin", "completion": "fun isPrime(n: Int): Boolean {\n    if (n <= 1) return false\n    if (n == 2) return true\n    if (n % 2 == 0) return false\n    for (i in 3..sqrt(n.toDouble()).toInt() step 2) {\n        if (n % i == 0) return false\n    }\n    return true\n}\n\nfun intersection(interval1: List<Int>, interval2: List<Int>): String {\n    val start1 = interval1[0]\n    val end1 = interval1[1]\n    val start2 = interval2[0]\n    val end2 = interval2[1]\n    \n    // Berechne die Schnittmenge der Intervalle\n    val intersectionStart = maxOf(start1, start2)\n    val intersectionEnd = minOf(end1, end2)\n    \n    if (intersectionStart > intersectionEnd) {\n        return \"NO\"\n    }\n    \n    // L\u00e4nge der Schnittmenge\n    val intersectionLength = intersectionEnd - intersectionStart + 1\n    \n    // \u00dcberpr\u00fcfe, ob die L\u00e4nge eine Primzahl ist\n    if (isPrime(intersectionLength)) {\n        return \"YES\"\n    } else {\n        return \"NO\"\n    }\n}\n\n// Beispielaufrufe\nfun main() {\n    println(intersection(listOf(1, 2), listOf(2, 3))) // \"NO\"\n    println(intersection(listOf(-1, 1), listOf(0, 4))) // \"NO\"\n    println(intersection(listOf(-3, -1), listOf(-5, 5))) // \"YES\"\n}"}
{"task_id": "kotlin/57", "language": "kotlin", "completion": "fun tri(n: Int): List<Any> {\n    val result = mutableListOf<Any>()\n    \n    for (i in 0..n) {\n        result.add(triValue(i))\n    }\n    \n    return result\n}\n\nfun triValue(n: Int): Any {\n    return when {\n        n == 0 -> 1\n        n == 1 -> 3\n        n % 2 == 0 -> 1 + (n / 2)\n        else -> triValue(n - 1) + triValue(n - 2) + triValue(n + 1)\n    }\n}\n\n// Beispielaufruf\nfun main() {\n    val n = 3\n    println(\"Tribonacci-Folge bis n=$n: ${tri(n)}\")\n}"}
{"task_id": "kotlin/58", "language": "kotlin", "completion": "fun digits(n: Int): Int {\n    // Wandle die Zahl in eine Zeichenkette um\n    val numStr = n.toString()\n    \n    // Filtere die ungeraden Ziffern heraus und berechne das Produkt\n    var product = 1\n    for (char in numStr) {\n        val digit = char.toInt() - '0'.toInt() // Wandle den Zeichen zu einer Ziffer um\n        if (digit % 2 != 0) {\n            product *= digit\n        }\n    }\n    \n    // Wenn das Produkt 1 ist, weil alle Ziffern gerade waren, gib 0 zur\u00fcck\n    return if (product == 1 && numStr.all { it.toInt() % 2 == 0 }) 0 else product\n}\n\n// Beispieltests\nfun main() {\n    println(digits(1))   // Ausgabe: 1\n    println(digits(4))   // Ausgabe: 0\n    println(digits(235)) // Ausgabe: 15\n}"}
{"task_id": "kotlin/59", "language": "kotlin", "completion": "fun isNested(string: String): Boolean {\n    // Wir verwenden einen Stack, um die ge\u00f6ffneten Klammern zu tracken\n    val stack = mutableListOf<Char>()\n    \n    for (char in string) {\n        if (char == '[') {\n            // Wenn eine \u00f6ffnende Klammer gefunden wird, f\u00fcgen wir sie zum Stack hinzu\n            stack.add(char)\n        } else if (char == ']') {\n            // Wenn eine schlie\u00dfende Klammer gefunden wird, pr\u00fcfen wir, ob der Stack nicht leer ist\n            if (stack.isNotEmpty()) {\n                // Wenn der Stack nicht leer ist und die oberste Klammer eine \u00f6ffnende Klammer ist, entfernen wir sie vom Stack\n                stack.removeAt(stack.size - 1)\n            } else {\n                // Wenn der Stack leer ist, bedeutet dies, dass es keine \u00fcbereinstimmende \u00f6ffnende Klammer gibt\n                return false\n            }\n        }\n    }\n    \n    // Wenn nach dem Durchlaufen des Strings der Stack nicht leer ist, bedeutet dies, dass mindestens eine Klammer nicht verschachtelt ist\n    return stack.isNotEmpty()\n}\n\n// Testf\u00e4lle\nfun main() {\n    println(isNested(\"[[]]\")) // \u279e True\n    println(isNested(\"[]]]]]]][[[[[]\")) // \u279e False\n    println(isNested(\"[][]\")) // \u279e False\n    println(isNested(\"[]\")) // \u279e False\n    println(isNested(\"[[][]]\")) // \u279e True\n    println(isNested(\"[[]][[\")) // \u279e True\n}"}
{"task_id": "kotlin/60", "language": "kotlin", "completion": "import kotlin.math.ceil\nimport kotlin.math.pow\n\nfun sumSquares(lst: List<Any>): Int {\n    return lst.map { ceil(it as Double).toInt() }.map { it.toDouble().pow(2) }.sum().toInt()\n}\n\n// Beispieltests\nfun main() {\n    println(sumSquares(listOf(1, 2, 3))) // Ausgabe: 14\n    println(sumSquares(listOf(1, 4, 9))) // Ausgabe: 98\n    println(sumSquares(listOf(1, 3, 5, 7))) // Ausgabe: 84\n    println(sumSquares(listOf(1.4, 4.2, 0))) // Ausgabe: 29\n    println(sumSquares(listOf(-2.4, 1, 1))) // Ausgabe: 6\n}"}
{"task_id": "kotlin/61", "language": "kotlin", "completion": "fun checkIfLastCharIsALetter(txt: String): Boolean {\n    // \u00dcberpr\u00fcfen, ob der Text leer ist\n    if (txt.isEmpty()) return false\n    \n    // Letztes Zeichen des Strings extrahieren\n    val lastChar = txt[txt.length - 1]\n    \n    // Pr\u00fcfen, ob das letzte Zeichen ein Buchstabe ist und nicht Teil eines Wortes\n    return lastChar.isLetter() && (txt.isEmpty() || !lastChar.toString().any { it.isLetterOrDigit() })\n}\n\n// Beispiele testen\nfun main() {\n    println(checkIfLastCharIsALetter(\"apple pie\")) // \u279e False\n    println(checkIfLastCharIsALetter(\"apple pi e\")) // \u279e True\n    println(checkIfLastCharIsALetter(\"apple pi e \")) // \u279e False\n    println(checkIfLastCharIsALetter(\"\")) // \u279e False\n}"}
{"task_id": "kotlin/62", "language": "kotlin", "completion": "fun canArrange(arr: List<Any>): Int {\n    if (arr.size < 2) return -1 // Wenn das Array weniger als 2 Elemente hat, gibt es keine L\u00f6sung\n    \n    var maxInvalidIndex = -1\n    \n    for (i in 1 until arr.size) {\n        if (arr[i] as Int > arr[i - 1] as Int) {\n            maxInvalidIndex = i\n        }\n    }\n    \n    return maxInvalidIndex\n}\n\n// Beispiele\nfun main() {\n    println(canArrange(listOf(1, 2, 4, 3, 5))) // Ausgabe: 3\n    println(canArrange(listOf(1, 2, 3)))       // Ausgabe: -1\n}"}
{"task_id": "kotlin/63", "language": "kotlin", "completion": "fun largestSmallestIntegers(lst: List<Any>): List<Int?> {\n    var maxNegative: Int? = null\n    var minPositive: Int? = null\n\n    for (item in lst) {\n        if (item is Int) {\n            when {\n                item < 0 -> {\n                    if (maxNegative == null || item > maxNegative) {\n                        maxNegative = item\n                    }\n                }\n                item > 0 -> {\n                    if (minPositive == null || item < minPositive) {\n                        minPositive = item\n                    }\n                }\n            }\n        }\n    }\n\n    return listOf(maxNegative, minPositive)\n}\n\n// Test cases\nfun main() {\n    println(largestSmallestIntegers(listOf(2, 4, 1, 3, 5, 7))) // Output: [null, 1]\n    println(largestSmallestIntegers(emptyList<Any>())) // Output: [null, null]\n    println(largestSmallestIntegers(listOf(0))) // Output: [null, null]\n}"}
{"task_id": "kotlin/64", "language": "kotlin", "completion": "fun specialFactorial(n : Int) : Int {\n    if (n <= 0) {\n        throw IllegalArgumentException(\"Der Wert von n muss gr\u00f6\u00dfer als 0 sein.\")\n    }\n    \n    fun factorial(num: Int): Int {\n        if (num == 0 || num == 1) return 1\n        var result = 1\n        for (i in 2..num) {\n            result *= i\n        }\n        return result\n    }\n    \n    var product = 1\n    for (i in 1..n) {\n        product *= factorial(i)\n    }\n    return product\n}\n\n// Beispielaufruf\nfun main() {\n    val result = specialFactorial(4)\n    println(result) // Ausgabe: 288\n}"}
{"task_id": "kotlin/65", "language": "kotlin", "completion": "fun wordsInSentence(sentence: String): String {\n    // Split the sentence into words\n    val words = sentence.split(\" \")\n    \n    // Filter words whose lengths are prime numbers\n    val resultWords = words.filter { isPrime(it.length) }\n    \n    // Join the filtered words back into a string\n    return resultWords.joinToString(\" \")\n}\n\n// Function to check if a number is a prime number\nfun isPrime(n: Int): Boolean {\n    if (n <= 1) return false\n    for (i in 2..Math.sqrt(n.toDouble()).toInt()) {\n        if (n % i == 0) return false\n    }\n    return true\n}\n\n// Example usage\nfun main() {\n    val sentence1 = \"This is a test\"\n    println(wordsInSentence(sentence1)) // Output: \"is\"\n    \n    val sentence2 = \"lets go for swimming\"\n    println(wordsInSentence(sentence2)) // Output: \"go for\"\n}"}
{"task_id": "kotlin/66", "language": "kotlin", "completion": "fun simplify(x : String, n : String) : Boolean {\n    // Funktion zum Parsen einer Bruchzahl aus einem String\n    fun parseFraction(fraction: String): Pair<Int, Int> {\n        val parts = fraction.split(\"/\")\n        val numerator = parts[0].toInt()\n        val denominator = parts[1].toInt()\n        return Pair(numerator, denominator)\n    }\n    \n    // Parsen der Bruchzahlen aus den Strings\n    val (xNumerator, xDenominator) = parseFraction(x)\n    val (nNumerator, nDenominator) = parseFraction(n)\n    \n    // Berechnung des Z\u00e4hlers und Nenners des Produkts\n    val resultNumerator = xNumerator * nNumerator\n    val resultDenominator = xDenominator * nDenominator\n    \n    // \u00dcberpr\u00fcfen, ob das Ergebnis eine ganze Zahl ist\n    return resultNumerator % resultDenominator == 0\n}\n\n// Testf\u00e4lle\nfun main() {\n    println(simplify(\"1/5\", \"5/1\")) // True\n    println(simplify(\"1/6\", \"2/1\")) // False\n    println(simplify(\"7/10\", \"10/2\")) // False\n}"}
{"task_id": "kotlin/67", "language": "kotlin", "completion": "fun orderByPoints(nums: List<Int>): List<Int> {\n    return nums.sortedWith(compareBy({ sumOfDigits(it) }, { nums.indexOf(it) }))\n}\n\nfun sumOfDigits(n: Int): Int {\n    var sum = 0\n    var num = n\n    while (num != 0) {\n        sum += Math.abs(num % 10)\n        num /= 10\n    }\n    return sum\n}\n\n// Beispieltests\nfun main() {\n    println(orderByPoints(listOf(1, 11, -1, -11, -12))) // Output: [-1, -11, 1, -12, 11]\n    println(orderByPoints(listOf())) // Output: []\n}"}
{"task_id": "kotlin/68", "language": "kotlin", "completion": "fun specialFilter(nums: List<Int>): Int {\n    return nums.count { num -> \n        val strNum = num.toString()\n        num > 10 && isOddDigit(strNum[0]) && isOddDigit(strNum[strNum.length - 1])\n    }\n}\n\nfun isOddDigit(char: Char): Boolean {\n    val digit = char.toInt()\n    return digit in listOf(1, 3, 5, 7, 9)\n}\n\n// Beispielaufrufe\nfun main() {\n    println(specialFilter(listOf(15, -73, 14, -15))) // Ausgabe: 1\n    println(specialFilter(listOf(33, -2, -3, 45, 21, 109))) // Ausgabe: 2\n}"}
{"task_id": "kotlin/69", "language": "kotlin", "completion": "fun getMaxTriples(n: Int): Int {\n    // Erstellen Sie das Array a\n    val a = IntArray(n) { i -> i * i - i + 1 }\n    \n    var count = 0\n    \n    // Durchlaufen Sie alle m\u00f6glichen Tripel (i, j, k) mit i < j < k\n    for (i in 0 until n) {\n        for (j in i+1 until n) {\n            for (k in j+1 until n) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++\n                }\n            }\n        }\n    }\n    \n    return count\n}\n\n// Beispielaufruf\nfun main() {\n    val n = 5\n    println(getMaxTriples(n)) // Ausgabe: 1\n}"}
{"task_id": "kotlin/70", "language": "kotlin", "completion": "fun bf(planet1 : String, planet2 : String) : List<Any> {\n    val planets = listOf(\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n    \n    // Pr\u00fcfen, ob die angegebenen Planeten korrekt sind\n    if (!planets.contains(planet1) || !planets.contains(planet2)) {\n        return emptyList()\n    }\n    \n    // Finden der Indizes der beiden Planeten\n    val index1 = planets.indexOf(planet1)\n    val index2 = planets.indexOf(planet2)\n    \n    // Bestimmen des Bereichs, in dem die Zwischenplaneten liegen\n    val startIndex = minOf(index1, index2) + 1\n    val endIndex = maxOf(index1, index2) - 1\n    \n    // Sammeln der Planeten im Bereich zwischen den beiden angegebenen Planeten\n    val result = mutableListOf<String>()\n    if (startIndex <= endIndex) {\n        for (i in startIndex..endIndex) {\n            result.add(planets[i])\n        }\n    }\n    \n    return result\n}\n\n// Beispielaufrufe\nfun main() {\n    println(bf(\"Jupiter\", \"Neptune\")) // ==> (\"Saturn\", \"Uranus\")\n    println(bf(\"Earth\", \"Mercury\")) // ==> (\"Venus\")\n    println(bf(\"Mercury\", \"Uranus\")) // ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n}"}
{"task_id": "kotlin/71", "language": "kotlin", "completion": "fun isPrime(n: Int): Boolean {\n    if (n <= 1) return false\n    if (n == 2) return true\n    if (n % 2 == 0) return false\n    for (i in 3..sqrt(n.toDouble()).toInt() step 2) {\n        if (n % i == 0) return false\n    }\n    return true\n}\n\nfun xOrY(n: Int, x: Int, y: Int): Int {\n    return if (isPrime(n)) x else y\n}\n\n// Beispiele\nfun main() {\n    println(xOrY(7, 34, 12)) // Ausgabe: 34\n    println(xOrY(15, 8, 5))   // Ausgabe: 5\n}"}
{"task_id": "kotlin/72", "language": "kotlin", "completion": "fun doubleTheDifference(lst: List<Any>): Int {\n    return lst.filter { it is Int && it >= 0 } // Filtere die Liste, um nur nichtnegative ganze Zahlen zu behalten\n        .map { it as Int } // Wandle die Elemente in Ganzzahlen um\n        .filter { it % 2 != 0 } // Filter f\u00fcr ungerade Zahlen\n        .map { it * it } // Quadriere die ungeraden Zahlen\n        .sum() // Summiere die quadrierten ungeraden Zahlen\n}\n\n// Testf\u00e4lle\nfun main() {\n    println(doubleTheDifference(listOf(1, 3, 2, 0))) // Ausgabe: 10\n    println(doubleTheDifference(listOf(-1, -2, 0))) // Ausgabe: 0\n    println(doubleTheDifference(listOf(9, -2))) // Ausgabe: 81\n    println(doubleTheDifference(listOf(0))) // Ausgabe: 0\n}"}
{"task_id": "kotlin/73", "language": "kotlin", "completion": "fun strongestExtension(className: String, extensions: List<String>): String {\n    // Funktion zum Z\u00e4hlen von Gro\u00df- und Kleinbuchstaben in einem String\n    fun countCase(s: String): Pair<Int, Int> {\n        var capCount = 0\n        var smCount = 0\n        for (char in s) {\n            if (char.isUpperCase()) {\n                capCount++\n            } else if (char.isLowerCase()) {\n                smCount++\n            }\n        }\n        return Pair(capCount, smCount)\n    }\n\n    // Liste zum Speichern der Erweiterungen und ihrer St\u00e4rken\n    val extensionStrengths = mutableListOf<Pair<String, Int>>()\n\n    for (extension in extensions) {\n        val (capCount, smCount) = countCase(extension)\n        val strength = capCount - smCount\n        extensionStrengths.add(Pair(extension, strength))\n    }\n\n    // Finde die Erweiterung mit der h\u00f6chsten St\u00e4rke\n    var strongestExtension = \"\"\n    var maxStrength = Int.MIN_VALUE\n\n    for ((ext, strength) in extensionStrengths) {\n        if (strength > maxStrength) {\n            maxStrength = strength\n            strongestExtension = ext\n        }\n    }\n\n    // Gib das Ergebnis zur\u00fcck\n    return \"$className.$strongestExtension\"\n}\n\n// Beispielaufruf\nfun main() {\n    println(strongestExtension(\"my_class\", listOf(\"AA\", \"Be\", \"CC\")))  // Ausgabe: my_class.AA\n    println(strongestExtension(\"Slices\", listOf(\"SErviNGSliCes\", \"Cheese\", \"StuFfed\")))  // Ausgabe: Slices.SErviNGSliCes\n}"}
{"task_id": "kotlin/74", "language": "kotlin", "completion": "fun cycpatternCheck(a : String, b : String) : Boolean {\n    // \u00dcberpr\u00fcfen, ob b ein Teilstring von a ist\n    if (a.contains(b)) {\n        return true\n    }\n    \n    // Wenn nicht, \u00fcberpr\u00fcfen wir alle Rotationen von b\n    val length = b.length\n    for (i in 1 until length) {\n        val rotatedB = b.substring(i) + b.substring(0, i)\n        if (a.contains(rotatedB)) {\n            return true\n        }\n    }\n    \n    // Wenn keine Rotation von b im a enthalten ist, geben wir False zur\u00fcck\n    return false\n}\n\n// Testf\u00e4lle\nfun main() {\n    println(cycpatternCheck(\"abcd\", \"abd\")) // False\n    println(cycpatternCheck(\"hello\", \"ell\")) // True\n    println(cycpatternCheck(\"whassup\", \"psus\")) // False\n    println(cycpatternCheck(\"abab\", \"baa\")) // True\n    println(cycpatternCheck(\"efef\", \"eeff\")) // False\n    println(cycpatternCheck(\"himenss\", \"simen\")) // True\n}"}
{"task_id": "kotlin/75", "language": "kotlin", "completion": "fun intToMiniRoman(number: Int): String {\n    val romanMap = listOf(\n        1000 to \"m\", 900 to \"cm\", 500 to \"d\", 400 to \"cd\",\n        100 to \"c\", 90 to \"xc\", 50 to \"l\", 40 to \"xl\",\n        10 to \"x\", 9 to \"ix\", 5 to \"v\", 4 to \"iv\", 1 to \"i\"\n    )\n    \n    var num = number\n    val result = StringBuilder()\n    \n    for ((value, symbol) in romanMap) {\n        while (num >= value) {\n            result.append(symbol)\n            num -= value\n        }\n    }\n    \n    return result.toString().toLowerCase()\n}\n\n// Beispiele\nfun main() {\n    println(intToMiniRoman(19))  // Ausgabe: xix\n    println(intToMiniRoman(152)) // Ausgabe: clii\n    println(intToMiniRoman(426)) // Ausgabe: cdxxvi\n}"}
{"task_id": "kotlin/76", "language": "kotlin", "completion": "fun rightAngleTriangle(a : Int, b : Int, c : Int) : Boolean {\n    // Wir m\u00fcssen sicherstellen, dass a, b und c der Gr\u00f6\u00dfe nach sortiert sind\n    val sides = listOf(a, b, c).sorted()\n    \n    // Anwenden der Pythagoreischen Formel: a^2 + b^2 == c^2\n    return sides[0] * sides[0] + sides[1] * sides[1] == sides[2] * sides[2]\n}"}
{"task_id": "kotlin/77", "language": "kotlin", "completion": "fun solve(s: String): String {\n    val charArray = s.toCharArray()\n    var hasLetter = false\n    \n    for (char in charArray) {\n        if (char.isLetter()) {\n            hasLetter = true\n            break\n        }\n    }\n    \n    if (!hasLetter) {\n        return String(charArray.reversed())\n    } else {\n        val result = StringBuilder()\n        for (char in charArray) {\n            when {\n                char.isUpperCase() -> result.append(char.toLowerCase())\n                char.isLowerCase() -> result.append(char.toUpperCase())\n                else -> result.append(char)\n            }\n        }\n        return result.toString()\n    }\n}\n\n// Beispiele\nfun main() {\n    println(solve(\"1234\")) // \"4321\"\n    println(solve(\"ab\")) // \"AB\"\n    println(solve(\"#a@C\")) // \"#A@c\"\n}"}
{"task_id": "kotlin/78", "language": "kotlin", "completion": "import java.security.MessageDigest\nimport java.security.NoSuchAlgorithmException\n\nfun stringToMd5(text: String): String? {\n    if (text.isEmpty()) {\n        return null\n    }\n\n    try {\n        val md = MessageDigest.getInstance(\"MD5\")\n        val bytes = text.toByteArray()\n        val digest = md.digest(bytes)\n        return digest.joinToString(\"\") { String.format(\"%02x\", it) }\n    } catch (e: NoSuchAlgorithmException) {\n        // MD5 sollte immer verf\u00fcgbar sein, aber wir sch\u00fctzen uns vor unbeabsichtigten Fehlern\n        e.printStackTrace()\n        return null\n    }\n}\n\n// Beispielaufrufe\nfun main() {\n    println(stringToMd5(\"Hello world\")) // Ausgabe: 3e25960a79dbc69b674cd4ec67a72c62\n    println(stringToMd5(\"\"))             // Ausgabe: null\n}"}
{"task_id": "kotlin/79", "language": "kotlin", "completion": "fun generateIntegers(a: Int, b: Int): List<Int> {\n    val start = if (a <= b) a else b\n    val end = if (a >= b) a else b\n    \n    val result = mutableListOf<Int>()\n    \n    for (i in start..end) {\n        if (i % 2 == 0) {\n            result.add(i)\n        }\n    }\n    \n    return result\n}\n\n// Beispielaufrufe\nfun main() {\n    println(generateIntegers(2, 8)) // [2, 4, 6, 8]\n    println(generateIntegers(8, 2)) // [2, 4, 6, 8]\n    println(generateIntegers(10, 14)) // []\n}"}
